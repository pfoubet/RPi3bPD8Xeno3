|| OP_NULL, saw a "do". */
				/*  On OP_EXISTS, treat av as av, not avhv.  */
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@ */
                                /*  On pushre, rx is used as part of split, e.g. split " " */
				/*  On regcomp, "use re 'eval'" was in scope */
				/*  On OP_READLINE, was <$filehandle> */
				/*  On RV2[ACGHS]V, don't create GV--in
				    defined()*/
				/*  On OP_DBSTATE, indicates breakpoint
				 *    (runtime property) */
				/*  On OP_REQUIRE, was seen as CORE::require */
				/*  On OP_(ENTER|LEAVE)WHEN, there's
				    no condition */
				/*  On OP_SMARTMATCH, an implicit smartmatch */
				/*  On OP_ANONHASH and OP_ANONLIST, create a
				    reference to the new anon hash or array */
				/*  On OP_HELEM and OP_HSLICE, localization will be followed
				    by assignment, so do not wipe the target if it is special
				    (e.g. a glob or a magic SV) */
				/*  On OP_MATCH, OP_SUBST & OP_TRANS, the
				    operand of a logical or conditional
				    that was optimised away, so it should
				    not be bound via =~ */
				/*  On OP_CONST, from a constant CV */
				/*  On OP_GLOB, two meanings:
				    - Before ck_glob, called as CORE::glob
				    - After ck_glob, use Perl glob function
			         */
                                /*  On OP_PADRANGE, push @_ */
                                /*  On OP_DUMP, has no label */

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT

#define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())

/* Lower bits of op_private often carry the number of arguments, as
 * set by newBINOP, newUNOP and ck_fun */

/* NOTE: OP_NEXTSTATE and OP_DBSTATE (i.e. COPs) carry NATIVE_HINTS
 * in op_private */

/* Private for lvalues */
#define OPpLVAL_INTRO	128	/* Lvalue must be localized or lvalue sub */

/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */

/* Private for OP_LEAVE, OP_LEAVESUB, OP_LEAVESUBLV and OP_LEAVEWRITE */
#define OPpREFCOUNTED		64	/* op_targ carries a refcount */

/* Private for OP_LEAVE and OP_LEAVELOOP */
#define OPpLVALUE		128	/* Do not copy return value */

/* Private for OP_AASSIGN */
#define OPpASSIGN_COMMON	64	/* Left & right have syms in common. */

/* Private for OP_SASSIGN */
#define OPpASSIGN_BACKWARDS	64	/* Left & right switched. */
#define OPpASSIGN_CV_TO_GV	128	/* Possible optimisation for constants. */

/* Private for OP_MATCH and OP_SUBST{,CONT} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

/* Private for OP_TRANS */
#define OPpTRANS_FROM_UTF	1
#define OPpTRANS_TO_UTF		2
#define OPpTRANS_IDENTICAL	4	/* right side is same as left */
#define OPpTRANS_SQUASH		8
    /* 16 is used for OPpTARGET_MY */
#define OPpTRANS_COMPLEMENT	32
#define OPpTRANS_GROWS		64
#define OPpTRANS_DELETE		128
#define OPpTRANS_ALL	(OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|OPpTRANS_SQUASH|OPpTRANS_COMPLEMENT|OPpTRANS_GROWS|OPpTRANS_DELETE)

/* Private for OP_REPEAT */
#define OPpREPEAT_DOLIST	64	/* List replication. */

/* Private for OP_RV2GV, OP_RV2SV, OP_AELEM, OP_HELEM, OP_PADSV */
#define OPpDEREF		(32|64)	/* autovivify: Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */

/* OP_ENTERSUB and OP_RV2CV flags

Flags are set on entersub and rv2cv in three phases:
  parser  - the parser passes the flag to the op constructor
  check   - the check routine called by the op constructor sets the flag
  context - application of scalar/ref/lvalue context applies the flag

In the third stage, an entersub op might turn into an rv2cv op (undef &foo,
\&foo, lock &foo, exists &foo, defined &foo).  The two places where that
happens (op_lvalue_flags and doref in op.c) need to make sure the flags do
not conflict.  Flags applied in the context phase are only set when there
is no conversion of op type.

  bit  entersub flag       phase   rv2cv flag             phase
  ---  -------------       -----   ----------             -----
    1  OPpENTERSUB_INARGS  context OPpMAY_RETURN_CONSTANT context
    2  HINT_STRICT_REFS    check   HINT_STRICT_REFS       check
    4  OPpENTERSUB_HASTARG check
    8                              OPpENTERSUB_AMPER      parser
   16  OPpENTERSUB_DB      check
   32  OPpDEREF_AV         context
   64  OPpDEREF_HV         context
  128  OPpLVAL_INTRO       context OPpENTERSUB_NOPAREN    parser

*/

  /* OP_ENTERSUB only */
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
#define OPpENTERSUB_HASTARG	4	/* Called from OP tree. */
#define OPpENTERSUB_INARGS	1	/* Lval used as arg to a sub. */
/* used by OPpDEREF             (32|64) */
/* used by HINT_STRICT_REFS     2          */
  /* Mask for OP_ENTERSUB flags, the absence of which must be propagated
     in dynamic context */
#define OPpENTERSUB_LVAL_MASK (OPpLVAL_INTRO|OPpENTERSUB_INARGS)

  /* OP_RV2CV only */
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

  /* OP_GV only */
#define OPpEARLY_CV		32	/* foo() called before sub foo was parsed */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* OP_RV2[AH]V OP_[AH]SLICE */
#define OPpSLICEWARNING		4	/* warn about @hash{$scalar} */
  /* OP_RV2[SAH]V, OP_GVSV, OP_ENTERITER only */
#define OPpOUR_INTRO		16	/* Variable was in an our() */
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM, OP_[AH]SLICE OP_AV2ARYLEN,
     OP_R?KEYS, OP_SUBSTR, OP_POS, OP_VEC */
#define OPpMAYBE_LVSUB		8	/* We might be an lvalue to return */
  /* OP_RV2HV and OP_PADHV */
#define OPpTRUEBOOL		32	/* %hash in (%hash || $foo) in
					   void context */
#define OPpMAYBE_TRUEBOOL	64	/* %hash in (%hash || $foo) where
					   cx is not known till run time */

  /* OP_SUBSTR only */
#define OPpSUBSTR_REPL_FIRST	16	/* 1st arg is replacement string */

  /* OP_PADSV only */
#define OPpPAD_STATE		16	/* is a "state" pad */
  /* for OP_RV2?V, lower bits carry hints (currently only HINT_STRICT_REFS) */

  /* OP_PADRANGE only */
  /* bit 7 is OPpLVAL_INTRO */
#define OPpPADRANGE_COUNTMASK	127	/* bits 6..0 hold target range, */
#define OPpPADRANGE_COUNTSHIFT	7	/* 7 bits in total */

  /* OP_RV2GV only */
#define OPpDONT_INIT_GV		4	/* Call gv_fetchpv with GV_NOINIT */
/* (Therefore will return whatever is currently in the symbol table, not
   guaranteed to be a PVGV)  */
#define OPpALLOW_FAKE		16	/* OK to return fake glob */

/* Private for OP_ENTERITER and OP_ITER */
#define OPpITER_REVERSED	4	/* for (reverse ...) */
#define OPpITER_DEF		8	/* for $_ or for my $_ */

/* Private for OP_CONST */
#define	OPpCONST_NOVER		2	/* no 6; */
#define	OPpCONST_SHORTCIRCUIT	4	/* eg the constant 5 in (5 || foo) */
#define	OPpCONST_STRICT		8	/* bareword subject to strict 'subs' */
#define OPpCONST_ENTERED	16	/* Has been entered as symbol. */
#define OPpCONST_BARE		64	/* Was a bare word (filehandle?). */

/* Private for OP_FLIP/FLOP */
#define OPpFLIP_LINENUM		64	/* Range arg potentially a line num. */

/* Private for OP_LIST */
#define OPpLIST_GUESSED		64	/* Guessed that pushmark was needed. */

/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */
/* Also OPpLVAL_INTRO (128) */

/* Private for OP_EXISTS */
#define OPpEXISTS_SUB		64	/* Checking for &sub, not {} or [].  */

/* Private for OP_SORT */
#define OPpSORT_NUMERIC		1	/* Optimized away { $a <=> $b } */
#define OPpSORT_INTEGER		2	/* Ditto while under "use integer" */
#define OPpSORT_REVERSE		4	/* Reversed sort */
#define OPpSORT_INPLACE		8	/* sort in-place; eg @a = sort @a */
#define OPpSORT_DESCEND		16	/* Descending sort */
#define OPpSORT_QSORT		32	/* Use quicksort (not mergesort) */
#define OPpSORT_STABLE		64	/* Use a stable algorithm */

/* Private for OP_REVERSE */
#define OPpREVERSE_INPLACE	8	/* reverse in-place (@a = reverse @a) */

/* Private for OP_OPEN and OP_BACKTICK */
#define OPpOPEN_IN_RAW		16	/* binmode(F,":raw") on input fh */
#define OPpOPEN_IN_CRLF		32	/* binmode(F,":crlf") on input fh */
#define OPpOPEN_OUT_RAW		64	/* binmode(F,":raw") on output fh */
#define OPpOPEN_OUT_CRLF	128	/* binmode(F,":crlf") on output fh */

/* Private for COPs */
#define OPpHUSH_VMSISH		32	/* hush DCL exit msg vmsish mode*/
/* Note: Used for NATIVE_HINTS (shifted from the values in PL_hints),
	 currently defined by vms/vmsish.h:
				64
				128
 */

/* Private for OP_FTXXX */
#define OPpFT_ACCESS		2	/* use filetest 'access' */
#define OPpFT_STACKED		4	/* stacked filetest, as "-f" in "-f -x $f" */
#define OPpFT_STACKING		8	/* stacking filetest, as "-x" in "-f -x $f" */
#define OPpFT_AFTER_t		16	/* previous op was -t */

/* Private for OP_(MAP|GREP)(WHILE|START) */
#define OPpGREP_LEX		2	/* iterate over lexical $_ */
    
/* Private for OP_ENTEREVAL */
#define OPpEVAL_HAS_HH		2	/* Does it have a copy of %^H */
#define OPpEVAL_UNICODE		4
#define OPpEVAL_BYTES		8
#define OPpEVAL_COPHH		16	/* Construct %^H from cop hints */
#define OPpEVAL_RE_REPARSING	32	/* eval_sv(..., G_RE_REPARSING) */
    
/* Private for OP_CALLER, OP_WANTARRAY and OP_RUNCV */
#define OPpOFFBYONE		128	/* Treat caller(1) as caller(2) */

/* Private for OP_COREARGS */
/* These must not conflict with OPpDONT_INIT_GV or OPpALLOW_FAKE.
   See pp.c:S_rv2gv. */
#define OPpCOREARGS_DEREF1	1	/* Arg 1 is a handle constructor */
#define OPpCOREARGS_DEREF2	2	/* Arg 2 is a handle constructor */
#define OPpCOREARGS_SCALARMOD	64	/* \$ rather than \[$@%*] */
#define OPpCOREARGS_PUSHMARK	128	/* Call pp_pushmark */

/* Private for OP_(LAST|REDO|NEXT|GOTO|DUMP) */
#define OPpPV_IS_UTF8		128	/* label is in UTF8 */

/* Private for OP_SPLIT */
#define OPpSPLIT_IMPLIM		128	/* implicit limit */

struct op {
    BASEOP
};

struct unop {
    BASEOP
    OP *	op_first;
};

struct binop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct logop {
    BASEOP
    OP *	op_first;
    OP *	op_other;
};

struct listop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct pmop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
#ifdef USE_ITHREADS
    PADOFFSET   op_pmoffset;
#else
    REGEXP *    op_pmregexp;            /* compiled expression */
#endif
    U32         op_pmflags;
    union {
	OP *	op_pmreplroot;		/* For OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET  op_pmtargetoff;	/* For OP_PUSHRE */
#else
	GV *	op_pmtargetgv;
#endif
    }	op_pmreplrootu;
    union {
	OP *	op_pmreplstart;	/* Only used in OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET op_pmstashoff; /* Only used in OP_MATCH, with PMf_ONCE set */
#else
	HV *	op_pmstash;
#endif
    }		op_pmstashstartu;
    OP *	op_code_list;	/* list of (?{}) code blocks */
};

#ifdef USE_ITHREADS
#define PM_GETRE(o)	(SvTYPE(PL_regex_pad[(o)->op_pmoffset]) == SVt_REGEXP \
		 	 ? (REGEXP*)(PL_regex_pad[(o)->op_pmoffset]) : NULL)
/* The assignment is just to enforce type safety (or at least get a warning).
 */
/* With first class regexps not via a reference one needs to assign
   &PL_sv_undef under ithreads. (This would probably work unthreaded, but NULL
   is cheaper. I guess we could allow NULL, but the check above would get
   more complex, and we'd have an AV with (SV*)NULL in it, which feels bad */
/* BEWARE - something that calls this macro passes (r) which has a side
   effect.  */
#define PM_SETRE(o,r)	STMT_START {					\
                            REGEXP *const _pm_setre = (r);		\
                            assert(_pm_setre);				\
			    PL_regex_pad[(o)->op_pmoffset] = MUTABLE_SV(_pm_setre); \
                        } STMT_END
#else
#define PM_GETRE(o)     ((o)->op_pmregexp)
#define PM_SETRE(o,r)   ((o)->op_pmregexp = (r))
#endif

/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+6)

/* 'use re "taint"' in scope: taint $1 etc. if target tainted */
#define PMf_RETAINT	(1<<(PMf_BASE_SHIFT+0))

/* match successfully only once per reset, with related flag RXf_USED in
 * re->extflags holding state.  This is used only for ?? matches, and only on
 * OP_MATCH and OP_QR */
#define PMf_ONCE	(1<<(PMf_BASE_SHIFT+1))

/* PMf_ONCE, i.e. ?pat?, has matched successfully.  Not used under threading. */
#define PMf_USED        (1<<(PMf_BASE_SHIFT+3))

/* subst replacement is constant */
#define PMf_CONST	(1<<(PMf_BASE_SHIFT+4))

/* keep 1st runtime pattern forever */
#define PMf_KEEP	(1<<(PMf_BASE_SHIFT+5))

#define PMf_GLOBAL	(1<<(PMf_BASE_SHIFT+6))	/* pattern had a g modifier */

/* don't reset pos() if //g fails */
#define PMf_CONTINUE	(1<<(PMf_BASE_SHIFT+7))

/* evaluating replacement as expr */
#define PMf_EVAL	(1<<(PMf_BASE_SHIFT+8))

/* Return substituted string instead of modifying it. */
#define PMf_NONDESTRUCT	(1<<(PMf_BASE_SHIFT+9))

/* the pattern has a CV attached (currently only under qr/...(?{}).../) */
#define PMf_HAS_CV	(1<<(PMf_BASE_SHIFT+10))

/* op_code_list is private; don't free it etc. It may well point to
 * code within another sub, with different pad etc */
#define PMf_CODELIST_PRIVATE	(1<<(PMf_BASE_SHIFT+11))

/* the PMOP is a QR (we should be able to detect that from the op type,
 * but the regex compilation API passes just the pm flags, not the op
 * itself */
#define PMf_IS_QR	(1<<(PMf_BASE_SHIFT+12))
#define PMf_USE_RE_EVAL	(1<<(PMf_BASE_SHIFT+13)) /* use re'eval' in scope */

#if PMf_BASE_SHIFT+13 > 31
#   error Too many PMf_ bits used.  See above and regnodes.h for any spare in middle
#endif

#ifdef USE_ITHREADS

#  define PmopSTASH(o)         ((o)->op_pmflags & PMf_ONCE                         \
                                ? PL_stashpad[(o)->op_pmstashstartu.op_pmstashoff]   \
                                : NULL)
#  define PmopSTASH_set(o,hv)	\
	(assert_((o)->op_pmflags & PMf_ONCE)				\
	 (o)->op_pmstashstartu.op_pmstashoff =				\
	    (hv) ? alloccopstash(hv) : 0)
#else
#  define PmopSTASH(o)							\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstash : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASH_set(o,hv)		({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstash = (hv));			\
    })
#  else
#    define PmopSTASH_set(o,hv)	((o)->op_pmstashstartu.op_pmstash = (hv))
#  endif
#endif
#define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
#define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))

struct svop {
    BASEOP
    SV *	op_sv;
};

struct padop {
    BASEOP
    PADOFFSET	op_padix;
};

struct pvop {
    BASEOP
    char *	op_pv;
};

struct loop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    OP *	op_redoop;
    OP *	op_nextop;
    OP *	op_lastop;
};

#define cUNOPx(o)	((UNOP*)o)
#define cBINOPx(o)	((BINOP*)o)
#define cLISTOPx(o)	((LISTOP*)o)
#define cLOGOPx(o)	((LOGOP*)o)
#define cPMOPx(o)	((PMOP*)o)
#define cSVOPx(o)	((SVOP*)o)
#define cPADOPx(o)	((PADOP*)o)
#define cPVOPx(o)	((PVOP*)o)
#define cCOPx(o)	((COP*)o)
#define cLOOPx(o)	((LOOP*)o)

#define cUNOP		cUNOPx(PL_op)
#define cBINOP		cBINOPx(PL_op)
#define cLISTOP		cLISTOPx(PL_op)
#define cLOGOP		cLOGOPx(PL_op)
#define cPMOP		cPMOPx(PL_op)
#define cSVOP		cSVOPx(PL_op)
#define cPADOP		cPADOPx(PL_op)
#define cPVOP		cPVOPx(PL_op)
#define cCOP		cCOPx(PL_op)
#define cLOOP		cLOOPx(PL_op)

#define cUNOPo		cUNOPx(o)
#define cBINOPo		cBINOPx(o)
#define cLISTOPo	cLISTOPx(o)
#define cLOGOPo		cLOGOPx(o)
#define cPMOPo		cPMOPx(o)
#define cSVOPo		cSVOPx(o)
#define cPADOPo		cPADOPx(o)
#define cPVOPo		cPVOPx(o)
#define cCOPo		cCOPx(o)
#define cLOOPo		cLOOPx(o)

#define kUNOP		cUNOPx(kid)
#define kBINOP		cBINOPx(kid)
#define kLISTOP		cLISTOPx(kid)
#define kLOGOP		cLOGOPx(kid)
#define kPMOP		cPMOPx(kid)
#define kSVOP		cSVOPx(kid)
#define kPADOP		cPADOPx(kid)
#define kPVOP		cPVOPx(kid)
#define kCOP		cCOPx(kid)
#define kLOOP		cLOOPx(kid)


#ifdef USE_ITHREADS
#  define	cGVOPx_gv(o)	((GV*)PAD_SVl(cPADOPx(o)->op_padix))
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && isGV_with_GP(v) \
				 && GvIN_PAD(v))
#  define	IS_PADCONST(v) \
	(v && (SvREADONLY(v) || (SvIsCOW(v) && !SvLEN(v))))
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv \
				 ? cSVOPx(v)->op_sv : PAD_SVl((v)->op_targ))
#  define	cSVOPx_svp(v)	(cSVOPx(v)->op_sv \
				 ? &cSVOPx(v)->op_sv : &PAD_SVl((v)->op_targ))
#else
#  define	cGVOPx_gv(o)	((GV*)cSVOPx(o)->op_sv)
#  define	IS_PADGV(v)	FALSE
#  define	IS_PADCONST(v)	FALSE
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv)
#  define	cSVOPx_svp(v)	(&cSVOPx(v)->op_sv)
#endif

#define	cGVOP_gv		cGVOPx_gv(PL_op)
#define	cGVOPo_gv		cGVOPx_gv(o)
#define	kGVOP_gv		cGVOPx_gv(kid)
#define cSVOP_sv		cSVOPx_sv(PL_op)
#define cSVOPo_sv		cSVOPx_sv(o)
#define kSVOP_sv		cSVOPx_sv(kid)

#ifndef PERL_CORE
#  define Nullop ((OP*)NULL)
#endif

/* Lowest byte of PL_opargs */
#define OA_MARK 1
#define OA_FOLDCONST 2
#define OA_RETSCALAR 4
#define OA_TARGET 8
#define OA_TARGLEX 16
#define OA_OTHERINT 32
#define OA_DANGEROUS 64
#define OA_DEFGV 128

/* The next 4 bits encode op class information */
#define OCSHIFT 8

#define OA_CLASS_MASK (15 << OCSHIFT)

#define OA_BASEOP (0 << OCSHIFT)
#define OA_UNOP (1 << OCSHIFT)
#define OA_BINOP (2 << OCSHIFT)
#define OA_LOGOP (3 << OCSHIFT)
#define OA_LISTOP (4 << OCSHIFT)
#define OA_PMOP (5 << OCSHIFT)
#define OA_SVOP (6 << OCSHIFT)
#define OA_PADOP (7 << OCSHIFT)
#define OA_PVOP_OR_SVOP (8 << OCSHIFT)
#define OA_LOOP (9 << OCSHIFT)
#define OA_COP (10 << OCSHIFT)
#define OA_BASEOP_OR_UNOP (11 << OCSHIFT)
#define OA_FILESTATOP (12 << OCSHIFT)
#define OA_LOOPEXOP (13 << OCSHIFT)

#define OASHIFT 12

/* Remaining nybbles of PL_opargs */
#define OA_SCALAR 1
#define OA_LIST 2
#define OA_AVREF 3
#define OA_HVREF 4
#define OA_CVREF 5
#define OA_FILEREF 6
#define OA_SCALARREF 7
#define OA_OPTIONAL 8

/* Op_REFCNT is a reference count at the head of each op tree: needed
 * since the tree is shared between threads, and between cloned closure
 * copies in the same thread. OP_REFCNT_LOCK/UNLOCK is used when modifying
 * this count.
 * The same mutex is used to protect the refcounts of the reg_trie_data
 * and reg_ac_data structures, which are shared between duplicated
 * regexes.
 */

#ifdef USE_ITHREADS
#  define OP_REFCNT_INIT		MUTEX_INIT(&PL_op_mutex)
#  ifdef PERL_CORE
#    define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#    define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  else
#    define OP_REFCNT_LOCK		op_refcnt_lock()
#    define OP_REFCNT_UNLOCK		op_refcnt_unlock()
#  endif
#  define OP_REFCNT_TERM		MUTEX_DESTROY(&PL_op_mutex)
#else
#  define OP_REFCNT_INIT		NOOP
#  define OP_REFCNT_LOCK		NOOP
#  define OP_REFCNT_UNLOCK		NOOP
#  define OP_REFCNT_TERM		NOOP
#endif

#define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#ifdef PERL_DEBUG_READONLY_OPS
#  define OpREFCNT_inc(o)		Perl_op_refcnt_inc(aTHX_ o)
#  define OpREFCNT_dec(o)		Perl_op_refcnt_dec(aTHX_ o)
#else
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : NULL)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#endif

/* flags used by Perl_load_module() */
#define PERL_LOADMOD_DENY		0x1	/* no Module */
#define PERL_LOADMOD_NOIMPORT		0x2	/* use Module () */
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* use Module (...) */

#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_TOKE_C)
#define ref(o, type) doref(o, type, TRUE)
#endif

/*
=head1 Optree Manipulation Functions

=for apidoc Am|OP*|LINKLIST|OP *o
Given the root of an optree, link the tree in execution order using the
C<op_next> pointers and return the first op executed.  If this has
already been done, it will not be redone, and C<< o->op_next >> will be
returned.  If C<< o->op_next >> is not already set, I<o> should be at
least an C<UNOP>.

=cut
*/

#define LINKLIST(o) ((o)->op_next ? (o)->op_next : op_linklist((OP*)o))

/* no longer used anywhere in core */
#ifndef PERL_CORE
#define cv_ckproto(cv, gv, p) \
   cv_ckproto_len_flags((cv), (gv), (p), (p) ? strlen(p) : 0, 0)
#endif

#ifdef PERL_CORE
#  define my(o)	my_attrs((o), NULL)
#endif

#ifdef USE_REENTRANT_API
#include "reentr.h"
#endif

#define NewOp(m,var,c,type)	\
	(var = (type *) Perl_Slab_Alloc(aTHX_ c*sizeof(type)))
#define NewOpSz(m,var,size)	\
	(var = (OP *) Perl_Slab_Alloc(aTHX_ size))
#define FreeOp(p) Perl_Slab_Free(aTHX_ p)

/*
 * The per-CV op slabs consist of a header (the opslab struct) and a bunch
 * of space for allocating op slots, each of which consists of two pointers
 * followed by an op.  The first pointer points to the next op slot.  The
 * second points to the slab.  At the end of the slab is a null pointer,
 * so that slot->opslot_next - slot can be used to determine the size
 * of the op.
 *
 * Each CV can have multiple slabs; opslab_next points to the next slab, to
 * form a chain.  All bookkeeping is done on the first slab, which is where
 * all the op slots point.
 *
 * Freed ops are marked as freed and attached to the freed chain
 * via op_next pointers.
 *
 * When there is more than one slab, the second slab in the slab chain is
 * assumed to be the one with free space available.  It is used when allo-
 * cating an op if there are no freed ops available or big enough.
 */

#ifdef PERL_CORE
struct opslot {
    /* keep opslot_next first */
    OPSLOT *	opslot_next;		/* next slot */
    OPSLAB *	opslot_slab;		/* owner */
    OP		opslot_op;		/* the op itself */
};

struct opslab {
    OPSLOT *	opslab_first;		/* first op in this slab */
    OPSLAB *	opslab_next;		/* next slab */
    OP *	opslab_freed;		/* chain of freed ops */
    size_t	opslab_refcnt;		/* number of ops */
# ifdef PERL_DEBUG_READONLY_OPS
    U16		opslab_size;		/* size of slab in pointers */
    bool	opslab_readonly;
# endif
    OPSLOT	opslab_slots;		/* slots begin here */
};

# define OPSLOT_HEADER		STRUCT_OFFSET(OPSLOT, opslot_op)
# define OPSLOT_HEADER_P	(OPSLOT_HEADER/sizeof(I32 *))
# define OpSLOT(o)		(assert_(o->op_slabbed) \
				 (OPSLOT *)(((char *)o)-OPSLOT_HEADER))
# define OpSLAB(o)		OpSLOT(o)->opslot_slab
# define OpslabREFCNT_dec(slab)      \
	(((slab)->opslab_refcnt == 1) \
	 ? opslab_free_nopad(slab)     \
	 : (void)--(slab)->opslab_refcnt)
  /* Variant that does not null out the pads */
# define OpslabREFCNT_dec_padok(slab) \
	(((slab)->opslab_refcnt == 1)  \
	 ? opslab_free(slab)		\
	 : (void)--(slab)->opslab_refcnt)
#endif

struct block_hooks {
    U32	    bhk_flags;
    void    (*bhk_start)	(pTHX_ int full);
    void    (*bhk_pre_end)	(pTHX_ OP **seq);
    void    (*bhk_post_end)	(pTHX_ OP **seq);
    void    (*bhk_eval)		(pTHX_ OP *const saveop);
};

/*
=head1 Compile-time scope hooks

=for apidoc mx|U32|BhkFLAGS|BHK *hk
Return the BHK's flags.

=for apidoc mx|void *|BhkENTRY|BHK *hk|which
Return an entry from the BHK structure.  I<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return NULL.  The type of the return value depends on which
entry you ask for.

=for apidoc Amx|void|BhkENTRY_set|BHK *hk|which|void *ptr
Set an entry in the BHK structure, and set the flags to indicate it is
valid.  I<which> is a preprocessing token indicating which entry to set.
The type of I<ptr> depends on the entry.

=for apidoc Amx|void|BhkDISABLE|BHK *hk|which
Temporarily disable an entry in this BHK structure, by clearing the
appropriate flag.  I<which> is a preprocessor token indicating which
entry to disable.

=for apidoc Amx|void|BhkENABLE|BHK *hk|which
Re-enable an entry in this BHK structure, by setting the appropriate
flag.  I<which> is a preprocessor token indicating which entry to enable.
This will assert (under -DDEBUGGING) if the entry doesn't contain a valid
pointer.

=for apidoc mx|void|CALL_BLOCK_HOOKS|which|arg
Call all the registered block hooks for type I<which>.  I<which> is a
preprocessing token; the type of I<arg> depends on I<which>.

=cut
*/

#define BhkFLAGS(hk)		((hk)->bhk_flags)

#define BHKf_bhk_start	    0x01
#define BHKf_bhk_pre_end    0x02
#define BHKf_bhk_post_end   0x04
#define BHKf_bhk_eval	    0x08

#define BhkENTRY(hk, which) \
    ((BhkFLAGS(hk) & BHKf_ ## which) ? ((hk)->which) : NULL)

#define BhkENABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) |= BHKf_ ## which; \
	assert(BhkENTRY(hk, which)); \
    } STMT_END

#define BhkDISABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) &= ~(BHKf_ ## which); \
    } STMT_END

#define BhkENTRY_set(hk, which, ptr) \
    STMT_START { \
	(hk)->which = ptr; \
	BhkENABLE(hk, which); \
    } STMT_END

#define CALL_BLOCK_HOOKS(which, arg) \
    STMT_START { \
	if (PL_blockhooks) { \
	    SSize_t i; \
	    for (i = av_tindex(PL_blockhooks); i >= 0; i--) { \
		SV *sv = AvARRAY(PL_blockhooks)[i]; \
		BHK *hk; \
		\
		assert(SvIOK(sv)); \
		if (SvUOK(sv)) \
		    hk = INT2PTR(BHK *, SvUVX(sv)); \
		else \
		    hk = INT2PTR(BHK *, SvIVX(sv)); \
		\
		if (BhkENTRY(hk, which)) \
		    BhkENTRY(hk, which)(aTHX_ arg); \
	    } \
	} \
    } STMT_END

/* flags for rv2cv_op_cv */

#define RV2CVOPCV_MARK_EARLY     0x00000001
#define RV2CVOPCV_RETURN_NAME_GV 0x00000002

#define op_lvalue(op,t) Perl_op_lvalue_flags(aTHX_ op,t,0)

/* flags for op_lvalue_flags */

#define OP_LVALUE_NO_CROAK 1

/*
=head1 Custom Operators

=for apidoc Am|U32|XopFLAGS|XOP *xop
Return the XOP's flags.

=for apidoc Am||XopENTRY|XOP *xop|which
Return a member of the XOP structure.  I<which> is a cpp token
indicating which entry to return.  If the member is not set
this will return a default value.  The return type depends
on I<which>.  This macro evaluates its arguments more than
once.  If you are using C<Perl_custom_op_xop> to retreive a
C<XOP *> from a C<OP *>, use the more efficient L</XopENTRYCUSTOM> instead.

=for apidoc Am||XopENTRYCUSTOM|const OP *o|which
Exactly like C<XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)> but more
efficient.  The I<which> parameter is identical to L</XopENTRY>.

=for apidoc Am|void|XopENTRY_set|XOP *xop|which|value
Set a member of the XOP structure.  I<which> is a cpp token
indicating which entry to set.  See L<perlguts/"Custom Operators">
for details about the available members and how
they are used.  This macro evaluates its argument
more than once.

=for apidoc Am|void|XopDISABLE|XOP *xop|which
Temporarily disable a member of the XOP, by clearing the appropriate flag.

=for apidoc Am|void|XopENABLE|XOP *xop|which
Reenable a member of the XOP which has been disabled.

=cut
*/

struct custom_op {
    U32		    xop_flags;    
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
};

/* return value of Perl_custom_op_get_field, similar to void * then casting but
   the U32 doesn't need truncation on 64 bit platforms in the caller, also
   for easier macro writing */
typedef union {
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
    XOP            *xop_ptr;
} XOPRETANY;

#define XopFLAGS(xop) ((xop)->xop_flags)

#define XOPf_xop_name	0x01
#define XOPf_xop_desc	0x02
#define XOPf_xop_class	0x04
#define XOPf_xop_peep	0x08

/* used by Perl_custom_op_get_field for option checking */
typedef enum {
    XOPe_xop_ptr = 0, /* just get the XOP *, don't look inside it */
    XOPe_xop_name = XOPf_xop_name,
    XOPe_xop_desc = XOPf_xop_desc,
    XOPe_xop_class = XOPf_xop_class,
    XOPe_xop_peep = XOPf_xop_peep
} xop_flags_enum;

#define XOPd_xop_name	PL_op_name[OP_CUSTOM]
#define XOPd_xop_desc	PL_op_desc[OP_CUSTOM]
#define XOPd_xop_class	OA_BASEOP
#define XOPd_xop_peep	((Perl_cpeep_t)0)

#define XopENTRY_set(xop, which, to) \
    STMT_START { \
	(xop)->which = (to); \
	(xop)->xop_flags |= XOPf_ ## which; \
    } STMT_END

#define XopENTRY(xop, which) \
    ((XopFLAGS(xop) & XOPf_ ## which) ? (xop)->which : XOPd_ ## which)

#define XopENTRYCUSTOM(o, which) \
    (Perl_custom_op_get_field(aTHX_ o, XOPe_ ## which).which)

#define XopDISABLE(xop, which) ((xop)->xop_flags &= ~XOPf_ ## which)
#define XopENABLE(xop, which) \
    STMT_START { \
	(xop)->xop_flags |= XOPf_ ## which; \
	assert(XopENTRY(xop, which)); \
    } STMT_END

#define Perl_custom_op_xop(x) \
    (Perl_custom_op_get_field(x, XOPe_xop_ptr).xop_ptr)

/*
=head1 Optree Manipulation Functions

=for apidoc Am|const char *|OP_NAME|OP *o
Return the name of the provided OP.  For core ops this looks up the name
from the op_type; for custom ops from the op_ppaddr.

=for apidoc Am|const char *|OP_DESC|OP *o
Return a short description of the provided OP.

=for apidoc Am|U32|OP_CLASS|OP *o
Return the class of the provided OP: that is, which of the *OP
structures it uses.  For core ops this currently gets the information out
of PL_opargs, which does not always accurately reflect the type used.
For custom ops the type is returned from the registration, and it is up
to the registree to ensure it is accurate.  The value returned will be
one of the OA_* constants from op.h.

=for apidoc Am|bool|OP_TYPE_IS|OP *o|Optype type
Returns true if the given OP is not a NULL pointer
and if it is of the given type.

The negation of this macro, C<OP_TYPE_ISNT> is also available
as well as C<OP_TYPE_IS_NN> and C<OP_TYPE_ISNT_NN> which elide
the NULL pointer check.

=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o|Optype type
Returns true if the given OP is not a NULL pointer and
if it is of the given type or used to be before being
replaced by an OP of type OP_NULL.

The negation of this macro, C<OP_TYPE_ISNT_AND_WASNT>
is also available as well as C<OP_TYPE_IS_OR_WAS_NN>
and C<OP_TYPE_ISNT_AND_WASNT_NN> which elide
the NULL pointer check.

=cut
*/

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_name) \
		    : PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_desc) \
		    : PL_op_desc[(o)->op_type])
#define OP_CLASS(o) ((o)->op_type == OP_CUSTOM \
		     ? XopENTRYCUSTOM(o, xop_class) \
		     : (PL_opargs[(o)->op_type] & OA_CLASS_MASK))

#define OP_TYPE_IS(o, type) ((o) && (o)->op_type == (type))
#define OP_TYPE_IS_NN(o, type) ((o)->op_type == (type))
#define OP_TYPE_ISNT(o, type) ((o) && (o)->op_type != (type))
#define OP_TYPE_ISNT_NN(o, type) ((o)->op_type != (type))

#define OP_TYPE_IS_OR_WAS_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      == (type) )

#define OP_TYPE_IS_OR_WAS(o, type) \
    ( (o) && OP_TYPE_IS_OR_WAS_NN(o, type) )

#define OP_TYPE_ISNT_AND_WASNT_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      != (type) )

#define OP_TYPE_ISNT_AND_WASNT(o, type) \
    ( (o) && OP_TYPE_ISNT_AND_WASNT_NN(o, type) )

#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))

#ifdef PERL_MAD
#  define MAD_NULL 1
#  define MAD_PV 2
#  define MAD_OP 3
#  define MAD_SV 4

struct madprop {
    MADPROP* mad_next;
    void *mad_val;
    U32 mad_vlen;
/*    short mad_count; */
    char mad_key;
    char mad_type;
};

struct token {
    I32 tk_type;
    YYSTYPE tk_lval;
    MADPROP* tk_mad;
};
#endif

/*
 * Values that can be held by mad_key :
 * ^       unfilled head spot
 * ,       literal ,
 * ;       literal ; (blank if implicit ; at end of block)
 * :       literal : from ?: or attr list
 * +       unary +
 * ?       literal ? from ?:
 * (       literal (
 * )       literal )
 * [       literal [
 * ]       literal ]
 * {       literal {
 * }       literal }
 * @       literal @ sigil
 * $       literal $ sigil
 * *       literal * sigil
 * !       use is source filtered
 * &       & or sub
 * #       whitespace/comment following ; or }
 * #       $# sigil
 * 1       1st ; from for(;;)
 * 1       retired protasis
 * 2       2nd ; from for(;;)
 * 2       retired apodosis
 * 3       C-style for list
 * a       sub or var attributes
 * a       non-method arrow operator
 * A       method arrow operator
 * A       use import args
 * b       format block
 * B       retired stub block
 * C       constant conditional op
 * d       declarator
 * D       do block
 * e       unreached "else" (see C)
 * e       expression producing E
 * E       tr/E/R/, /E/
 * f       folded constant op
 * F       peg op for format
 * g       op was forced to be a word
 * i       if/unless modifier
 * I       if/elsif/unless statement
 * k       local declarator
 * K       retired kid op
 * l       last index of array ($#foo)
 * L       label
 * m       modifier on regex
 * n       sub or format name
 * o       current operator/declarator name
 * o       else/continue
 * O       generic optimized op
 * p       peg to hold extra whitespace at statement level
 * P       peg op for package declaration
 * q       opening quote
 * =       quoted material
 * Q       closing quote
 * Q       optimized qw//
 * r       expression producing R
 * R       tr/E/R/ s/E/R/
 * s       sub signature
 * S       use import stub (no import)
 * S       retired sort block
 * t       unreached "then" (see C)
 * U       use import op
 * v       private sv of for loop
 * V       use version
 * w       while/until modifier
 * W       while/for statement
 * x       optimized qw
 * X       random thing
 * _       whitespace/comments preceding anything else
 * ~       =~ operator
 */

/*
=head1 Hook manipulation
*/

#ifdef USE_ITHREADS
#  define OP_CHECK_MUTEX_INIT		MUTEX_INIT(&PL_check_mutex)
#  define OP_CHECK_MUTEX_LOCK		MUTEX_LOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_UNLOCK		MUTEX_UNLOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_TERM		MUTEX_DESTROY(&PL_check_mutex)
#else
#  define OP_CHECK_MUTEX_INIT		NOOP
#  define OP_CHECK_MUTEX_LOCK		NOOP
#  define OP_CHECK_MUTEX_UNLOCK		NOOP
#  define OP_CHECK_MUTEX_TERM		NOOP
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*    thread.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if defined(USE_ITHREADS)

#if defined(VMS)
#include <builtins.h>
#endif

#ifdef WIN32
#  include <win32thread.h>
#else
#ifdef NETWARE
#  include <nw5thread.h>
#else
#  ifdef OLD_PTHREADS_API /* Here be dragons. */
#    define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach(&(t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END

#    define PERL_GET_CONTEXT	Perl_get_context()
#    define PERL_SET_CONTEXT(t)	Perl_set_context((void*)t)

#    define PTHREAD_GETSPECIFIC_INT
#    ifdef DJGPP
#      define pthread_addr_t any_t
#      define NEED_PTHREAD_INIT
#      define PTHREAD_CREATE_JOINABLE (1)
#    endif
#    ifdef OEMVS
#      define pthread_addr_t void *
#      define pthread_create(t,a,s,d)        pthread_create(t,&(a),s,d)
#      define pthread_keycreate              pthread_key_create
#    endif
#    ifdef VMS
#      define pthread_attr_init(a) pthread_attr_create(a)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_setdetach_np(a,s)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(__hpux) && defined(__ux_version) && __ux_version <= 1020
#      define pthread_attr_init(a) pthread_attr_create(a)
       /* XXX pthread_setdetach_np() missing in DCE threads on HP-UX 10.20 */
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s)	(0)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(DJGPP) || defined(OEMVS)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,&(s))
#      define YIELD pthread_yield(NULL)
#    endif
#  endif
#  if !defined(__hpux) || !defined(__ux_version) || __ux_version > 1020
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default  NULL
#  endif
#endif	/* NETWARE */
#endif

#ifndef PTHREAD_CREATE
/* You are not supposed to pass NULL as the 2nd arg of PTHREAD_CREATE(). */
#  define PTHREAD_CREATE(t,a,s,d) pthread_create(t,&(a),s,d)
#endif

#ifndef PTHREAD_ATTR_SETDETACHSTATE
#  define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,s)
#endif

#ifndef PTHREAD_CREATE_JOINABLE
#  ifdef OLD_PTHREAD_CREATE_JOINABLE
#    define PTHREAD_CREATE_JOINABLE OLD_PTHREAD_CREATE_JOINABLE
#  else
#    define PTHREAD_CREATE_JOINABLE 0 /* Panic?  No, guess. */
#  endif
#endif

#ifdef __VMS
  /* Default is 1024 on VAX, 8192 otherwise */
#  ifdef __ia64
#    define THREAD_CREATE_NEEDS_STACK (48*1024)
#  else
#    define THREAD_CREATE_NEEDS_STACK (32*1024)
#  endif
#endif

#ifdef I_MACH_CTHREADS

/* cthreads interface */

/* #include <mach/cthreads.h> is in perl.h #ifdef I_MACH_CTHREADS */

#define MUTEX_INIT(m) \
    STMT_START {						\
	*m = mutex_alloc();					\
	if (*m) {						\
	    mutex_init(*m);					\
	} else {						\
	    Perl_croak_nocontext("panic: MUTEX_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define MUTEX_LOCK(m)			mutex_lock(*m)
#define MUTEX_UNLOCK(m)			mutex_unlock(*m)
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	mutex_free(*m);						\
	*m = 0;							\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	*c = condition_alloc();					\
	if (*c) {						\
	    condition_init(*c);					\
	}							\
	else {							\
	    Perl_croak_nocontext("panic: COND_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define COND_SIGNAL(c)		condition_signal(*c)
#define COND_BROADCAST(c)	condition_broadcast(*c)
#define COND_WAIT(c, m)		condition_wait(*c, *m)
#define COND_DESTROY(c) \
    STMT_START {						\
	condition_free(*c);					\
	*c = 0;							\
    } STMT_END

#define THREAD_CREATE(thr, f)	(thr->self = cthread_fork(f, thr), 0)
#define THREAD_POST_CREATE(thr)

#define THREAD_RET_TYPE		any_t
#define THREAD_RET_CAST(x)	((any_t) x)

#define DETACH(t)		cthread_detach(t->self)
#define JOIN(t, avp)		(*(avp) = MUTABLE_AV(cthread_join(t->self)))

#define PERL_SET_CONTEXT(t)	cthread_set_data(cthread_self(), t)
#define PERL_GET_CONTEXT	cthread_data(cthread_self())

#define INIT_THREADS		cthread_init()
#define YIELD			cthread_yield()
#define ALLOC_THREAD_KEY	NOOP
#define FREE_THREAD_KEY		NOOP
#define SET_THREAD_SELF(thr)	(thr->self = cthread_self())

#endif /* I_MACH_CTHREADS */

#ifndef YIELD
#  ifdef SCHED_YIELD
#    define YIELD SCHED_YIELD
#  else
#    ifdef HAS_SCHED_YIELD
#      define YIELD sched_yield()
#    else
#      ifdef HAS_PTHREAD_YIELD
    /* pthread_yield(NULL) platforms are expected
     * to have #defined YIELD for themselves. */
#        define YIELD pthread_yield()
#      endif
#    endif
#  endif
#endif

#ifdef __hpux
#  define MUTEX_INIT_NEEDS_MUTEX_ZEROED
#endif

#ifndef MUTEX_INIT

#  ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
    /* Temporary workaround, true bug is deeper. --jhi 1999-02-25 */
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	Zero((m), 1, perl_mutex);                               \
 	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  else
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  endif

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_lock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_LOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_unlock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_destroy((m))))		\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* MUTEX_INIT */

#ifndef COND_INIT
#  define COND_INIT(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_init((c), pthread_condattr_default)))	\
	    Perl_croak_nocontext("panic: COND_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_SIGNAL(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_signal((c))))			\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_BROADCAST(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_broadcast((c))))		\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_WAIT(c, m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_wait((c), (m))))		\
	    Perl_croak_nocontext("panic: COND_WAIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_DESTROY(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_destroy((c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* COND_INIT */

/* DETACH(t) must only be called while holding t->mutex */
#ifndef DETACH
#  define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach((t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END
#endif /* DETACH */

#ifndef JOIN
#  define JOIN(t, avp) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_join((t)->self, (void**)(avp))))	\
	    Perl_croak_nocontext("panic: pthread_join (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* JOIN */

/* Use an unchecked fetch of thread-specific data instead of a checked one.
 * It would fail if the key were bogus, but if the key were bogus then
 * Really Bad Things would be happening anyway. --dan */
#if (defined(__ALPHA) && (__VMS_VER >= 70000000)) || \
    (defined(__alpha) && defined(__osf__) && !defined(__GNUC__)) /* Available only on >= 4.0 */
#  define HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP /* Configure test needed */
#endif

#ifdef HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP
#  define PTHREAD_GETSPECIFIC(key) pthread_unchecked_getspecific_np(key)
#else
#    define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT	PTHREAD_GETSPECIFIC(PL_thr_key)
#endif

#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_setspecific(PL_thr_key, (void *)(t))))	\
	    Perl_croak_nocontext("panic: pthread_setspecific (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* PERL_SET_CONTEXT */

#ifndef INIT_THREADS
#  ifdef NEED_PTHREAD_INIT
#    define INIT_THREADS pthread_init()
#  endif
#endif

#ifndef ALLOC_THREAD_KEY
#  define ALLOC_THREAD_KEY \
    STMT_START {						\
	if (pthread_key_create(&PL_thr_key, 0)) {		\
            PERL_UNUSED_RESULT(write(2, STR_WITH_LEN("panic: pthread_key_create failed\n"))); \
	    exit(1);						\
	}							\
    } STMT_END
#endif

#ifndef FREE_THREAD_KEY
#  define FREE_THREAD_KEY \
    STMT_START {						\
	pthread_key_delete(PL_thr_key);				\
    } STMT_END
#endif

#ifndef PTHREAD_ATFORK
#  ifdef HAS_PTHREAD_ATFORK
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	pthread_atfork(prepare,parent,child)
#  else
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	NOOP
#  endif
#endif

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */

#  define LOCK_DOLLARZERO_MUTEX		MUTEX_LOCK(&PL_dollarzero_mutex)
#  define UNLOCK_DOLLARZERO_MUTEX	MUTEX_UNLOCK(&PL_dollarzero_mutex)

#endif /* USE_ITHREADS */

#ifndef MUTEX_LOCK
#  define MUTEX_LOCK(m)
#endif

#ifndef MUTEX_UNLOCK
#  define MUTEX_UNLOCK(m)
#endif

#ifndef MUTEX_INIT
#  define MUTEX_INIT(m)
#endif

#ifndef MUTEX_DESTROY
#  define MUTEX_DESTROY(m)
#endif

#ifndef COND_INIT
#  define COND_INIT(c)
#endif

#ifndef COND_SIGNAL
#  define COND_SIGNAL(c)
#endif

#ifndef COND_BROADCAST
#  define COND_BROADCAST(c)
#endif

#ifndef COND_WAIT
#  define COND_WAIT(c, m)
#endif

#ifndef COND_DESTROY
#  define COND_DESTROY(c)
#endif

#ifndef LOCK_DOLLARZERO_MUTEX
#  define LOCK_DOLLARZERO_MUTEX
#endif

#ifndef UNLOCK_DOLLARZERO_MUTEX
#  define UNLOCK_DOLLARZERO_MUTEX
#endif

/* THR, SET_THR, and dTHR are there for compatibility with old versions */
#ifndef THR
#  define THR		PERL_GET_THX
#endif

#ifndef SET_THR
#  define SET_THR(t)	PERL_SET_THX(t)
#endif

#ifndef dTHR
#  define dTHR dNOOP
#endif

#ifndef INIT_THREADS
#  define INIT_THREADS NOOP
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*    EXTERN.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * EXT  designates a global var which is defined in perl.h
 * dEXT designates a global var which is defined in another
 *      file, so we can't count on finding it in perl.h
 *      (this practice should be avoided).
 */
#undef EXT
#undef dEXT
#undef EXTCONST
#undef dEXTCONST
#if defined(VMS) && !defined(__GNUC__)
    /* Suppress portability warnings from DECC for VMS-specific extensions */
#  ifdef __DECC
#    pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT)
#  endif
#  define EXT globalref
#  define dEXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define EXTCONST globalref
#  define dEXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#else
#  if (defined(WIN32) || defined(__SYMBIAN32__)) && !defined(PERL_STATIC_SYMS)
    /* miniperl should not export anything */
#    if defined(PERL_IS_MINIPERL) && !defined(UNDER_CE) && defined(_MSC_VER)
#      define EXT extern
#      define dEXT 
#      define EXTCONST extern const
#      define dEXTCONST const
#    else
#      if defined(PERLDLL) || defined(__SYMBIAN32__)
#        define EXT extern __declspec(dllexport)
#        define dEXT 
#        define EXTCONST extern __declspec(dllexport) const
#        define dEXTCONST const
#      else
#        define EXT extern __declspec(dllimport)
#        define dEXT 
#        define EXTCONST extern __declspec(dllimport) const
#        define dEXTCONST const
#      endif
#    endif
#  else
#    if defined(__CYGWIN__) && defined(USEIMPORTLIB)
#      define EXT extern __declspec(dllimport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllimport) const
#      define dEXTCONST const
#    else
#      define EXT extern
#      define dEXT
#      define EXTCONST extern const
#      define dEXTCONST const
#    endif
#  endif
#endif

#undef INIT
#define INIT(x)

#undef DOINIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*    util.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1999, 2001, 2002, 2003, 2004, 2005,
 *    2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef VMS
#  define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || (strchr(f,':')						\
	     || ((*(f) == '[' || *(f) == '<')				\
		 && (isWORDCHAR((f)[1]) || strchr("$-_]>",(f)[1])))))

#else		/* !VMS */
#  if defined(WIN32) || defined(__CYGWIN__)
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/' || *(f) == '\\'		/* UNC/rooted path */	\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#  else		/* !WIN32 */
#  ifdef NETWARE
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(((f)[0] && (f)[1] == ':')		/* drive name */	\
	 || ((f)[0] == '\\' && (f)[1] == '\\')	/* UNC path */	\
	 ||	((f)[3] == ':'))				/* volume name, currently only sys */
#  else		/* !NETWARE */
#    if defined(DOSISH) || defined(__SYMBIAN32__)
#      define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#    else	/* NEITHER DOSISH NOR SYMBIANISH */
#      define PERL_FILE_IS_ABSOLUTE(f)	(*(f) == '/')
#    endif	/* DOSISH */
#   endif	/* NETWARE */
#  endif	/* WIN32 */
#endif		/* VMS */

/*
=for apidoc ibcmp

This is a synonym for (! foldEQ())

=for apidoc ibcmp_locale

This is a synonym for (! foldEQ_locale())

=cut
*/
#define ibcmp(s1, s2, len)         cBOOL(! foldEQ(s1, s2, len))
#define ibcmp_locale(s1, s2, len)  cBOOL(! foldEQ_locale(s1, s2, len))

/* outside the core, perl.h undefs HAS_QUAD if IV isn't 64-bit
   We can't swap this to HAS_QUAD, because the logic here affects the type of
   perl_drand48_t below, and that is visible outside of the core.  */
#if defined(U64TYPE) && !defined(USING_MSVC6)
/* use a faster implementation when quads are available,
 * but not with VC6 on Windows */
#    define PERL_DRAND48_QUAD
#endif

#ifdef PERL_DRAND48_QUAD

/* U64 is only defined under PERL_CORE, but this needs to be visible
 * elsewhere so the definition of PerlInterpreter is complete.
 */
typedef U64TYPE perl_drand48_t;

#else

struct PERL_DRAND48_T {
    U16 seed[3];
};

typedef struct PERL_DRAND48_T perl_drand48_t;

#endif

#define PL_RANDOM_STATE_TYPE perl_drand48_t

#define Perl_drand48_init(seed) (Perl_drand48_init_r(&PL_random_state, (seed)))
#define Perl_drand48() (Perl_drand48_r(&PL_random_state))

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef _PERLIOL_H
#define _PERLIOL_H

typedef struct {
    PerlIO_funcs *funcs;
    SV *arg;
} PerlIO_pair_t;

struct PerlIO_list_s {
    IV refcnt;
    IV cur;
    IV len;
    PerlIO_pair_t *array;
};

struct _PerlIO_funcs {
    Size_t fsize;
    const char *name;
    Size_t size;
    U32 kind;
    IV (*Pushed) (pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
    IV (*Popped) (pTHX_ PerlIO *f);
    PerlIO *(*Open) (pTHX_ PerlIO_funcs *tab,
		     PerlIO_list_t *layers, IV n,
		     const char *mode,
		     int fd, int imode, int perm,
		     PerlIO *old, int narg, SV **args);
    IV (*Binmode)(pTHX_ PerlIO *f);
    SV *(*Getarg) (pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags);
    IV (*Fileno) (pTHX_ PerlIO *f);
    PerlIO *(*Dup) (pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
    /* Unix-like functions - cf sfio line disciplines */
     SSize_t(*Read) (pTHX_ PerlIO *f, void *vbuf, Size_t count);
     SSize_t(*Unread) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
     SSize_t(*Write) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
    IV (*Seek) (pTHX_ PerlIO *f, Off_t offset, int whence);
     Off_t(*Tell) (pTHX_ PerlIO *f);
    IV (*Close) (pTHX_ PerlIO *f);
    /* Stdio-like buffered IO functions */
    IV (*Flush) (pTHX_ PerlIO *f);
    IV (*Fill) (pTHX_ PerlIO *f);
    IV (*Eof) (pTHX_ PerlIO *f);
    IV (*Error) (pTHX_ PerlIO *f);
    void (*Clearerr) (pTHX_ PerlIO *f);
    void (*Setlinebuf) (pTHX_ PerlIO *f);
    /* Perl's snooping functions */
    STDCHAR *(*Get_base) (pTHX_ PerlIO *f);
     Size_t(*Get_bufsiz) (pTHX_ PerlIO *f);
    STDCHAR *(*Get_ptr) (pTHX_ PerlIO *f);
     SSize_t(*Get_cnt) (pTHX_ PerlIO *f);
    void (*Set_ptrcnt) (pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
};

/*--------------------------------------------------------------------------------------*/
/* Kind values */
#define PERLIO_K_RAW		0x00000001
#define PERLIO_K_BUFFERED	0x00000002
#define PERLIO_K_CANCRLF	0x00000004
#define PERLIO_K_FASTGETS	0x00000008
#define PERLIO_K_DUMMY		0x00000010
#define PERLIO_K_UTF8		0x00008000
#define PERLIO_K_DESTRUCT	0x00010000
#define PERLIO_K_MULTIARG	0x00020000

/*--------------------------------------------------------------------------------------*/
struct _PerlIO {
    PerlIOl *next;		/* Lower layer */
    PerlIO_funcs *tab;		/* Functions for this layer */
    U32 flags;			/* Various flags for state */
    PerlIOl *head;		/* our ultimate parent pointer */
};

/*--------------------------------------------------------------------------------------*/

/* Flag values */
#define PERLIO_F_EOF		0x00000100
#define PERLIO_F_CANWRITE	0x00000200
#define PERLIO_F_CANREAD	0x00000400
#define PERLIO_F_ERROR		0x00000800
#define PERLIO_F_TRUNCATE	0x00001000
#define PERLIO_F_APPEND		0x00002000
#define PERLIO_F_CRLF		0x00004000
#define PERLIO_F_UTF8		0x00008000
#define PERLIO_F_UNBUF		0x00010000
#define PERLIO_F_WRBUF		0x00020000
#define PERLIO_F_RDBUF		0x00040000
#define PERLIO_F_LINEBUF	0x00080000
#define PERLIO_F_TEMP		0x00100000
#define PERLIO_F_OPEN		0x00200000
#define PERLIO_F_FASTGETS	0x00400000
#define PERLIO_F_TTY		0x00800000
#define PERLIO_F_NOTREG         0x01000000   
#define PERLIO_F_CLEARED        0x02000000 /* layer cleared but not freed */

#define PerlIOBase(f)      (*(f))
#define PerlIOSelf(f,type) ((type *)PerlIOBase(f))
#define PerlIONext(f)      (&(PerlIOBase(f)->next))
#define PerlIOValid(f)     ((f) && *(f))

/*--------------------------------------------------------------------------------------*/
/* Data exports - EXTCONST rather than extern is needed for Cygwin */
#undef EXTPERLIO 
#ifdef PERLIO_FUNCS_CONST
#define EXTPERLIO EXTCONST
#else
#define EXTPERLIO EXT
#endif
EXTPERLIO PerlIO_funcs PerlIO_unix;
EXTPERLIO PerlIO_funcs PerlIO_perlio;
EXTPERLIO PerlIO_funcs PerlIO_stdio;
EXTPERLIO PerlIO_funcs PerlIO_crlf;
EXTPERLIO PerlIO_funcs PerlIO_utf8;
EXTPERLIO PerlIO_funcs PerlIO_byte;
EXTPERLIO PerlIO_funcs PerlIO_raw;
EXTPERLIO PerlIO_funcs PerlIO_pending;
#ifdef WIN32
EXTPERLIO PerlIO_funcs PerlIO_win32;
#endif
PERL_EXPORT_C PerlIO *PerlIO_allocate(pTHX);
PERL_EXPORT_C SV *PerlIO_arg_fetch(PerlIO_list_t *av, IV n);
#define PerlIOArg PerlIO_arg_fetch(layers,n)

#ifdef PERLIO_USING_CRLF
#define PERLIO_STDTEXT "t"
#else
#define PERLIO_STDTEXT ""
#endif

/*--------------------------------------------------------------------------------------*/
/* perlio buffer layer
   As this is reasonably generic its struct and "methods" are declared here
   so they can be used to "inherit" from it.
*/

typedef struct {
    struct _PerlIO base;	/* Base "class" info */
    STDCHAR *buf;		/* Start of buffer */
    STDCHAR *end;		/* End of valid part of buffer */
    STDCHAR *ptr;		/* Current position in buffer */
    Off_t posn;			/* Offset of buf into the file */
    Size_t bufsiz;		/* Real size of buffer */
    IV oneword;			/* Emergency buffer */
} PerlIOBuf;

PERL_EXPORT_C int PerlIO_apply_layera(pTHX_ PerlIO *f, const char *mode,
		    PerlIO_list_t *layers, IV n, IV max);
PERL_EXPORT_C int PerlIO_parse_layers(pTHX_ PerlIO_list_t *av, const char *names);
PERL_EXPORT_C PerlIO_funcs *PerlIO_layer_fetch(pTHX_ PerlIO_list_t *av, IV n, PerlIO_funcs *def);


PERL_EXPORT_C SV *PerlIO_sv_dup(pTHX_ SV *arg, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_cleantable(pTHX_ PerlIOl **tablep);
PERL_EXPORT_C SV * PerlIO_tab_sv(pTHX_ PerlIO_funcs *tab);
PERL_EXPORT_C void PerlIO_default_buffer(pTHX_ PerlIO_list_t *av);
PERL_EXPORT_C void PerlIO_stdstreams(pTHX);
PERL_EXPORT_C int PerlIO__close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO_list_t * PerlIO_resolve_layers(pTHX_ const char *layers, const char *mode, int narg, SV **args);
PERL_EXPORT_C PerlIO_funcs * PerlIO_default_layer(pTHX_ I32 n);
PERL_EXPORT_C PerlIO_list_t * PerlIO_default_layers(pTHX);
PERL_EXPORT_C PerlIO * PerlIO_reopen(const char *path, const char *mode, PerlIO *f);

PERL_EXPORT_C PerlIO_list_t *PerlIO_list_alloc(pTHX);
PERL_EXPORT_C PerlIO_list_t *PerlIO_clone_list(pTHX_ PerlIO_list_t *proto, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);
PERL_EXPORT_C void PerlIO_list_push(pTHX_ PerlIO_list_t *list, PerlIO_funcs *funcs, SV *arg);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);

/* PerlIO_teardown doesn't need exporting, but the EXTERN_C is needed
 * for compiling as C++.  Must also match with what perl.h says. */
EXTERN_C void PerlIO_teardown(void);

/*--------------------------------------------------------------------------------------*/
/* Generic, or stub layer functions */

PERL_EXPORT_C IV        PerlIOBase_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBase_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBase_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_flush_linebuf(pTHX);
PERL_EXPORT_C IV        PerlIOBase_noop_fail(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_noop_ok(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C PerlIO *  PerlIOBase_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C SSize_t   PerlIOBase_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C void      PerlIOBase_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBase_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Buf */
PERL_EXPORT_C Size_t    PerlIOBuf_bufsiz(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBuf_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_ptr(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOBuf_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOBuf_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOBuf_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOBuf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C Off_t     PerlIOBuf_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOBuf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Crlf */
PERL_EXPORT_C IV        PerlIOCrlf_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOCrlf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C void      PerlIOCrlf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C SSize_t   PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOCrlf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Pending */
PERL_EXPORT_C IV        PerlIOPending_close(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOPending_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOPending_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOPending_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);

/* Pop */
PERL_EXPORT_C IV        PerlIOPop_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Raw */
PERL_EXPORT_C IV        PerlIORaw_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Stdio */
PERL_EXPORT_C void      PerlIOStdio_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOStdio_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOStdio_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_fileno(pTHX_ PerlIO *f);
#ifdef USE_STDIO_PTR
PERL_EXPORT_C STDCHAR * PerlIOStdio_get_ptr(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOStdio_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOStdio_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
#endif
PERL_EXPORT_C IV        PerlIOStdio_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_flush(pTHX_ PerlIO *f);
#ifdef FILE_base
PERL_EXPORT_C STDCHAR * PerlIOStdio_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C Size_t    PerlIOStdio_get_bufsiz(pTHX_ PerlIO *f);
#endif
PERL_EXPORT_C char *    PerlIOStdio_mode(const char *mode, char *tmode);
PERL_EXPORT_C PerlIO *  PerlIOStdio_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOStdio_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOStdio_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOStdio_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOStdio_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C Off_t     PerlIOStdio_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOStdio_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOStdio_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Unix */
PERL_EXPORT_C IV        PerlIOUnix_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOUnix_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOUnix_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C int       PerlIOUnix_oflags(const char *mode);
PERL_EXPORT_C PerlIO *  PerlIOUnix_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOUnix_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOUnix_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C int       PerlIOUnix_refcnt_dec(int fd);
PERL_EXPORT_C void      PerlIOUnix_refcnt_inc(int fd);
PERL_EXPORT_C int       PerlIOUnix_refcnt(int fd);
PERL_EXPORT_C IV        PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C Off_t     PerlIOUnix_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOUnix_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Utf8 */
PERL_EXPORT_C IV        PerlIOUtf8_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

#endif				/* _PERLIOL_H */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/feature.pl.
   Any changes made here will be lost!
 */


#if defined(PERL_CORE) || defined (PERL_EXT)

#define HINT_FEATURE_SHIFT	26

#define FEATURE_BUNDLE_DEFAULT	0
#define FEATURE_BUNDLE_510	1
#define FEATURE_BUNDLE_511	2
#define FEATURE_BUNDLE_515	3
#define FEATURE_BUNDLE_CUSTOM	(HINT_FEATURE_MASK >> HINT_FEATURE_SHIFT)

#define CURRENT_HINTS \
    (PL_curcop == &PL_compiling ? PL_hints : PL_curcop->cop_hints)
#define CURRENT_FEATURE_BUNDLE \
    ((CURRENT_HINTS & HINT_FEATURE_MASK) >> HINT_FEATURE_SHIFT)

/* Avoid using ... && Perl_feature_is_enabled(...) as that triggers a bug in
   the HP-UX cc on PA-RISC */
#define FEATURE_IS_ENABLED(name)				        \
	((CURRENT_HINTS							 \
	   & HINT_LOCALIZE_HH)						  \
	    ? Perl_feature_is_enabled(aTHX_ STR_WITH_LEN(name)) : FALSE)
/* The longest string we pass in.  */
#define MAX_FEATURE_LEN (sizeof("postderef_qq")-1)

#define FEATURE_FC_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("fc")) \
    )

#define FEATURE_SAY_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("say")) \
    )

#define FEATURE_STATE_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("state")) \
    )

#define FEATURE_SWITCH_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_510 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("switch")) \
    )

#define FEATURE_EVALBYTES_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("evalbytes")) \
    )

#define FEATURE_POSTDEREF_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("postderef") \
    )

#define FEATURE_ARYBASE_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_511 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("arybase")) \
    )

#define FEATURE_SIGNATURES_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("signatures") \
    )

#define FEATURE___SUB___IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("__SUB__")) \
    )

#define FEATURE_LEXSUBS_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("lexsubs") \
    )

#define FEATURE_POSTDEREF_QQ_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("postderef_qq") \
    )

#define FEATURE_UNIEVAL_IS_ENABLED \
    ( \
	CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_515 \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("unieval")) \
    )

#define FEATURE_UNICODE_IS_ENABLED \
    ( \
	(CURRENT_FEATURE_BUNDLE >= FEATURE_BUNDLE_511 && \
	 CURRENT_FEATURE_BUNDLE <= FEATURE_BUNDLE_515) \
     || (CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM && \
	 FEATURE_IS_ENABLED("unicode")) \
    )


#endif /* PERL_CORE or PERL_EXT */

#ifdef PERL_IN_OP_C
PERL_STATIC_INLINE void
S_enable_feature_bundle(pTHX_ SV *ver)
{
    SV *comp_ver = sv_newmortal();
    PL_hints = (PL_hints &~ HINT_FEATURE_MASK)
	     | (
		  (sv_setnv(comp_ver, 5.015),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_515 :
		  (sv_setnv(comp_ver, 5.011),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_511 :
		  (sv_setnv(comp_ver, 5.009005),
		   vcmp(ver, upg_version(comp_ver, FALSE)) >= 0)
			? FEATURE_BUNDLE_510 :
			  FEATURE_BUNDLE_DEFAULT
	       ) << HINT_FEATURE_SHIFT;
    /* special case */
    assert(PL_curcop == &PL_compiling);
    if (FEATURE_UNICODE_IS_ENABLED) PL_hints |=  HINT_UNI_8_BIT;
    else			    PL_hints &= ~HINT_UNI_8_BIT;
}
#endif /* PERL_IN_OP_C */

/* ex: set ro: */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*    hv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* These control hash traversal randomization and the environment variable PERL_PERTURB_KEYS.
 * Currently disabling this functionality will break a few tests, but should otherwise work fine.
 * See perlrun for more details. */

#if defined(PERL_PERTURB_KEYS_DISABLED)
#   define PL_HASH_RAND_BITS_ENABLED        0
#   define PERL_HASH_ITER_BUCKET(iter)      ((iter)->xhv_riter)
#else
#   define PERL_HASH_RANDOMIZE_KEYS         1
#   if defined(PERL_PERTURB_KEYS_RANDOM)
#       define PL_HASH_RAND_BITS_ENABLED    1
#   elif defined(PERL_PERTURB_KEYS_DETERMINISTIC)
#       define PL_HASH_RAND_BITS_ENABLED    2
#   else
#       define USE_PERL_PERTURB_KEYS        1
#       define PL_HASH_RAND_BITS_ENABLED    PL_hash_rand_bits_enabled
#   endif
#   define PERL_HASH_ITER_BUCKET(iter)      (((iter)->xhv_riter) ^ ((iter)->xhv_rand))
#endif

/* entry in hash value chain */
struct he {
    /* Keep hent_next first in this structure, because sv_free_arenas take
       advantage of this to share code between the he arenas and the SV
       body arenas  */
    HE		*hent_next;	/* next entry in chain */
    HEK		*hent_hek;	/* hash key */
    union {
	SV	*hent_val;	/* scalar value that was hashed */
	Size_t	hent_refcount;	/* references for this shared hash key */
    } he_valu;
};

/* hash key -- defined separately for use as shared pointer */
struct hek {
    U32		hek_hash;	/* hash of key */
    I32		hek_len;	/* length of hash key */
    char	hek_key[1];	/* variable-length hash key */
    /* the hash-key is \0-terminated */
    /* after the \0 there is a byte for flags, such as whether the key
       is UTF-8 */
};

struct shared_he {
    struct he shared_he_he;
    struct hek shared_he_hek;
};

/* Subject to change.
   Don't access this directly.
   Use the funcs in mro.c
*/

struct mro_alg {
    AV *(*resolve)(pTHX_ HV* stash, U32 level);
    const char *name;
    U16 length;
    U16	kflags;	/* For the hash API - set HVhek_UTF8 if name is UTF-8 */
    U32 hash; /* or 0 */
};

struct mro_meta {
    /* a hash holding the different MROs private data.  */
    HV      *mro_linear_all;
    /* a pointer directly to the current MROs private data.  If mro_linear_all
       is NULL, this owns the SV reference, else it is just a pointer to a
       value stored in and owned by mro_linear_all.  */
    SV      *mro_linear_current;
    HV      *mro_nextmethod; /* next::method caching */
    U32     cache_gen;       /* Bumping this invalidates our method cache */
    U32     pkg_gen;         /* Bumps when local methods/@ISA change */
    const struct mro_alg *mro_which; /* which mro alg is in use? */
    HV      *isa;            /* Everything this class @ISA */
    HV      *super;          /* SUPER method cache */
    U32     destroy_gen;     /* Generation number of DESTROY cache */
};

#define MRO_GET_PRIVATE_DATA(smeta, which)		   \
    (((smeta)->mro_which && (which) == (smeta)->mro_which) \
     ? (smeta)->mro_linear_current			   \
     : Perl_mro_get_private_data(aTHX_ (smeta), (which)))

/* Subject to change.
   Don't access this directly.
*/

union _xhvnameu {
    HEK *xhvnameu_name;		/* When xhv_name_count is 0 */
    HEK **xhvnameu_names;	/* When xhv_name_count is non-0 */
};

struct xpvhv_aux {
    union _xhvnameu xhv_name_u;	/* name, if a symbol table */
    AV		*xhv_backreferences; /* back references for weak references */
    HE		*xhv_eiter;	/* current entry of iterator */
    I32		xhv_riter;	/* current root of iterator */

/* Concerning xhv_name_count: When non-zero, xhv_name_u contains a pointer 
 * to an array of HEK pointers, this being the length. The first element is
 * the name of the stash, which may be NULL. If xhv_name_count is positive,
 * then *xhv_name is one of the effective names. If xhv_name_count is nega-
 * tive, then xhv_name_u.xhvnameu_names[1] is the first effective name.
 */
    I32		xhv_name_count;
    struct mro_meta *xhv_mro_meta;
#ifdef PERL_HASH_RANDOMIZE_KEYS
    U32         xhv_rand;       /* random value for hash traversal */
    U32         xhv_last_rand;  /* last random value for hash traversal,
                                   used to detect each() after insert for warnings */
#endif
    U32         xhv_fill_lazy;
    U32         xhv_aux_flags;      /* assorted extra flags */
};

#define HvAUXf_SCAN_STASH   0x1   /* stash is being scanned by gv_check */
#define HvAUXf_NO_DEREF     0x2   /* @{}, %{} etc (and nomethod) not present */

/* hash structure: */
/* This structure must match the beginning of struct xpvmg in sv.h. */
struct xpvhv {
    HV*		xmg_stash;	/* class package */
    union _xmgu	xmg_u;
    STRLEN      xhv_keys;       /* total keys, including placeholders */
    STRLEN      xhv_max;        /* subscript of last element of xhv_array */
};

/*
=head1 Hash Manipulation Functions

=for apidoc AmU||HEf_SVKEY
This flag, used in the length slot of hash entries and magic structures,
specifies the structure contains an C<SV*> pointer where a C<char*> pointer
is to be expected.  (For information only--not to be used).

=head1 Handy Values

=for apidoc AmU||Nullhv
Null HV pointer.

(deprecated - use C<(HV *)NULL> instead)

=head1 Hash Manipulation Functions

=for apidoc Am|char*|HvNAME|HV* stash
Returns the package name of a stash, or NULL if C<stash> isn't a stash.
See C<SvSTASH>, C<CvSTASH>.

=for apidoc Am|STRLEN|HvNAMELEN|HV *stash
Returns the length of the stash's name.

=for apidoc Am|unsigned char|HvNAMEUTF8|HV *stash
Returns true if the name is in UTF8 encoding.

=for apidoc Am|char*|HvENAME|HV* stash
Returns the effective name of a stash, or NULL if there is none.  The
effective name represents a location in the symbol table where this stash
resides.  It is updated automatically when packages are aliased or deleted.
A stash that is no longer in the symbol table has no effective name.  This
name is preferable to C<HvNAME> for use in MRO linearisations and isa
caches.

=for apidoc Am|STRLEN|HvENAMELEN|HV *stash
Returns the length of the stash's effective name.

=for apidoc Am|unsigned char|HvENAMEUTF8|HV *stash
Returns true if the effective name is in UTF8 encoding.

=for apidoc Am|void*|HeKEY|HE* he
Returns the actual pointer stored in the key slot of the hash entry.  The
pointer may be either C<char*> or C<SV*>, depending on the value of
C<HeKLEN()>.  Can be assigned to.  The C<HePV()> or C<HeSVKEY()> macros are
usually preferable for finding the value of a key.

=for apidoc Am|STRLEN|HeKLEN|HE* he
If this is negative, and amounts to C<HEf_SVKEY>, it indicates the entry
holds an C<SV*> key.  Otherwise, holds the actual length of the key.  Can
be assigned to.  The C<HePV()> macro is usually preferable for finding key
lengths.

=for apidoc Am|SV*|HeVAL|HE* he
Returns the value slot (type C<SV*>)
stored in the hash entry.  Can be assigned
to.

  SV *foo= HeVAL(hv);
  HeVAL(hv)= sv;


=for apidoc Am|U32|HeHASH|HE* he
Returns the computed hash stored in the hash entry.

=for apidoc Am|char*|HePV|HE* he|STRLEN len
Returns the key slot of the hash entry as a C<char*> value, doing any
necessary dereferencing of possibly C<SV*> keys.  The length of the string
is placed in C<len> (this is a macro, so do I<not> use C<&len>).  If you do
not care about what the length of the key is, you may use the global
variable C<PL_na>, though this is rather less efficient than using a local
variable.  Remember though, that hash keys in perl are free to contain
embedded nulls, so using C<strlen()> or similar is not a good way to find
the length of hash keys.  This is very similar to the C<SvPV()> macro
described elsewhere in this document.  See also C<HeUTF8>.

If you are using C<HePV> to get values to pass to C<newSVpvn()> to create a
new SV, you should consider using C<newSVhek(HeKEY_hek(he))> as it is more
efficient.

=for apidoc Am|U32|HeUTF8|HE* he
Returns whether the C<char *> value returned by C<HePV> is encoded in UTF-8,
doing any necessary dereferencing of possibly C<SV*> keys.  The value returned
will be 0 or non-0, not necessarily 1 (or even a value with any low bits set),
so B<do not> blindly assign this to a C<bool> variable, as C<bool> may be a
typedef for C<char>.

=for apidoc Am|SV*|HeSVKEY|HE* he
Returns the key as an C<SV*>, or C<NULL> if the hash entry does not
contain an C<SV*> key.

=for apidoc Am|SV*|HeSVKEY_force|HE* he
Returns the key as an C<SV*>.  Will create and return a temporary mortal
C<SV*> if the hash entry contains only a C<char*> key.

=for apidoc Am|SV*|HeSVKEY_set|HE* he|SV* sv
Sets the key to a given C<SV*>, taking care to set the appropriate flags to
indicate the presence of an C<SV*> key, and returns the same
C<SV*>.

=cut
*/

#define PERL_HASH_DEFAULT_HvMAX 7

/* During hsplit(), if HvMAX(hv)+1 (the new bucket count) is >= this value,
 * we preallocate the HvAUX() struct.
 * The assumption being that we are using so much space anyway we might
 * as well allocate the extra bytes and speed up later keys()
 * or each() operations. We don't do this to small hashes as we assume
 * that a) it will be easy/fast to resize them to add the iterator, and b) that
 * many of them will be objects which won't be traversed. Larger hashes however
 * will take longer to extend, and the size of the aux struct is swamped by the
 * overall length of the bucket array.
 * */
#define PERL_HV_ALLOC_AUX_SIZE (1 << 9)

/* these hash entry flags ride on hent_klen (for use only in magic/tied HVs) */
#define HEf_SVKEY	-2	/* hent_key is an SV* */

#ifndef PERL_CORE
#  define Nullhv Null(HV*)
#endif
#define HvARRAY(hv)	((hv)->sv_u.svu_hash)
#define HvFILL(hv)	Perl_hv_fill(aTHX_ MUTABLE_HV(hv))
#define HvMAX(hv)	((XPVHV*)  SvANY(hv))->xhv_max
/* This quite intentionally does no flag checking first. That's your
   responsibility.  */
#define HvAUX(hv)	((struct xpvhv_aux*)&(HvARRAY(hv)[HvMAX(hv)+1]))
#define HvRITER(hv)	(*Perl_hv_riter_p(aTHX_ MUTABLE_HV(hv)))
#define HvEITER(hv)	(*Perl_hv_eiter_p(aTHX_ MUTABLE_HV(hv)))
#define HvRITER_set(hv,r)	Perl_hv_riter_set(aTHX_ MUTABLE_HV(hv), r)
#define HvEITER_set(hv,e)	Perl_hv_eiter_set(aTHX_ MUTABLE_HV(hv), e)
#define HvRITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_riter : -1)
#define HvEITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_eiter : NULL)
#define HvRAND_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_rand : 0)
#define HvLASTRAND_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_last_rand : 0)

#define HvNAME(hv)	HvNAME_get(hv)
#define HvNAMELEN(hv)   HvNAMELEN_get(hv)
#define HvENAME(hv)	HvENAME_get(hv)
#define HvENAMELEN(hv)  HvENAMELEN_get(hv)

/* Checking that hv is a valid package stash is the
   caller's responsibility */
#define HvMROMETA(hv) (HvAUX(hv)->xhv_mro_meta \
                       ? HvAUX(hv)->xhv_mro_meta \
                       : Perl_mro_meta_init(aTHX_ hv))

#define HvNAME_HEK_NN(hv)			  \
 (						  \
  HvAUX(hv)->xhv_name_count			  \
  ? *HvAUX(hv)->xhv_name_u.xhvnameu_names	  \
  : HvAUX(hv)->xhv_name_u.xhvnameu_name		  \
 )
/* This macro may go away without notice.  */
#define HvNAME_HEK(hv) \
	(SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name ? HvNAME_HEK_NN(hv) : NULL)
#define HvNAME_get(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
			 ? HEK_KEY(HvNAME_HEK_NN(hv)) : NULL)
#define HvNAMELEN_get(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
				 ? HEK_LEN(HvNAME_HEK_NN(hv)) : 0)
#define HvNAMEUTF8(hv) \
	((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvNAME_HEK_NN(hv)) \
				 ? HEK_UTF8(HvNAME_HEK_NN(hv)) : 0)
#define HvENAME_HEK_NN(hv)                                             \
 (                                                                      \
  HvAUX(hv)->xhv_name_count > 0   ? HvAUX(hv)->xhv_name_u.xhvnameu_names[0] : \
  HvAUX(hv)->xhv_name_count < -1  ? HvAUX(hv)->xhv_name_u.xhvnameu_names[1] : \
  HvAUX(hv)->xhv_name_count == -1 ? NULL                              : \
                                    HvAUX(hv)->xhv_name_u.xhvnameu_name \
 )
#define HvENAME_HEK(hv) \
	(SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name ? HvENAME_HEK_NN(hv) : NULL)
#define HvENAME_get(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
			 ? HEK_KEY(HvENAME_HEK_NN(hv)) : NULL)
#define HvENAMELEN_get(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
				 ? HEK_LEN(HvENAME_HEK_NN(hv)) : 0)
#define HvENAMEUTF8(hv) \
   ((SvOOK(hv) && HvAUX(hv)->xhv_name_u.xhvnameu_name && HvAUX(hv)->xhv_name_count != -1) \
				 ? HEK_UTF8(HvENAME_HEK_NN(hv)) : 0)

/* the number of keys (including any placeholders) */
#define XHvTOTALKEYS(xhv)	((xhv)->xhv_keys)

/*
 * HvKEYS gets the number of keys that actually exist(), and is provided
 * for backwards compatibility with old XS code. The core uses HvUSEDKEYS
 * (keys, excluding placeholders) and HvTOTALKEYS (including placeholders)
 */
#define HvKEYS(hv)		HvUSEDKEYS(hv)
#define HvUSEDKEYS(hv)		(HvTOTALKEYS(hv) - HvPLACEHOLDERS_get(hv))
#define HvTOTALKEYS(hv)		XHvTOTALKEYS((XPVHV*)  SvANY(hv))
#define HvPLACEHOLDERS(hv)	(*Perl_hv_placeholders_p(aTHX_ MUTABLE_HV(hv)))
#define HvPLACEHOLDERS_get(hv)	(SvMAGIC(hv) ? Perl_hv_placeholders_get(aTHX_ (const HV *)hv) : 0)
#define HvPLACEHOLDERS_set(hv,p)	Perl_hv_placeholders_set(aTHX_ MUTABLE_HV(hv), p)

#define HvSHAREKEYS(hv)		(SvFLAGS(hv) & SVphv_SHAREKEYS)
#define HvSHAREKEYS_on(hv)	(SvFLAGS(hv) |= SVphv_SHAREKEYS)
#define HvSHAREKEYS_off(hv)	(SvFLAGS(hv) &= ~SVphv_SHAREKEYS)

/* This is an optimisation flag. It won't be set if all hash keys have a 0
 * flag. Currently the only flags relate to utf8.
 * Hence it won't be set if all keys are 8 bit only. It will be set if any key
 * is utf8 (including 8 bit keys that were entered as utf8, and need upgrading
 * when retrieved during iteration. It may still be set when there are no longer
 * any utf8 keys.
 * See HVhek_ENABLEHVKFLAGS for the trigger.
 */
#define HvHASKFLAGS(hv)		(SvFLAGS(hv) & SVphv_HASKFLAGS)
#define HvHASKFLAGS_on(hv)	(SvFLAGS(hv) |= SVphv_HASKFLAGS)
#define HvHASKFLAGS_off(hv)	(SvFLAGS(hv) &= ~SVphv_HASKFLAGS)

#define HvLAZYDEL(hv)		(SvFLAGS(hv) & SVphv_LAZYDEL)
#define HvLAZYDEL_on(hv)	(SvFLAGS(hv) |= SVphv_LAZYDEL)
#define HvLAZYDEL_off(hv)	(SvFLAGS(hv) &= ~SVphv_LAZYDEL)

#ifndef PERL_CORE
#  define Nullhe Null(HE*)
#endif
#define HeNEXT(he)		(he)->hent_next
#define HeKEY_hek(he)		(he)->hent_hek
#define HeKEY(he)		HEK_KEY(HeKEY_hek(he))
#define HeKEY_sv(he)		(*(SV**)HeKEY(he))
#define HeKLEN(he)		HEK_LEN(HeKEY_hek(he))
#define HeKUTF8(he)  HEK_UTF8(HeKEY_hek(he))
#define HeKWASUTF8(he)  HEK_WASUTF8(HeKEY_hek(he))
#define HeKLEN_UTF8(he)  (HeKUTF8(he) ? -HeKLEN(he) : HeKLEN(he))
#define HeKFLAGS(he)  HEK_FLAGS(HeKEY_hek(he))
#define HeVAL(he)		(he)->he_valu.hent_val
#define HeHASH(he)		HEK_HASH(HeKEY_hek(he))
#define HePV(he,lp)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvPV(HeKEY_sv(he),lp) :		\
				 ((lp = HeKLEN(he)), HeKEY(he)))
#define HeUTF8(he)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvUTF8(HeKEY_sv(he)) :			\
				 (U32)HeKUTF8(he))

#define HeSVKEY(he)		((HeKEY(he) && 				\
				  HeKLEN(he) == HEf_SVKEY) ?		\
				 HeKEY_sv(he) : NULL)

#define HeSVKEY_force(he)	(HeKEY(he) ?				\
				 ((HeKLEN(he) == HEf_SVKEY) ?		\
				  HeKEY_sv(he) :			\
				  newSVpvn_flags(HeKEY(he),		\
                                                 HeKLEN(he),            \
                                                 SVs_TEMP |             \
                                      ( HeKUTF8(he) ? SVf_UTF8 : 0 ))) : \
				 &PL_sv_undef)
#define HeSVKEY_set(he,sv)	((HeKLEN(he) = HEf_SVKEY), (HeKEY_sv(he) = sv))

#ifndef PERL_CORE
#  define Nullhek Null(HEK*)
#endif
#define HEK_BASESIZE		STRUCT_OFFSET(HEK, hek_key[0])
#define HEK_HASH(hek)		(hek)->hek_hash
#define HEK_LEN(hek)		(hek)->hek_len
#define HEK_KEY(hek)		(hek)->hek_key
#define HEK_FLAGS(hek)	(*((unsigned char *)(HEK_KEY(hek))+HEK_LEN(hek)+1))

#define HVhek_UTF8	0x01 /* Key is utf8 encoded. */
#define HVhek_WASUTF8	0x02 /* Key is bytes here, but was supplied as utf8. */
#define HVhek_UNSHARED	0x08 /* This key isn't a shared hash key. */
#define HVhek_FREEKEY	0x100 /* Internal flag to say key is malloc()ed.  */
#define HVhek_PLACEHOLD	0x200 /* Internal flag to create placeholder.
                               * (may change, but Storable is a core module) */
#define HVhek_KEYCANONICAL 0x400 /* Internal flag - key is in canonical form.
				    If the string is UTF-8, it cannot be
				    converted to bytes. */
#define HVhek_MASK	0xFF

#define HVhek_ENABLEHVKFLAGS        (HVhek_MASK & ~(HVhek_UNSHARED))

#define HEK_UTF8(hek)		(HEK_FLAGS(hek) & HVhek_UTF8)
#define HEK_UTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_UTF8)
#define HEK_UTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_UTF8)
#define HEK_WASUTF8(hek)	(HEK_FLAGS(hek) & HVhek_WASUTF8)
#define HEK_WASUTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_WASUTF8)
#define HEK_WASUTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_WASUTF8)

/* calculate HV array allocation */
#ifndef PERL_USE_LARGE_HV_ALLOC
/* Default to allocating the correct size - default to assuming that malloc()
   is not broken and is efficient at allocating blocks sized at powers-of-two.
*/   
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) ((size) * sizeof(HE*))
#else
#  define MALLOC_OVERHEAD 16
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) \
			(((size) < 64)					\
			 ? (size) * sizeof(HE*)				\
			 : (size) * sizeof(HE*) * 2 - MALLOC_OVERHEAD)
#endif

/* Flags for hv_iternext_flags.  */
#define HV_ITERNEXT_WANTPLACEHOLDERS	0x01	/* Don't skip placeholders.  */

#define hv_iternext(hv)	hv_iternext_flags(hv, 0)
#define hv_magic(hv, gv, how) sv_magic(MUTABLE_SV(hv), MUTABLE_SV(gv), how, NULL, 0)
#define hv_undef(hv) Perl_hv_undef_flags(aTHX_ hv, 0)

#define Perl_sharepvn(pv, len, hash) HEK_KEY(share_hek(pv, len, hash))
#define sharepvn(pv, len, hash)	     Perl_sharepvn(pv, len, hash)

#define share_hek_hek(hek)						\
    (++(((struct shared_he *)(((char *)hek)				\
			      - STRUCT_OFFSET(struct shared_he,		\
					      shared_he_hek)))		\
	->shared_he_he.he_valu.hent_refcount),				\
     hek)

#define hv_store_ent(hv, keysv, val, hash)				\
    ((HE *) hv_common((hv), (keysv), NULL, 0, 0, HV_FETCH_ISSTORE,	\
		      (val), (hash)))

#define hv_exists_ent(hv, keysv, hash)					\
    (hv_common((hv), (keysv), NULL, 0, 0, HV_FETCH_ISEXISTS, 0, (hash))	\
     ? TRUE : FALSE)
#define hv_fetch_ent(hv, keysv, lval, hash)				\
    ((HE *) hv_common((hv), (keysv), NULL, 0, 0,			\
		      ((lval) ? HV_FETCH_LVALUE : 0), NULL, (hash)))
#define hv_delete_ent(hv, key, flags, hash)				\
    (MUTABLE_SV(hv_common((hv), (key), NULL, 0, 0, (flags) | HV_DELETE,	\
			  NULL, (hash))))

#define hv_store_flags(hv, key, klen, val, hash, flags)			\
    ((SV**) hv_common((hv), NULL, (key), (klen), (flags),		\
		      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val),	\
		      (hash)))

#define hv_store(hv, key, klen, val, hash)				\
    ((SV**) hv_common_key_len((hv), (key), (klen),			\
			      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV),	\
			      (val), (hash)))

#define hv_exists(hv, key, klen)					\
    (hv_common_key_len((hv), (key), (klen), HV_FETCH_ISEXISTS, NULL, 0) \
     ? TRUE : FALSE)

#define hv_fetch(hv, key, klen, lval)					\
    ((SV**) hv_common_key_len((hv), (key), (klen), (lval)		\
			      ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			      : HV_FETCH_JUST_SV, NULL, 0))

#define hv_delete(hv, key, klen, flags)					\
    (MUTABLE_SV(hv_common_key_len((hv), (key), (klen),			\
				  (flags) | HV_DELETE, NULL, 0)))

#ifdef PERL_CORE
# define hv_storehek(hv, hek, val) \
    hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek),	\
	      HV_FETCH_ISSTORE|HV_FETCH_JUST_SV, (val), HEK_HASH(hek))
# define hv_fetchhek(hv, hek, lval) \
    ((SV **)								\
     hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek),	\
	       (lval)							\
		? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)			\
		: HV_FETCH_JUST_SV,					\
	       NULL, HEK_HASH(hek)))
# define hv_deletehek(hv, hek, flags) \
    hv_common((hv), NULL, HEK_KEY(hek), HEK_LEN(hek), HEK_UTF8(hek), \
	      (flags)|HV_DELETE, NULL, HEK_HASH(hek))
#endif

/* This refcounted he structure is used for storing the hints used for lexical
   pragmas. Without threads, it's basically struct he + refcount.
   With threads, life gets more complex as the structure needs to be shared
   between threads (because it hangs from OPs, which are shared), hence the
   alternate definition and mutex.  */

struct refcounted_he;

/* flags for the refcounted_he API */
#define REFCOUNTED_HE_KEY_UTF8		0x00000001
#ifdef PERL_CORE
# define REFCOUNTED_HE_EXISTS		0x00000002
#endif

#ifdef PERL_CORE

/* Gosh. This really isn't a good name any longer.  */
struct refcounted_he {
    struct refcounted_he *refcounted_he_next;	/* next entry in chain */
#ifdef USE_ITHREADS
    U32                   refcounted_he_hash;
    U32                   refcounted_he_keylen;
#else
    HEK                  *refcounted_he_hek;	/* hint key */
#endif
    union {
	IV                refcounted_he_u_iv;
	UV                refcounted_he_u_uv;
	STRLEN            refcounted_he_u_len;
	void		 *refcounted_he_u_ptr;	/* Might be useful in future */
    } refcounted_he_val;
    U32	                  refcounted_he_refcnt;	/* reference count */
    /* First byte is flags. Then NUL-terminated value. Then for ithreads,
       non-NUL terminated key.  */
    char                  refcounted_he_data[1];
};

/*
=for apidoc m|SV *|refcounted_he_fetch_pvs|const struct refcounted_he *chain|const char *key|U32 flags

Like L</refcounted_he_fetch_pvn>, but takes a literal string instead of
a string/length pair, and no precomputed hash.

=cut
*/

#define refcounted_he_fetch_pvs(chain, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ chain, STR_WITH_LEN(key), 0, flags)

/*
=for apidoc m|struct refcounted_he *|refcounted_he_new_pvs|struct refcounted_he *parent|const char *key|SV *value|U32 flags

Like L</refcounted_he_new_pvn>, but takes a literal string instead of
a string/length pair, and no precomputed hash.

=cut
*/

#define refcounted_he_new_pvs(parent, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ parent, STR_WITH_LEN(key), 0, value, flags)

/* Flag bits are HVhek_UTF8, HVhek_WASUTF8, then */
#define HVrhek_undef	0x00 /* Value is undef. */
#define HVrhek_delete	0x10 /* Value is placeholder - signifies delete. */
#define HVrhek_IV	0x20 /* Value is IV. */
#define HVrhek_UV	0x30 /* Value is UV. */
#define HVrhek_PV	0x40 /* Value is a (byte) string. */
#define HVrhek_PV_UTF8	0x50 /* Value is a (utf8) string. */
/* Two spare. As these have to live in the optree, you can't store anything
   interpreter specific, such as SVs. :-( */
#define HVrhek_typemask 0x70

#ifdef USE_ITHREADS
/* A big expression to find the key offset */
#define REF_HE_KEY(chain)						\
	((((chain->refcounted_he_data[0] & 0x60) == 0x40)		\
	    ? chain->refcounted_he_val.refcounted_he_u_len + 1 : 0)	\
	 + 1 + chain->refcounted_he_data)
#endif

#  ifdef USE_ITHREADS
#    define HINTS_REFCNT_LOCK		MUTEX_LOCK(&PL_hints_mutex)
#    define HINTS_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_hints_mutex)
#  else
#    define HINTS_REFCNT_LOCK		NOOP
#    define HINTS_REFCNT_UNLOCK		NOOP
#  endif
#endif

#ifdef USE_ITHREADS
#  define HINTS_REFCNT_INIT		MUTEX_INIT(&PL_hints_mutex)
#  define HINTS_REFCNT_TERM		MUTEX_DESTROY(&PL_hints_mutex)
#else
#  define HINTS_REFCNT_INIT		NOOP
#  define HINTS_REFCNT_TERM		NOOP
#endif

/* Hash actions
 * Passed in PERL_MAGIC_uvar calls
 */
#define HV_DISABLE_UVAR_XKEY	0x01
/* We need to ensure that these don't clash with G_DISCARD, which is 2, as it
   is documented as being passed to hv_delete().  */
#define HV_FETCH_ISSTORE	0x04
#define HV_FETCH_ISEXISTS	0x08
#define HV_FETCH_LVALUE		0x10
#define HV_FETCH_JUST_SV	0x20
#define HV_DELETE		0x40
#define HV_FETCH_EMPTY_HE	0x80 /* Leave HeVAL null. */

/* Must not conflict with HVhek_UTF8 */
#define HV_NAME_SETALL		0x02

/*
=for apidoc newHV

Creates a new HV.  The reference count is set to 1.

=cut
*/

#define newHV()	MUTABLE_HV(newSV_type(SVt_PVHV))

#include "hv_func.h"

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                      /*    nostdio.h
 *
 *    Copyright (C) 1996, 2000, 2001, 2005, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Strong denial of stdio - make all stdio calls (we can think of) errors
 */
/* This is a 1st attempt to stop other include files pulling
   in real <stdio.h>.
   A more ambitious set of possible symbols can be found in
   sfio.h (inside an _cplusplus gard).
   It is completely pointless as we have already included it ourselves.
*/

#if !defined(_STDIO_H) && !defined(FILE) && !defined(_STDIO_INCLUDED) && !defined(__STDIO_LOADED)
#define _STDIO_H
#define _STDIO_INCLUDED
#define __STDIO_LOADED
struct _FILE;
#define FILE struct _FILE
#endif

#define _CANNOT "CANNOT"

#undef clearerr
#undef fclose
#undef fdopen
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fileno
#undef flockfile
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef ftrylockfile
#undef funlockfile
#undef fwrite
#undef getc
#undef getc_unlocked
#undef getw
#undef pclose
#undef popen
#undef putc
#undef putc_unlocked
#undef putw
#undef rewind
#undef setbuf
#undef setvbuf
#undef stderr
#undef stdin
#undef stdout
#undef tmpfile
#undef ungetc
#undef vfprintf
#undef printf

#define fprintf    _CANNOT _fprintf_
#define printf     _CANNOT _printf_
#define stdin      _CANNOT _stdin_
#define stdout     _CANNOT _stdout_
#define stderr     _CANNOT _stderr_
#ifndef OS2
#define tmpfile()  _CANNOT _tmpfile_
#endif
#define fclose(f)  _CANNOT _fclose_
#define fflush(f)  _CANNOT _fflush_
#define fopen(p,m)  _CANNOT _fopen_
#define freopen(p,m,f)  _CANNOT _freopen_
#define setbuf(f,b)  _CANNOT _setbuf_
#define setvbuf(f,b,x,s)  _CANNOT _setvbuf_
#define fscanf  _CANNOT _fscanf_
#define vfprintf(f,fmt,a)  _CANNOT _vfprintf_
#define fgetc(f)  _CANNOT _fgetc_
#define fgets(s,n,f)  _CANNOT _fgets_
#define fputc(c,f)  _CANNOT _fputc_
#define fputs(s,f)  _CANNOT _fputs_
#define getc(f)  _CANNOT _getc_
#define putc(c,f)  _CANNOT _putc_
#ifndef OS2
#define ungetc(c,f)  _CANNOT _ungetc_
#endif
#define fread(b,s,c,f)  _CANNOT _fread_
#define fwrite(b,s,c,f)  _CANNOT _fwrite_
#define fgetpos(f,p)  _CANNOT _fgetpos_
#define fseek(f,o,w)  _CANNOT _fseek_
#define fsetpos(f,p)  _CANNOT _fsetpos_
#define ftell(f)  _CANNOT _ftell_
#define rewind(f)  _CANNOT _rewind_
#define clearerr(f)  _CANNOT _clearerr_
#define feof(f)  _CANNOT _feof_
#define ferror(f)  _CANNOT _ferror_
#define __filbuf(f)  _CANNOT __filbuf_
#define __flsbuf(c,f)  _CANNOT __flsbuf_
#define _filbuf(f)  _CANNOT _filbuf_
#define _flsbuf(c,f)  _CANNOT _flsbuf_
#define fdopen(fd,p)  _CANNOT _fdopen_
#define fileno(f)  _CANNOT _fileno_
#if defined(SFIO_VERSION) && SFIO_VERSION < 20000101L
#define flockfile(f)  _CANNOT _flockfile_
#define ftrylockfile(f)  _CANNOT _ftrylockfile_
#define funlockfile(f)  _CANNOT _funlockfile_
#endif
#define getc_unlocked(f)  _CANNOT _getc_unlocked_
#define putc_unlocked(c,f)  _CANNOT _putc_unlocked_
#define popen(c,m)  _CANNOT _popen_
#define getw(f)  _CANNOT _getw_
#define putw(v,f)  _CANNOT _putw_
#ifndef OS2
#define pclose(f)  _CANNOT _pclose_
#endif

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 et:
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*    form.h
 *
 *    Copyright (C) 1991, 1992, 1993, 2000, 2004, 2011 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define FF_END          0  /* tidy up, then return */
#define FF_LINEMARK     1  /* start (or end) of a line */
#define FF_LITERAL      2  /* append <arg> literal chars */
#define FF_SKIP         3  /* skip <arg> chars in format */
#define FF_FETCH        4  /* get next item and set field size to <arg> */
#define FF_CHECKNL      5  /* find max len of item (up to \n) that fits field */
#define FF_CHECKCHOP    6  /* like CHECKNL, but up to highest split point */
#define FF_SPACE        7  /* append padding space (diff of field, item size) */
#define FF_HALFSPACE    8  /* like FF_SPACE, but only append half as many */
#define FF_ITEM         9  /* append a text item, while blanking ctrl chars */
#define FF_CHOP         10 /* (for ^*) chop the current item */
#define FF_LINEGLOB     11 /* process @*  */
#define FF_DECIMAL      12 /* do @##, ^##, where <arg>=(precision|flags) */
#define FF_NEWLINE      13 /* delete trailing spaces, then append \n */
#define FF_BLANK        14 /* for arg==0: do '~'; for arg>0 : do '~~' */
#define FF_MORE         15 /* replace long end of string with '...' */
#define FF_0DECIMAL     16 /* like FF_DECIMAL but for 0### */
#define FF_LINESNGL     17 /* process ^*  */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_STDC_PREDEF_H)) {
    eval 'sub _STDC_PREDEF_H () {1;}' unless defined(&_STDC_PREDEF_H);
    if(defined(&__GCC_IEC_559)) {
	if((defined(&__GCC_IEC_559) ? &__GCC_IEC_559 : undef) > 0) {
	    eval 'sub __STDC_IEC_559__ () {1;}' unless defined(&__STDC_IEC_559__);
	}
    } else {
	eval 'sub __STDC_IEC_559__ () {1;}' unless defined(&__STDC_IEC_559__);
    }
    if(defined(&__GCC_IEC_559_COMPLEX)) {
	if((defined(&__GCC_IEC_559_COMPLEX) ? &__GCC_IEC_559_COMPLEX : undef) > 0) {
	    eval 'sub __STDC_IEC_559_COMPLEX__ () {1;}' unless defined(&__STDC_IEC_559_COMPLEX__);
	}
    } else {
	eval 'sub __STDC_IEC_559_COMPLEX__ () {1;}' unless defined(&__STDC_IEC_559_COMPLEX__);
    }
    eval 'sub __STDC_ISO_10646__ () {201103;}' unless defined(&__STDC_ISO_10646__);
    eval 'sub __STDC_NO_THREADS__ () {1;}' unless defined(&__STDC_NO_THREADS__);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       package Unicode::Collate;

BEGIN {
    unless ("A" eq pack('U', 0x41)) {
	die "Unicode::Collate cannot stringify a Unicode code point\n";
    }
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Collate cannot get a Unicode code point\n";
    }
}

use 5.006;
use strict;
use warnings;
use Carp;
use File::Spec;

no warnings 'utf8';

our $VERSION = '1.04';
our $PACKAGE = __PACKAGE__;

### begin XS only ###
require DynaLoader;
our @ISA = qw(DynaLoader);
bootstrap Unicode::Collate $VERSION;
### end XS only ###

my @Path = qw(Unicode Collate);
my $KeyFile = "allkeys.txt";

# Perl's boolean
use constant TRUE  => 1;
use constant FALSE => "";
use constant NOMATCHPOS => -1;

# A coderef to get combining class imported from Unicode::Normalize
# (i.e. \&Unicode::Normalize::getCombinClass).
# This is also used as a HAS_UNICODE_NORMALIZE flag.
my $CVgetCombinClass;

# Supported Levels
use constant MinLevel => 1;
use constant MaxLevel => 4;

# Minimum weights at level 2 and 3, respectively
use constant Min2Wt => 0x20;
use constant Min3Wt => 0x02;

# Shifted weight at 4th level
use constant Shift4Wt => 0xFFFF;

# A boolean for Variable and 16-bit weights at 4 levels of Collation Element
use constant VCE_TEMPLATE => 'Cn4';

# A sort key: 16-bit weights
use constant KEY_TEMPLATE => 'n*';

# The tie-breaking: 32-bit weights
use constant TIE_TEMPLATE => 'N*';

# Level separator in a sort key:
# i.e. pack(KEY_TEMPLATE, 0)
use constant LEVEL_SEP => "\0\0";

# As Unicode code point separator for hash keys.
# A joined code point string (denoted by JCPS below)
# like "65;768" is used for internal processing
# instead of Perl's Unicode string like "\x41\x{300}",
# as the native code point is different from the Unicode code point
# on EBCDIC platform.
# This character must not be included in any stringified
# representation of an integer.
use constant CODE_SEP => ';';
	# NOTE: in regex /;/ is used for $jcps!

# boolean values of variable weights
use constant NON_VAR => 0; # Non-Variable character
use constant VAR     => 1; # Variable character

# specific code points
use constant Hangul_SIni   => 0xAC00;
use constant Hangul_SFin   => 0xD7A3;

# Logical_Order_Exception in PropList.txt
my $DefaultRearrange = [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ];

# for highestFFFF and minimalFFFE
my $HighestVCE = pack(VCE_TEMPLATE, 0, 0xFFFE, 0x20, 0x5, 0xFFFF);
my $minimalVCE = pack(VCE_TEMPLATE, 0,      1, 0x20, 0x5, 0xFFFE);

sub UCA_Version { "28" }

sub Base_Unicode_Version { "6.3.0" }

######

sub pack_U {
    return pack('U*', @_);
}

### begin XS only ###
*unpack_U = exists &Unicode::Collate::bootstrap &&
	$] < 5.008 && \&unpackUfor56 && 0x41 == unpackUfor56('A')
    ? \&unpackUfor56 : sub { return unpack('U*', shift(@_).pack('U*')) };
### end XS only ###

######

my (%VariableOK);
@VariableOK{ qw/
    blanked  non-ignorable  shifted  shift-trimmed
  / } = (); # keys lowercased

our @ChangeOK = qw/
    alternate backwards level normalization rearrange
    katakana_before_hiragana upper_before_lower ignore_level2
    overrideCJK overrideHangul overrideOut preprocess UCA_Version
    hangul_terminator variable identical highestFFFF minimalFFFE
  /;

our @ChangeNG = qw/
    entry mapping table maxlength contraction
    ignoreChar ignoreName undefChar undefName rewrite
    versionTable alternateTable backwardsTable forwardsTable
    rearrangeTable variableTable
    derivCode normCode rearrangeHash backwardsFlag
    suppress suppressHash
    __useXS /; ### XS only
# The hash key 'ignored' was deleted at v 0.21.
# The hash key 'isShift' was deleted at v 0.23.
# The hash key 'combining' was deleted at v 0.24.
# The hash key 'entries' was deleted at v 0.30.
# The hash key 'L3_ignorable' was deleted at v 0.40.

sub version {
    my $self = shift;
    return $self->{versionTable} || 'unknown';
}

my (%ChangeOK, %ChangeNG);
@ChangeOK{ @ChangeOK } = ();
@ChangeNG{ @ChangeNG } = ();

sub change {
    my $self = shift;
    my %hash = @_;
    my %old;
    if (exists $hash{alternate}) {
	if (exists $hash{variable}) {
	    delete $hash{alternate};
	} else {
	    $hash{variable} = $hash{alternate};
	}
    }
    foreach my $k (keys %hash) {
	if (exists $ChangeOK{$k}) {
	    $old{$k} = $self->{$k};
	    $self->{$k} = $hash{$k};
	} elsif (exists $ChangeNG{$k}) {
	    croak "change of $k via change() is not allowed!";
	}
	# else => ignored
    }
    $self->checkCollator();
    return wantarray ? %old : $self;
}

sub _checkLevel {
    my $level = shift;
    my $key   = shift; # 'level' or 'backwards'
    MinLevel <= $level or croak sprintf
	"Illegal level %d (in value for key '%s') lower than %d.",
	    $level, $key, MinLevel;
    $level <= MaxLevel or croak sprintf
	"Unsupported level %d (in value for key '%s') higher than %d.",
	    $level, $key, MaxLevel;
}

my %DerivCode = (
    8 => \&_derivCE_8,
    9 => \&_derivCE_9,
   11 => \&_derivCE_9, # 11 == 9
   14 => \&_derivCE_14,
   16 => \&_derivCE_14, # 16 == 14
   18 => \&_derivCE_18,
   20 => \&_derivCE_20,
   22 => \&_derivCE_22,
   24 => \&_derivCE_24,
   26 => \&_derivCE_24, # 26 == 24
   28 => \&_derivCE_24, # 28 == 24
);

sub checkCollator {
    my $self = shift;
    _checkLevel($self->{level}, "level");

    $self->{derivCode} = $DerivCode{ $self->{UCA_Version} }
	or croak "Illegal UCA version (passed $self->{UCA_Version}).";

    $self->{variable} ||= $self->{alternate} || $self->{variableTable} ||
				$self->{alternateTable} || 'shifted';
    $self->{variable} = $self->{alternate} = lc($self->{variable});
    exists $VariableOK{ $self->{variable} }
	or croak "$PACKAGE unknown variable parameter name: $self->{variable}";

    if (! defined $self->{backwards}) {
	$self->{backwardsFlag} = 0;
    } elsif (! ref $self->{backwards}) {
	_checkLevel($self->{backwards}, "backwards");
	$self->{backwardsFlag} = 1 << $self->{backwards};
    } else {
	my %level;
	$self->{backwardsFlag} = 0;
	for my $b (@{ $self->{backwards} }) {
	    _checkLevel($b, "backwards");
	    $level{$b} = 1;
	}
	for my $v (sort keys %level) {
	    $self->{backwardsFlag} += 1 << $v;
	}
    }

    defined $self->{rearrange} or $self->{rearrange} = [];
    ref $self->{rearrange}
	or croak "$PACKAGE: list for rearrangement must be store in ARRAYREF";

    # keys of $self->{rearrangeHash} are $self->{rearrange}.
    $self->{rearrangeHash} = undef;

    if (@{ $self->{rearrange} }) {
	@{ $self->{rearrangeHash} }{ @{ $self->{rearrange} } } = ();
    }

    $self->{normCode} = undef;

    if (defined $self->{normalization}) {
	eval { require Unicode::Normalize };
	$@ and croak "Unicode::Normalize is required to normalize strings";

	$CVgetCombinClass ||= \&Unicode::Normalize::getCombinClass;

	if ($self->{normalization} =~ /^(?:NF)D\z/) { # tweak for default
	    $self->{normCode} = \&Unicode::Normalize::NFD;
	}
	elsif ($self->{normalization} ne 'prenormalized') {
	    my $norm = $self->{normalization};
	    $self->{normCode} = sub {
		Unicode::Normalize::normalize($norm, shift);
	    };
	    eval { $self->{normCode}->("") }; # try
	    $@ and croak "$PACKAGE unknown normalization form name: $norm";
	}
    }
    return;
}

sub new
{
    my $class = shift;
    my $self = bless { @_ }, $class;

### begin XS only ###
    if (! exists $self->{table}     && !defined $self->{rewrite} &&
	!defined $self->{undefName} && !defined $self->{ignoreName} &&
	!defined $self->{undefChar} && !defined $self->{ignoreChar}) {
	$self->{__useXS} = \&_fetch_simple;
    } else {
	$self->{__useXS} = undef;
    }
### end XS only ###

    # keys of $self->{suppressHash} are $self->{suppress}.
    if ($self->{suppress} && @{ $self->{suppress} }) {
	@{ $self->{suppressHash} }{ @{ $self->{suppress} } } = ();
    } # before read_table()

    # If undef is passed explicitly, no file is read.
    $self->{table} = $KeyFile if ! exists $self->{table};
    $self->read_table() if defined $self->{table};

    if ($self->{entry}) {
	while ($self->{entry} =~ /([^\n]+)/g) {
	    $self->parseEntry($1, TRUE);
	}
    }

    $self->{level} ||= MaxLevel;
    $self->{UCA_Version} ||= UCA_Version();

    $self->{overrideHangul} = FALSE
	if ! exists $self->{overrideHangul};
    $self->{overrideCJK} = FALSE
	if ! exists $self->{overrideCJK};
    $self->{normalization} = 'NFD'
	if ! exists $self->{normalization};
    $self->{rearrange} = $self->{rearrangeTable} ||
	($self->{UCA_Version} <= 11 ? $DefaultRearrange : [])
	if ! exists $self->{rearrange};
    $self->{backwards} = $self->{backwardsTable}
	if ! exists $self->{backwards};

    $self->checkCollator();

    return $self;
}

sub parseAtmark {
    my $self = shift;
    my $line = shift; # after s/^\s*\@//

    if ($line =~ /^version\s*(\S*)/) {
	$self->{versionTable} ||= $1;
    }
    elsif ($line =~ /^variable\s+(\S*)/) { # since UTS #10-9
	$self->{variableTable} ||= $1;
    }
    elsif ($line =~ /^alternate\s+(\S*)/) { # till UTS #10-8
	$self->{alternateTable} ||= $1;
    }
    elsif ($line =~ /^backwards\s+(\S*)/) {
	push @{ $self->{backwardsTable} }, $1;
    }
    elsif ($line =~ /^forwards\s+(\S*)/) { # perhaps no use
	push @{ $self->{forwardsTable} }, $1;
    }
    elsif ($line =~ /^rearrange\s+(.*)/) { # (\S*) is NG
	push @{ $self->{rearrangeTable} }, _getHexArray($1);
    }
}

sub read_table {
    my $self = shift;

### begin XS only ###
    if ($self->{__useXS}) {
	my @rest = _fetch_rest(); # complex matter need to parse
	for my $line (@rest) {
	    next if $line =~ /^\s*#/;

	    if ($line =~ s/^\s*\@//) {
		$self->parseAtmark($line);
	    } else {
		$self->parseEntry($line);
	    }
	}
	return;
    }
### end XS only ###

    my($f, $fh);
    foreach my $d (@INC) {
	$f = File::Spec->catfile($d, @Path, $self->{table});
	last if open($fh, $f);
	$f = undef;
    }
    if (!defined $f) {
	$f = File::Spec->catfile(@Path, $self->{table});
	croak("$PACKAGE: Can't locate $f in \@INC (\@INC contains: @INC)");
    }

    while (my $line = <$fh>) {
	next if $line =~ /^\s*#/;

	if ($line =~ s/^\s*\@//) {
	    $self->parseAtmark($line);
	} else {
	    $self->parseEntry($line);
	}
    }
    close $fh;
}


##
## get $line, parse it, and write an entry in $self
##
sub parseEntry
{
    my $self = shift;
    my $line = shift;
    my $tailoring = shift;
    my($name, $entry, @uv, @key);

    if (defined $self->{rewrite}) {
	$line = $self->{rewrite}->($line);
    }

    return if $line !~ /^\s*[0-9A-Fa-f]/;

    # removes comment and gets name
    $name = $1
	if $line =~ s/[#%]\s*(.*)//;
    return if defined $self->{undefName} && $name =~ /$self->{undefName}/;

    # gets element
    my($e, $k) = split /;/, $line;
    croak "Wrong Entry: <charList> must be separated by ';' from <collElement>"
	if ! $k;

    @uv = _getHexArray($e);
    return if !@uv;
    return if @uv > 1 && $self->{suppressHash} && !$tailoring &&
		  exists $self->{suppressHash}{$uv[0]};
    $entry = join(CODE_SEP, @uv); # in JCPS

    if (defined $self->{undefChar} || defined $self->{ignoreChar}) {
	my $ele = pack_U(@uv);

	# regarded as if it were not stored in the table
	return
	    if defined $self->{undefChar} && $ele =~ /$self->{undefChar}/;

	# replaced as completely ignorable
	$k = '[.0000.0000.0000.0000]'
	    if defined $self->{ignoreChar} && $ele =~ /$self->{ignoreChar}/;
    }

    # replaced as completely ignorable
    $k = '[.0000.0000.0000.0000]'
	if defined $self->{ignoreName} && $name =~ /$self->{ignoreName}/;

    my $is_L3_ignorable = TRUE;

    foreach my $arr ($k =~ /\[([^\[\]]+)\]/g) { # SPACEs allowed
	my $var = $arr =~ /\*/; # exactly /^\*/ but be lenient.
	my @wt = _getHexArray($arr);
	push @key, pack(VCE_TEMPLATE, $var, @wt);
	$is_L3_ignorable = FALSE
	    if $wt[0] || $wt[1] || $wt[2];
	# Conformance Test for 3.1.1 and 4.0.0 shows Level 3 ignorable
	# is completely ignorable.
	# For expansion, an entry $is_L3_ignorable
	# if and only if "all" CEs are [.0000.0000.0000].
    }

    $self->{mapping}{$entry} = $is_L3_ignorable ? [] : \@key;

    if (@uv > 1) {
	if (!$self->{maxlength}{$uv[0]} || $self->{maxlength}{$uv[0]} < @uv) {
	    $self->{maxlength}{$uv[0]} = @uv;
	}
    }
    if (@uv > 2) {
	while (@uv) {
	    pop @uv;
	    my $fake_entry = join(CODE_SEP, @uv); # in JCPS
	    $self->{contraction}{$fake_entry} = 1;
	}
    }
}


sub viewSortKey
{
    my $self = shift;
    my $str  = shift;
    $self->visualizeSortKey($self->getSortKey($str));
}


sub process
{
    my $self = shift;
    my $str  = shift;
    my $prep = $self->{preprocess};
    my $norm = $self->{normCode};

    $str = &$prep($str) if ref $prep;
    $str = &$norm($str) if ref $norm;
    return $str;
}

##
## arrayref of JCPS   = splitEnt(string to be collated)
## arrayref of arrayref[JCPS, ini_pos, fin_pos] = splitEnt(string, TRUE)
##
sub splitEnt
{
    my $self = shift;
    my $str  = shift;
    my $wLen = shift; # with Length

    my $map  = $self->{mapping};
    my $max  = $self->{maxlength};
    my $reH  = $self->{rearrangeHash};
    my $vers = $self->{UCA_Version};
    my $ver9 = $vers >= 9 && $vers <= 11;
    my $uXS  = $self->{__useXS}; ### XS only

    my @buf;

    # get array of Unicode code point of string.
    my @src = unpack_U($str);

    # rearrangement:
    # Character positions are not kept if rearranged,
    # then neglected if $wLen is true.
    if ($reH && ! $wLen) {
	for (my $i = 0; $i < @src; $i++) {
	    if (exists $reH->{ $src[$i] } && $i + 1 < @src) {
		($src[$i], $src[$i+1]) = ($src[$i+1], $src[$i]);
		$i++;
	    }
	}
    }

    # remove a code point marked as a completely ignorable.
    for (my $i = 0; $i < @src; $i++) {
	if ($vers <= 20 && _isIllegal($src[$i])) {
	    $src[$i] = undef;
	} elsif ($ver9) {
	    $src[$i] = undef if $map->{ $src[$i] }
			   ? @{ $map->{ $src[$i] } } == 0
			   : $uXS && _ignorable_simple($src[$i]); ### XS only
	}
    }

    for (my $i = 0; $i < @src; $i++) {
	my $jcps = $src[$i];

	# skip removed code point
	if (! defined $jcps) {
	    if ($wLen && @buf) {
		$buf[-1][2] = $i + 1;
	    }
	    next;
	}

	my $i_orig = $i;

	# find contraction
	if ($max->{$jcps}) {
	    my $temp_jcps = $jcps;
	    my $jcpsLen = 1;
	    my $maxLen = $max->{$jcps};

	    for (my $p = $i + 1; $jcpsLen < $maxLen && $p < @src; $p++) {
		next if ! defined $src[$p];
		$temp_jcps .= CODE_SEP . $src[$p];
		$jcpsLen++;
		if ($map->{$temp_jcps}) {
		    $jcps = $temp_jcps;
		    $i = $p;
		}
	    }

	# discontiguous contraction with Combining Char (cf. UTS#10, S2.1).
	# This process requires Unicode::Normalize.
	# If "normalization" is undef, here should be skipped *always*
	# (in spite of bool value of $CVgetCombinClass),
	# since canonical ordering cannot be expected.
	# Blocked combining character should not be contracted.

	    # $self->{normCode} is false in the case of "prenormalized".
	    if ($self->{normalization}) {
		my $cont = $self->{contraction};
		my $preCC = 0;
		my $preCC_uc = 0;
		my $jcps_uc = $jcps;
		my(@out, @out_uc);

		for (my $p = $i + 1; $p < @src; $p++) {
		    next if ! defined $src[$p];
		    my $curCC = $CVgetCombinClass->($src[$p]);
		    last unless $curCC;
		    my $tail = CODE_SEP . $src[$p];

		    if ($preCC_uc != $curCC && ($map->{$jcps_uc.$tail} ||
					       $cont->{$jcps_uc.$tail})) {
			$jcps_uc .= $tail;
			push @out_uc, $p;
		    } else {
			$preCC_uc = $curCC;
		    }

		    if ($preCC != $curCC && $map->{$jcps.$tail}) {
			$jcps .= $tail;
			push @out, $p;
		    } else {
			$preCC = $curCC;
		    }
		}

		if ($map->{$jcps_uc}) {
		    $jcps = $jcps_uc;
		    $src[$_] = undef for @out_uc;
		} else {
		    $src[$_] = undef for @out;
		}
	    }
	}

	# skip completely ignorable
	if ($map->{$jcps} ? @{ $map->{$jcps} } == 0 :
	    $uXS && $jcps !~ /;/ && _ignorable_simple($jcps)) { ### XS only
	    if ($wLen && @buf) {
		$buf[-1][2] = $i + 1;
	    }
	    next;
	}

	push @buf, $wLen ? [$jcps, $i_orig, $i + 1] : $jcps;
    }
    return \@buf;
}

##
## VCE = _pack_override(input, codepoint, derivCode)
##
sub _pack_override ($$$) {
    my $r = shift;
    my $u = shift;
    my $der = shift;

    if (ref $r) {
	return pack(VCE_TEMPLATE, NON_VAR, @$r);
    } elsif (defined $r) {
	return pack(VCE_TEMPLATE, NON_VAR, $r, Min2Wt, Min3Wt, $u);
    } else {
	$u = 0xFFFD if 0x10FFFF < $u;
	return $der->($u);
    }
}

##
## list of VCE = getWt(JCPS)
##
sub getWt
{
    my $self = shift;
    my $u    = shift;
    my $map  = $self->{mapping};
    my $der  = $self->{derivCode};
    my $out  = $self->{overrideOut};
    my $uXS  = $self->{__useXS}; ### XS only

    return if !defined $u;
    return $self->varCE($HighestVCE) if $u eq 0xFFFF && $self->{highestFFFF};
    return $self->varCE($minimalVCE) if $u eq 0xFFFE && $self->{minimalFFFE};
    $u = 0xFFFD if $u !~ /;/ && 0x10FFFF < $u && !$out;

    my @ce;
    if ($map->{$u}) {
	@ce = @{ $map->{$u} }; # $u may be a contraction
### begin XS only ###
    } elsif ($uXS && _exists_simple($u)) {
	@ce = _fetch_simple($u);
### end XS only ###
    } elsif (Hangul_SIni <= $u && $u <= Hangul_SFin) {
	my $hang = $self->{overrideHangul};
	if ($hang) {
	    @ce = map _pack_override($_, $u, $der), $hang->($u);
	} elsif (!defined $hang) {
	    @ce = $der->($u);
	} else {
	    my $max  = $self->{maxlength};
	    my @decH = _decompHangul($u);

	    if (@decH == 2) {
		my $contract = join(CODE_SEP, @decH);
		@decH = ($contract) if $map->{$contract};
	    } else { # must be <@decH == 3>
		if ($max->{$decH[0]}) {
		    my $contract = join(CODE_SEP, @decH);
		    if ($map->{$contract}) {
			@decH = ($contract);
		    } else {
			$contract = join(CODE_SEP, @decH[0,1]);
			$map->{$contract} and @decH = ($contract, $decH[2]);
		    }
		    # even if V's ignorable, LT contraction is not supported.
		    # If such a situation were required, NFD should be used.
		}
		if (@decH == 3 && $max->{$decH[1]}) {
		    my $contract = join(CODE_SEP, @decH[1,2]);
		    $map->{$contract} and @decH = ($decH[0], $contract);
		}
	    }

	    @ce = map({
		    $map->{$_} ? @{ $map->{$_} } :
		$uXS && _exists_simple($_) ? _fetch_simple($_) : ### XS only
		    $der->($_);
		} @decH);
	}
    } elsif ($out && 0x10FFFF < $u) {
	@ce = map _pack_override($_, $u, $der), $out->($u);
    } else {
	my $cjk  = $self->{overrideCJK};
	my $vers = $self->{UCA_Version};
	if ($cjk && _isUIdeo($u, $vers)) {
	    @ce = map _pack_override($_, $u, $der), $cjk->($u);
	} elsif ($vers == 8 && defined $cjk && _isUIdeo($u, 0)) {
	    @ce = _uideoCE_8($u);
	} else {
	    @ce = $der->($u);
	}
    }
    return map $self->varCE($_), @ce;
}


##
## string sortkey = getSortKey(string arg)
##
sub getSortKey
{
    my $self = shift;
    my $orig = shift;
    my $str  = $self->process($orig);
    my $rEnt = $self->splitEnt($str); # get an arrayref of JCPS
    my $vers = $self->{UCA_Version};
    my $term = $self->{hangul_terminator};
    my $lev  = $self->{level};
    my $iden = $self->{identical};

    my @buf; # weight arrays
    if ($term) {
	my $preHST = '';
	my $termCE = $self->varCE(pack(VCE_TEMPLATE, NON_VAR, $term, 0,0,0));
	foreach my $jcps (@$rEnt) {
	    # weird things like VL, TL-contraction are not considered!
	    my $curHST = join '', map getHST($_, $vers), split /;/, $jcps;
	    if ($preHST && !$curHST || # hangul before non-hangul
		$preHST =~ /L\z/ && $curHST =~ /^T/ ||
		$preHST =~ /V\z/ && $curHST =~ /^L/ ||
		$preHST =~ /T\z/ && $curHST =~ /^[LV]/) {
		push @buf, $termCE;
	    }
	    $preHST = $curHST;
	    push @buf, $self->getWt($jcps);
	}
	push @buf, $termCE if $preHST; # end at hangul
    } else {
	foreach my $jcps (@$rEnt) {
	    push @buf, $self->getWt($jcps);
	}
    }

    my $rkey = $self->mk_SortKey(\@buf); ### XS only

    if ($iden || $vers >= 26 && $lev == MaxLevel) {
	$rkey .= LEVEL_SEP;
	$rkey .= pack(TIE_TEMPLATE, unpack_U($str)) if $iden;
    }
    return $rkey;
}


##
## int compare = cmp(string a, string b)
##
sub cmp { $_[0]->getSortKey($_[1]) cmp $_[0]->getSortKey($_[2]) }
sub eq  { $_[0]->getSortKey($_[1]) eq  $_[0]->getSortKey($_[2]) }
sub ne  { $_[0]->getSortKey($_[1]) ne  $_[0]->getSortKey($_[2]) }
sub lt  { $_[0]->getSortKey($_[1]) lt  $_[0]->getSortKey($_[2]) }
sub le  { $_[0]->getSortKey($_[1]) le  $_[0]->getSortKey($_[2]) }
sub gt  { $_[0]->getSortKey($_[1]) gt  $_[0]->getSortKey($_[2]) }
sub ge  { $_[0]->getSortKey($_[1]) ge  $_[0]->getSortKey($_[2]) }

##
## list[strings] sorted = sort(list[strings] arg)
##
sub sort {
    my $obj = shift;
    return
	map { $_->[1] }
	    sort{ $a->[0] cmp $b->[0] }
		map [ $obj->getSortKey($_), $_ ], @_;
}


##
## bool _nonIgnorAtLevel(arrayref weights, int level)
##
sub _nonIgnorAtLevel($$)
{
    my $wt = shift;
    return if ! defined $wt;
    my $lv = shift;
    return grep($wt->[$_-1] != 0, MinLevel..$lv) ? TRUE : FALSE;
}

##
## bool _eqArray(
##    arrayref of arrayref[weights] source,
##    arrayref of arrayref[weights] substr,
##    int level)
## * comparison of graphemes vs graphemes.
##   @$source >= @$substr must be true (check it before call this);
##
sub _eqArray($$$)
{
    my $source = shift;
    my $substr = shift;
    my $lev = shift;

    for my $g (0..@$substr-1){
	# Do the $g'th graphemes have the same number of AV weights?
	return if @{ $source->[$g] } != @{ $substr->[$g] };

	for my $w (0..@{ $substr->[$g] }-1) {
	    for my $v (0..$lev-1) {
		return if $source->[$g][$w][$v] != $substr->[$g][$w][$v];
	    }
	}
    }
    return 1;
}

##
## (int position, int length)
## int position = index(string, substring, position, [undoc'ed global])
##
## With "global" (only for the list context),
##  returns list of arrayref[position, length].
##
sub index
{
    my $self = shift;
    $self->{preprocess} and
	croak "Don't use Preprocess with index(), match(), etc.";
    $self->{normCode} and
	croak "Don't use Normalization with index(), match(), etc.";

    my $str  = shift;
    my $len  = length($str);
    my $sub  = shift;
    my $subE = $self->splitEnt($sub);
    my $pos  = @_ ? shift : 0;
       $pos  = 0 if $pos < 0;
    my $glob = shift;

    my $lev  = $self->{level};
    my $v2i  = $self->{UCA_Version} >= 9 &&
		$self->{variable} ne 'non-ignorable';

    if (! @$subE) {
	my $temp = $pos <= 0 ? 0 : $len <= $pos ? $len : $pos;
	return $glob
	    ? map([$_, 0], $temp..$len)
	    : wantarray ? ($temp,0) : $temp;
    }
    $len < $pos
	and return wantarray ? () : NOMATCHPOS;
    my $strE = $self->splitEnt($pos ? substr($str, $pos) : $str, TRUE);
    @$strE
	or return wantarray ? () : NOMATCHPOS;

    my(@strWt, @iniPos, @finPos, @subWt, @g_ret);

    my $last_is_variable;
    for my $vwt (map $self->getWt($_), @$subE) {
	my($var, @wt) = unpack(VCE_TEMPLATE, $vwt);
	my $to_be_pushed = _nonIgnorAtLevel(\@wt,$lev);

	# "Ignorable (L1, L2) after Variable" since track. v. 9
	if ($v2i) {
	    if ($var) {
		$last_is_variable = TRUE;
	    }
	    elsif (!$wt[0]) { # ignorable
		$to_be_pushed = FALSE if $last_is_variable;
	    }
	    else {
		$last_is_variable = FALSE;
	    }
	}

	if (@subWt && !$var && !$wt[0]) {
	    push @{ $subWt[-1] }, \@wt if $to_be_pushed;
	} elsif ($to_be_pushed) {
	    push @subWt, [ \@wt ];
	}
	# else ===> skipped
    }

    my $count = 0;
    my $end = @$strE - 1;

    $last_is_variable = FALSE; # reuse
    for (my $i = 0; $i <= $end; ) { # no $i++
	my $found_base = 0;

	# fetch a grapheme
	while ($i <= $end && $found_base == 0) {
	    for my $vwt ($self->getWt($strE->[$i][0])) {
		my($var, @wt) = unpack(VCE_TEMPLATE, $vwt);
		my $to_be_pushed = _nonIgnorAtLevel(\@wt,$lev);

		# "Ignorable (L1, L2) after Variable" since track. v. 9
		if ($v2i) {
		    if ($var) {
			$last_is_variable = TRUE;
		    }
		    elsif (!$wt[0]) { # ignorable
			$to_be_pushed = FALSE if $last_is_variable;
		    }
		    else {
			$last_is_variable = FALSE;
		    }
		}

		if (@strWt && !$var && !$wt[0]) {
		    push @{ $strWt[-1] }, \@wt if $to_be_pushed;
		    $finPos[-1] = $strE->[$i][2];
		} elsif ($to_be_pushed) {
		    push @strWt, [ \@wt ];
		    push @iniPos, $found_base ? NOMATCHPOS : $strE->[$i][1];
		    $finPos[-1] = NOMATCHPOS if $found_base;
		    push @finPos, $strE->[$i][2];
		    $found_base++;
		}
		# else ===> no-op
	    }
	    $i++;
	}

	# try to match
	while ( @strWt > @subWt || (@strWt == @subWt && $i > $end) ) {
	    if ($iniPos[0] != NOMATCHPOS &&
		    $finPos[$#subWt] != NOMATCHPOS &&
			_eqArray(\@strWt, \@subWt, $lev)) {
		my $temp = $iniPos[0] + $pos;

		if ($glob) {
		    push @g_ret, [$temp, $finPos[$#subWt] - $iniPos[0]];
		    splice @strWt,  0, $#subWt;
		    splice @iniPos, 0, $#subWt;
		    splice @finPos, 0, $#subWt;
		}
		else {
		    return wantarray
			? ($temp, $finPos[$#subWt] - $iniPos[0])
			:  $temp;
		}
	    }
	    shift @strWt;
	    shift @iniPos;
	    shift @finPos;
	}
    }

    return $glob
	? @g_ret
	: wantarray ? () : NOMATCHPOS;
}

##
## scalarref to matching part = match(string, substring)
##
sub match
{
    my $self = shift;
    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	my $temp = substr($_[0], $pos, $len);
	return wantarray ? $temp : \$temp;
	# An lvalue ref \substr should be avoided,
	# since its value is affected by modification of its referent.
    }
    else {
	return;
    }
}

##
## arrayref matching parts = gmatch(string, substring)
##
sub gmatch
{
    my $self = shift;
    my $str  = shift;
    my $sub  = shift;
    return map substr($str, $_->[0], $_->[1]),
		$self->index($str, $sub, 0, 'g');
}

##
## bool subst'ed = subst(string, substring, replace)
##
sub subst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;

    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	if ($code) {
	    my $mat = substr($_[0], $pos, $len);
	    substr($_[0], $pos, $len, $code->($mat));
	} else {
	    substr($_[0], $pos, $len, $_[2]);
	}
	return TRUE;
    }
    else {
	return FALSE;
    }
}

##
## int count = gsubst(string, substring, replace)
##
sub gsubst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;
    my $cnt = 0;

    # Replacement is carried out from the end, then use reverse.
    for my $pos_len (reverse $self->index($_[0], $_[1], 0, 'g')) {
	if ($code) {
	    my $mat = substr($_[0], $pos_len->[0], $pos_len->[1]);
	    substr($_[0], $pos_len->[0], $pos_len->[1], $code->($mat));
	} else {
	    substr($_[0], $pos_len->[0], $pos_len->[1], $_[2]);
	}
	$cnt++;
    }
    return $cnt;
}

1;
__END__

=head1 NAME

Unicode::Collate - Unicode Collation Algorithm

=head1 SYNOPSIS

  use Unicode::Collate;

  #construct
  $Collator = Unicode::Collate->new(%tailoring);

  #sort
  @sorted = $Collator->sort(@not_sorted);

  #compare
  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.

B<Note:> Strings in C<@not_sorted>, C<$a> and C<$b> are interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.
Otherwise you can use C<preprocess> or should decode them before.

=head1 DESCRIPTION

This module is an implementation of Unicode Technical Standard #10
(a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).

=head2 Constructor and Tailoring

The C<new> method returns a collator object. If new() is called
with no parameters, the collator should do the default collation.

   $Collator = Unicode::Collate->new(
      UCA_Version => $UCA_Version,
      alternate => $alternate, # alias for 'variable'
      backwards => $levelNumber, # or \@levelNumbers
      entry => $element,
      hangul_terminator => $term_primary_weight,
      highestFFFF => $bool,
      identical => $bool,
      ignoreName => qr/$ignoreName/,
      ignoreChar => qr/$ignoreChar/,
      ignore_level2 => $bool,
      katakana_before_hiragana => $bool,
      level => $collationLevel,
      minimalFFFE => $bool,
      normalization  => $normalization_form,
      overrideCJK => \&overrideCJK,
      overrideHangul => \&overrideHangul,
      preprocess => \&preprocess,
      rearrange => \@charList,
      rewrite => \&rewrite,
      suppress => \@charList,
      table => $filename,
      undefName => qr/$undefName/,
      undefChar => qr/$undefChar/,
      upper_before_lower => $bool,
      variable => $variable,
   );

=over 4

=item UCA_Version

If the revision (previously "tracking version") number of UCA is given,
behavior of that revision is emulated on collating.
If omitted, the return value of C<UCA_Version()> is used.

The following revisions are supported.  The default is 28.

     UCA       Unicode Standard         DUCET (@version)
   -------------------------------------------------------
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)
     16              5.0                5.0.0 (5.0.0)
     18             5.1.0               5.1.0 (5.1.0)
     20             5.2.0               5.2.0 (5.2.0)
     22             6.0.0               6.0.0 (6.0.0)
     24             6.1.0               6.1.0 (6.1.0)
     26             6.2.0               6.2.0 (6.2.0)
     28             6.3.0               6.3.0 (6.3.0)

* Noncharacters (e.g. U+FFFF) are not ignored, and can be overridden
since C<UCA_Version> 22.

* Out-of-range codepoints (greater than U+10FFFF) are not ignored,
and can be overridden since C<UCA_Version> 22.

* Fully ignorable characters were ignored, and would not interrupt
contractions with C<UCA_Version> 9 and 11.

* Treatment of ignorables after variables and some behaviors
were changed at C<UCA_Version> 9.

* Characters regarded as CJK unified ideographs (cf. C<overrideCJK>)
depend on C<UCA_Version>.

* Many hangul jamo are assigned at C<UCA_Version> 20, that will affect
C<hangul_terminator>.

=item alternate

-- see 3.2.2 Alternate Weighting, version 8 of UTS #10

For backward compatibility, C<alternate> (old name) can be used
as an alias for C<variable>.

=item backwards

-- see 3.4 Backward Accents, UTS #10.

     backwards => $levelNumber or \@levelNumbers

Weights in reverse order; ex. level 2 (diacritic ordering) in French.
If omitted (or C<$levelNumber> is C<undef> or C<\@levelNumbers> is C<[]>),
forwards at all the levels.

=item entry

-- see 5 Tailoring; 3.6.1 File Format, UTS #10.

If the same character (or a sequence of characters) exists
in the collation element table through C<table>,
mapping to collation elements is overridden.
If it does not exist, the mapping is defined additionally.

    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
ENTRY

    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as <a><e>
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as <A><E>
ENTRY

B<NOTE:> The code point in the UCA file format (before C<';'>)
B<must> be a Unicode code point (defined as hexadecimal),
but not a native code point.
So C<0063> must always denote C<U+0063>,
but not a character of C<"\x63">.

Weighting may vary depending on collation element table.
So ensure the weights defined in C<entry> will be consistent with
those in the collation element table loaded via C<table>.

In DUCET v4.0.0, primary weight of C<C> is C<0E60>
and that of C<D> is C<0E6D>. So setting primary weight of C<CH> to C<0E6A>
(as a value between C<0E60> and C<0E6D>)
makes ordering as C<C E<lt> CH E<lt> D>.
Exactly speaking DUCET already has some characters between C<C> and C<D>:
C<small capital C> (C<U+1D04>) with primary weight C<0E64>,
C<c-hook/C-hook> (C<U+0188/U+0187>) with C<0E65>,
and C<c-curl> (C<U+0255>) with C<0E69>.
Then primary weight C<0E6A> for C<CH> makes C<CH>
ordered between C<c-curl> and C<D>.

=item hangul_terminator

-- see 7.1.4 Trailing Weights, UTS #10.

If a true value is given (non-zero but should be positive),
it will be added as a terminator primary weight to the end of
every standard Hangul syllable. Secondary and any higher weights
for terminator are set to zero.
If the value is false or C<hangul_terminator> key does not exist,
insertion of terminator weights will not be performed.

Boundaries of Hangul syllables are determined
according to conjoining Jamo behavior in F<the Unicode Standard>
and F<HangulSyllableType.txt>.

B<Implementation Note:>
(1) For expansion mapping (Unicode character mapped
to a sequence of collation elements), a terminator will not be added
between collation elements, even if Hangul syllable boundary exists there.
Addition of terminator is restricted to the next position
to the last collation element.

(2) Non-conjoining Hangul letters
(Compatibility Jamo, halfwidth Jamo, and enclosed letters) are not
automatically terminated with a terminator primary weight.
These characters may need terminator included in a collation element
table beforehand.

=item highestFFFF

-- see 5.14 Collation Elements, UTS #35.

If the parameter is made true, C<U+FFFF> has a highest primary weight.
When a boolean of C<$coll-E<gt>ge($str, "abc")> and
C<$coll-E<gt>le($str, "abc\x{FFFF}")> is true, it is expected that C<$str>
begins with C<"abc">, or another primary equivalent.
C<$str> may be C<"abcd">, C<"abc012">, but should not include C<U+FFFF>
such as C<"abc\x{FFFF}xyz">.

C<$coll-E<gt>le($str, "abc\x{FFFF}")> works like C<$coll-E<gt>lt($str, "abd")>
almost, but the latter has a problem that you should know which letter is
next to C<c>. For a certain language where C<ch> as the next letter,
C<"abch"> is greater than C<"abc\x{FFFF}">, but less than C<"abd">.

Note:
This is equivalent to C<(entry =E<gt> 'FFFF ; [.FFFE.0020.0005.FFFF]')>.
Any other character than C<U+FFFF> can be tailored by C<entry>.

=item identical

-- see A.3 Deterministic Comparison, UTS #10.

By default, strings whose weights are equal should be equal,
even though their code points are not equal.
Completely ignorable characters are ignored.

If the parameter is made true, a final, tie-breaking level is used.
If no difference of weights is found after the comparison through
all the level specified by C<level>, the comparison with code points
will be performed.
For the tie-breaking comparison, the sort key has code points
of the original string appended.
Completely ignorable characters are not ignored.

If C<preprocess> and/or C<normalization> is applied, the code points
of the string after them (in NFD by default) are used.

=item ignoreChar

=item ignoreName

-- see 3.6.2 Variable Weighting, UTS #10.

Makes the entry in the table completely ignorable;
i.e. as if the weights were zero at all level.

Through C<ignoreChar>, any character matching C<qr/$ignoreChar/>
will be ignored. Through C<ignoreName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$ignoreName/>
will be ignored.

E.g. when 'a' and 'e' are ignorable,
'element' is equal to 'lament' (or 'lmnt').

=item ignore_level2

-- see 5.1 Parametric Tailoring, UTS #10.

By default, case-sensitive comparison (that is level 3 difference)
won't ignore accents (that is level 2 difference).

If the parameter is made true, accents (and other primary ignorable
characters) are ignored, even though cases are taken into account.

B<NOTE>: C<level> should be 3 or greater.

=item katakana_before_hiragana

-- see 7.2 Tertiary Weight Table, UTS #10.

By default, hiragana is before katakana.
If the parameter is made true, this is reversed.

B<NOTE>: This parameter simplemindedly assumes that any hiragana/katakana
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which violate this requirement,
this parameter does not work validly.

=item level

-- see 4.3 Form Sort Key, UTS #10.

Set the maximum level.
Any higher levels than the specified one are ignored.

  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie-breaking (e.g. in the case when variable is 'shifted')

  ex.level => 2,

If omitted, the maximum is the 4th.

B<NOTE:> The DUCET includes weights over 0xFFFF at the 4th level.
But this module only uses weights within 0xFFFF.
When C<variable> is 'blanked' or 'non-ignorable' (other than 'shifted'
and 'shift-trimmed'), the level 4 may be unreliable.

See also C<identical>.

=item minimalFFFE

-- see 5.14 Collation Elements, UTS #35.

If the parameter is made true, C<U+FFFE> has a minimal primary weight.
The comparison between C<"$a1\x{FFFE}$a2"> and C<"$b1\x{FFFE}$b2">
first compares C<$a1> and C<$b1> at level 1, and
then C<$a2> and C<$b2> at level 1, as followed.

        "ab\x{FFFE}a"
        "Ab\x{FFFE}a"
        "ab\x{FFFE}c"
        "Ab\x{FFFE}c"
        "ab\x{FFFE}xyz"
        "abc\x{FFFE}def"
        "abc\x{FFFE}xYz"
        "aBc\x{FFFE}xyz"
        "abcX\x{FFFE}def"
        "abcx\x{FFFE}xyz"
        "b\x{FFFE}aaa"
        "bbb\x{FFFE}a"

Note:
This is equivalent to C<(entry =E<gt> 'FFFE ; [.0001.0020.0005.FFFE]')>.
Any other character than C<U+FFFE> can be tailored by C<entry>.

=item normalization

-- see 4.1 Normalize, UTS #10.

If specified, strings are normalized before preparation of sort keys
(the normalization is executed after preprocess).

A form name C<Unicode::Normalize::normalize()> accepts will be applied
as C<$normalization_form>.
Acceptable names include C<'NFD'>, C<'NFC'>, C<'NFKD'>, and C<'NFKC'>.
See C<Unicode::Normalize::normalize()> for detail.
If omitted, C<'NFD'> is used.

C<normalization> is performed after C<preprocess> (if defined).

Furthermore, special values, C<undef> and C<"prenormalized">, can be used,
though they are not concerned with C<Unicode::Normalize::normalize()>.

If C<undef> (not a string C<"undef">) is passed explicitly
as the value for this key,
any normalization is not carried out (this may make tailoring easier
if any normalization is not desired). Under C<(normalization =E<gt> undef)>,
only contiguous contractions are resolved;
e.g. even if C<A-ring> (and C<A-ring-cedilla>) is ordered after C<Z>,
C<A-cedilla-ring> would be primary equal to C<A>.
In this point,
C<(normalization =E<gt> undef, preprocess =E<gt> sub { NFD(shift) })>
B<is not> equivalent to C<(normalization =E<gt> 'NFD')>.

In the case of C<(normalization =E<gt> "prenormalized")>,
any normalization is not performed, but
discontiguous contractions with combining characters are performed.
Therefore
C<(normalization =E<gt> 'prenormalized', preprocess =E<gt> sub { NFD(shift) })>
B<is> equivalent to C<(normalization =E<gt> 'NFD')>.
If source strings are finely prenormalized,
C<(normalization =E<gt> 'prenormalized')> may save time for normalization.

Except C<(normalization =E<gt> undef)>,
B<Unicode::Normalize> is required (see also B<CAVEAT>).

=item overrideCJK

-- see 7.1 Derived Collation Elements, UTS #10.

By default, CJK unified ideographs are ordered in Unicode codepoint
order, but those in the CJK Unified Ideographs block are less than
those in the CJK Unified Ideographs Extension A etc.

    In the CJK Unified Ideographs block:
    U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
    U+4E00..U+9FBB if UCA_Version is 14 or 16.
    U+4E00..U+9FC3 if UCA_Version is 18.
    U+4E00..U+9FCB if UCA_Version is 20 or 22.
    U+4E00..U+9FCC if UCA_Version is 24 or later.

    In the CJK Unified Ideographs Extension blocks:
    Ext.A (U+3400..U+4DB5) and Ext.B (U+20000..U+2A6D6) in any UCA_Version.
    Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or later.
    Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or later.

Through C<overrideCJK>, ordering of CJK unified ideographs (including
extensions) can be overridden.

ex. CJK unified ideographs in the JIS code point order.

  overrideCJK => sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },

The return value may be an arrayref of 1st to 4th weights as shown
above. The return value may be an integer as the primary weight
as shown below.  If C<undef> is returned, the default derived
collation element will be used.

  overrideCJK => sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      return $n;                 # return the primary weight
  },

The return value may be a list containing zero or more of
an arrayref, an integer, or C<undef>.

ex. ignores all CJK unified ideographs.

  overrideCJK => sub {()}, # CODEREF returning empty list

   # where ->eq("Pe\x{4E00}rl", "Perl") is true
   # as U+4E00 is a CJK unified ideograph and to be ignorable.

If a false value (including C<undef>) is passed, C<overrideCJK>
has no effect.
C<$Collator-E<gt>change(overrideCJK =E<gt> 0)> resets the old one.

But assignment of weight for CJK unified ideographs
in C<table> or C<entry> is still valid.
If C<undef> is passed explicitly as the value for this key,
weights for CJK unified ideographs are treated as undefined.
However when C<UCA_Version> E<gt> 8, C<(overrideCJK =E<gt> undef)>
has no special meaning.

B<Note:> In addition to them, 12 CJK compatibility ideographs (C<U+FA0E>,
C<U+FA0F>, C<U+FA11>, C<U+FA13>, C<U+FA14>, C<U+FA1F>, C<U+FA21>, C<U+FA23>,
C<U+FA24>, C<U+FA27>, C<U+FA28>, C<U+FA29>) are also treated as CJK unified
ideographs. But they can't be overridden via C<overrideCJK> when you use
DUCET, as the table includes weights for them. C<table> or C<entry> has
priority over C<overrideCJK>.

=item overrideHangul

-- see 7.1 Derived Collation Elements, UTS #10.

By default, Hangul syllables are decomposed into Hangul Jamo,
even if C<(normalization =E<gt> undef)>.
But the mapping of Hangul syllables may be overridden.

This parameter works like C<overrideCJK>, so see there for examples.

If you want to override the mapping of Hangul syllables,
NFD and NFKD are not appropriate, since NFD and NFKD will decompose
Hangul syllables before overriding. FCD may decompose Hangul syllables
as the case may be.

If a false value (but not C<undef>) is passed, C<overrideHangul>
has no effect.
C<$Collator-E<gt>change(overrideHangul =E<gt> 0)> resets the old one.

If C<undef> is passed explicitly as the value for this key,
weight for Hangul syllables is treated as undefined
without decomposition into Hangul Jamo.
But definition of weight for Hangul syllables
in C<table> or C<entry> is still valid.

=item overrideOut

-- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.

Perl seems to allow out-of-range values (greater than 0x10FFFF).
By default, out-of-range values are replaced with C<U+FFFD>
(REPLACEMENT CHARACTER) when C<UCA_Version> E<gt>= 22,
or ignored when C<UCA_Version> E<lt>= 20.

When C<UCA_Version> E<gt>= 22, the weights of out-of-range values
can be overridden. Though C<table> or C<entry> are available for them,
out-of-range values are too many.

C<overrideOut> can perform it algorithmically.
This parameter works like C<overrideCJK>, so see there for examples.

ex. ignores all out-of-range values.

  overrideOut => sub {()}, # CODEREF returning empty list

If a false value (including C<undef>) is passed, C<overrideOut>
has no effect.
C<$Collator-E<gt>change(overrideOut =E<gt> 0)> resets the old one.

B<NOTE ABOUT U+FFFD:>

UCA recommends that out-of-range values should not be ignored for security
reasons. Say, C<"pe\x{110000}rl"> should not be equal to C<"perl">.
However, C<U+FFFD> is wrongly mapped to a variable collation element
in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be
ignored when C<variable> isn't C<Non-ignorable>.

The mapping of C<U+FFFD> is corrected in Unicode 6.3.0.
see L<http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights>
(7.1.4 Trailing Weights). Such a correction is reproduced by this.

  overrideOut => sub { 0xFFFD }, # CODEREF returning a very large integer

This workaround is unnecessary since Unicode 6.3.0.

=item preprocess

-- see 5.4 Preprocessing, UTS #10.

If specified, the coderef is used to preprocess each string
before the formation of sort keys.

ex. dropping English articles, such as "a" or "the".
Then, "the pen" is before "a pencil".

     preprocess => sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           return $str;
        },

C<preprocess> is performed before C<normalization> (if defined).

ex. decoding strings in a legacy encoding such as shift-jis:

    $sjis_collator = Unicode::Collate->new(
        preprocess => \&your_shiftjis_to_unicode_decoder,
    );
    @result = $sjis_collator->sort(@shiftjis_strings);

B<Note:> Strings returned from the coderef will be interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.

=item rearrange

-- see 3.5 Rearrangement, UTS #10.

Characters that are not coded in logical order and to be rearranged.
If C<UCA_Version> is equal to or less than 11, default is:

    rearrange => [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],

If you want to disallow any rearrangement, pass C<undef> or C<[]>
(a reference to empty list) as the value for this key.

If C<UCA_Version> is equal to or greater than 14, default is C<[]>
(i.e. no rearrangement).

B<According to the version 9 of UCA, this parameter shall not be used;
but it is not warned at present.>

=item rewrite

If specified, the coderef is used to rewrite lines in C<table> or C<entry>.
The coderef will get each line, and then should return a rewritten line
according to the UCA file format.
If the coderef returns an empty line, the line will be skipped.

e.g. any primary ignorable characters into tertiary ignorable:

    rewrite => sub {
        my $line = shift;
        $line =~ s/\[\.0000\..{4}\..{4}\./[.0000.0000.0000./g;
        return $line;
    },

This example shows rewriting weights. C<rewrite> is allowed to
affect code points, weights, and the name.

B<NOTE>: C<table> is available to use another table file;
preparing a modified table once would be more efficient than
rewriting lines on reading an unmodified table every time.

=item suppress

-- see suppress contractions in 5.14.11 Special-Purpose Commands,
UTS #35 (LDML).

Contractions beginning with the specified characters are suppressed,
even if those contractions are defined in C<table>.

An example for Russian and some languages using the Cyrillic script:

    suppress => [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],

where 0x0400 stands for C<U+0400>, CYRILLIC CAPITAL LETTER IE WITH GRAVE.

B<NOTE>: Contractions via C<entry> are not be suppressed.

=item table

-- see 3.6 Default Unicode Collation Element Table, UTS #10.

You can use another collation element table if desired.

The table file should locate in the F<Unicode/Collate> directory
on C<@INC>. Say, if the filename is F<Foo.txt>,
the table file is searched as F<Unicode/Collate/Foo.txt> in C<@INC>.

By default, F<allkeys.txt> (as the filename of DUCET) is used.
If you will prepare your own table file, any name other than F<allkeys.txt>
may be better to avoid namespace conflict.

B<NOTE>: When XSUB is used, the DUCET is compiled on building this
module, and it may save time at the run time.
Explicit saying C<(table =E<gt> 'allkeys.txt')>, or using another table,
or using C<ignoreChar>, C<ignoreName>, C<undefChar>, C<undefName> or
C<rewrite> will prevent this module from using the compiled DUCET.

If C<undef> is passed explicitly as the value for this key,
no file is read (but you can define collation elements via C<entry>).

A typical way to define a collation element table
without any file of table:

   $onlyABC = Unicode::Collate->new(
       table => undef,
       entry => << 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );

If C<ignoreName> or C<undefName> is used, character names should be
specified as a comment (following C<#>) on each line.

=item undefChar

=item undefName

-- see 6.3.4 Reducing the Repertoire, UTS #10.

Undefines the collation element as if it were unassigned in the C<table>.
This reduces the size of the table.
If an unassigned character appears in the string to be collated,
the sort key is made from its codepoint
as a single-character collation element,
as it is greater than any other assigned collation elements
(in the codepoint order among the unassigned characters).
But, it'd be better to ignore characters
unfamiliar to you and maybe never used.

Through C<undefChar>, any character matching C<qr/$undefChar/>
will be undefined. Through C<undefName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$undefName/>
will be undefined.

ex. Collation weights for beyond-BMP characters are not stored in object:

    undefChar => qr/[^\0-\x{fffd}]/,

=item upper_before_lower

-- see 6.6 Case Comparisons, UTS #10.

By default, lowercase is before uppercase.
If the parameter is made true, this is reversed.

B<NOTE>: This parameter simplemindedly assumes that any lowercase/uppercase
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which differs from this requirement,
this parameter doesn't work validly.

=item variable

-- see 3.6.2 Variable Weighting, UTS #10.

This key allows for variable weighting of variable collation elements,
which are marked with an ASTERISK in the table
(NOTE: Many punctuation marks and symbols are variable in F<allkeys.txt>).

   variable => 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

These names are case-insensitive.
By default (if specification is omitted), 'shifted' is adopted.

   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-Ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.

=back

=head2 Methods for Collation

=over 4

=item C<@sorted = $Collator-E<gt>sort(@not_sorted)>

Sorts a list of strings.

=item C<$result = $Collator-E<gt>cmp($a, $b)>

Returns 1 (when C<$a> is greater than C<$b>)
or 0 (when C<$a> is equal to C<$b>)
or -1 (when C<$a> is less than C<$b>).

=item C<$result = $Collator-E<gt>eq($a, $b)>

=item C<$result = $Collator-E<gt>ne($a, $b)>

=item C<$result = $Collator-E<gt>lt($a, $b)>

=item C<$result = $Collator-E<gt>le($a, $b)>

=item C<$result = $Collator-E<gt>gt($a, $b)>

=item C<$result = $Collator-E<gt>ge($a, $b)>

They works like the same name operators as theirs.

   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is less than $b.
   le : whether $a is less than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.

=item C<$sortKey = $Collator-E<gt>getSortKey($string)>

-- see 4.3 Form Sort Key, UTS #10.

Returns a sort key.

You compare the sort keys using a binary comparison
and get the result of the comparison of the strings using UCA.

   $Collator->getSortKey($a) cmp $Collator->getSortKey($b)

      is equivalent to

   $Collator->cmp($a, $b)

=item C<$sortKeyForm = $Collator-E<gt>viewSortKey($string)>

Converts a sorting key into its representation form.
If C<UCA_Version> is 8, the output is slightly different.

   use Unicode::Collate;
   my $c = Unicode::Collate->new();
   print $c->viewSortKey("Perl"),"\n";

   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4

=back

=head2 Methods for Searching

The C<match>, C<gmatch>, C<subst>, C<gsubst> methods work
like C<m//>, C<m//g>, C<s///>, C<s///g>, respectively,
but they are not aware of any pattern, but only a literal substring.

B<DISCLAIMER:> If C<preprocess> or C<normalization> parameter is true
for C<$Collator>, calling these methods (C<index>, C<match>, C<gmatch>,
C<subst>, C<gsubst>) is croaked, as the position and the length might
differ from those on the specified string.

C<rearrange> and C<hangul_terminator> parameters are neglected.
C<katakana_before_hiragana> and C<upper_before_lower> don't affect
matching and searching, as it doesn't matter whether greater or less.

=over 4

=item C<$position = $Collator-E<gt>index($string, $substring[, $position])>

=item C<($position, $length) = $Collator-E<gt>index($string, $substring[, $position])>

If C<$substring> matches a part of C<$string>, returns
the position of the first occurrence of the matching part in scalar context;
in list context, returns a two-element list of
the position and the length of the matching part.

If C<$substring> does not match any part of C<$string>,
returns C<-1> in scalar context and
an empty list in list context.

e.g. when the content of C<$str> is C<"Ich mu>E<szlig>C< studieren Perl.">,
you say the following where C<$sub> is C<"M>E<uuml>C<SS">,

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
                                     # (normalization => undef) is REQUIRED.
  my $match;
  if (my($pos,$len) = $Collator->index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }

and get C<"mu>E<szlig>C<"> in C<$match>, since C<"mu>E<szlig>C<">
is primary equal to C<"M>E<uuml>C<SS">.

=item C<$match_ref = $Collator-E<gt>match($string, $substring)>

=item C<($match)   = $Collator-E<gt>match($string, $substring)>

If C<$substring> matches a part of C<$string>, in scalar context, returns
B<a reference to> the first occurrence of the matching part
(C<$match_ref> is always true if matches,
since every reference is B<true>);
in list context, returns the first occurrence of the matching part.

If C<$substring> does not match any part of C<$string>,
returns C<undef> in scalar context and
an empty list in list context.

e.g.

    if ($match_ref = $Collator->match($str, $sub)) { # scalar context
	print "matches [$$match_ref].\n";
    } else {
	print "doesn't match.\n";
    }

     or

    if (($match) = $Collator->match($str, $sub)) { # list context
	print "matches [$match].\n";
    } else {
	print "doesn't match.\n";
    }

=item C<@match = $Collator-E<gt>gmatch($string, $substring)>

If C<$substring> matches a part of C<$string>, returns
all the matching parts (or matching count in scalar context).

If C<$substring> does not match any part of C<$string>,
returns an empty list.

=item C<$count = $Collator-E<gt>subst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
the first occurrence of the matching part is replaced by C<$replacement>
(C<$string> is modified) and C<$count> (always equals to C<1>) is returned.

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/e>).

=item C<$count = $Collator-E<gt>gsubst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
all the occurrences of the matching part are replaced by C<$replacement>
(C<$string> is modified) and C<$count> is returned.

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/eg>).

e.g.

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
                                     # (normalization => undef) is REQUIRED.
  my $str = "Camel donkey zebra came\x{301}l CAMEL horse cam\0e\0l...";
  $Collator->gsubst($str, "camel", sub { "<b>$_[0]</b>" });

  # now $str is "<b>Camel</b> donkey zebra <b>came\x{301}l</b> <b>CAMEL</b> horse <b>cam\0e\0l</b>...";
  # i.e., all the camels are made bold-faced.

   Examples: levels and ignore_level2 - what does camel match?
  ---------------------------------------------------------------------------
   level  ignore_level2  |  camel  Camel  came\x{301}l  c-a-m-e-l  cam\0e\0l
  -----------------------|---------------------------------------------------
     1        false      |   yes    yes      yes          yes        yes
     2        false      |   yes    yes      no           yes        yes
     3        false      |   yes    no       no           yes        yes
     4        false      |   yes    no       no           no         yes
  -----------------------|---------------------------------------------------
     1        true       |   yes    yes      yes          yes        yes
     2        true       |   yes    yes      yes          yes        yes
     3        true       |   yes    no       yes          yes        yes
     4        true       |   yes    no       yes          no         yes
  ---------------------------------------------------------------------------
   note: if variable => non-ignorable, camel doesn't match c-a-m-e-l
         at any level.

=back

=head2 Other Methods

=over 4

=item C<%old_tailoring = $Collator-E<gt>change(%new_tailoring)>

=item C<$modified_collator = $Collator-E<gt>change(%new_tailoring)>

Changes the value of specified keys and returns the changed part.

    $Collator = Unicode::Collate->new(level => 4);

    $Collator->eq("perl", "PERL"); # false

    %old = $Collator->change(level => 2); # returns (level => 4).

    $Collator->eq("perl", "PERL"); # true

    $Collator->change(%old); # returns (level => 2).

    $Collator->eq("perl", "PERL"); # false

Not all C<(key,value)>s are allowed to be changed.
See also C<@Unicode::Collate::ChangeOK> and C<@Unicode::Collate::ChangeNG>.

In the scalar context, returns the modified collator
(but it is B<not> a clone from the original).

    $Collator->change(level => 2)->eq("perl", "PERL"); # true

    $Collator->eq("perl", "PERL"); # true; now max level is 2nd.

    $Collator->change(level => 4)->eq("perl", "PERL"); # false

=item C<$version = $Collator-E<gt>version()>

Returns the version number (a string) of the Unicode Standard
which the C<table> file used by the collator object is based on.
If the table does not include a version line (starting with C<@version>),
returns C<"unknown">.

=item C<UCA_Version()>

Returns the revision number of UTS #10 this module consults,
that should correspond with the DUCET incorporated.

=item C<Base_Unicode_Version()>

Returns the version number of UTS #10 this module consults,
that should correspond with the DUCET incorporated.

=back

=head1 EXPORT

No method will be exported.

=head1 INSTALL

Though this module can be used without any C<table> file,
to use this module easily, it is recommended to install a table file
in the UCA format, by copying it under the directory
<a place in @INC>/Unicode/Collate.

The most preferable one is "The Default Unicode Collation Element Table"
(aka DUCET), available from the Unicode Consortium's website:

   http://www.unicode.org/Public/UCA/

   http://www.unicode.org/Public/UCA/latest/allkeys.txt (latest version)

If DUCET is not installed, it is recommended to copy the file
from http://www.unicode.org/Public/UCA/latest/allkeys.txt
to <a place in @INC>/Unicode/Collate/allkeys.txt
manually.

=head1 CAVEATS

=over 4

=item Normalization

Use of the C<normalization> parameter requires the B<Unicode::Normalize>
module (see L<Unicode::Normalize>).

If you need not it (say, in the case when you need not
handle any combining characters),
assign C<(normalization =E<gt> undef)> explicitly.

-- see 6.5 Avoiding Normalization, UTS #10.

=item Conformance Test

The Conformance Test for the UCA is available
under L<http://www.unicode.org/Public/UCA/>.

For F<CollationTest_SHIFTED.txt>,
a collator via C<Unicode::Collate-E<gt>new( )> should be used;
for F<CollationTest_NON_IGNORABLE.txt>, a collator via
C<Unicode::Collate-E<gt>new(variable =E<gt> "non-ignorable", level =E<gt> 3)>.

If C<UCA_Version> is 26 or later, the C<identical> level is preferred;
C<Unicode::Collate-E<gt>new(identical =E<gt> 1)> and
C<Unicode::Collate-E<gt>new(identical =E<gt> 1,>
C<variable =E<gt> "non-ignorable", level =E<gt> 3)> should be used.

B<Unicode::Normalize is required to try The Conformance Test.>

=back

=head1 AUTHOR, COPYRIGHT AND LICENSE

The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki,
<SADAHIRO@cpan.org>. This module is Copyright(C) 2001-2013,
SADAHIRO Tomoyuki. Japan. All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

The file Unicode/Collate/allkeys.txt was copied verbatim
from L<http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt>.
For this file, Copyright (c) 2001-2012 Unicode, Inc.
Distributed under the Terms of Use in L<http://www.unicode.org/copyright.html>.

=head1 SEE ALSO

=over 4

=item Unicode Collation Algorithm - UTS #10

L<http://www.unicode.org/reports/tr10/>

=item The Default Unicode Collation Element Table (DUCET)

L<http://www.unicode.org/Public/UCA/latest/allkeys.txt>

=item The conformance test for the UCA

L<http://www.unicode.org/Public/UCA/latest/CollationTest.html>

L<http://www.unicode.org/Public/UCA/latest/CollationTest.zip>

=item Hangul Syllable Type

L<http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt>

=item Unicode Normalization Forms - UAX #15

L<http://www.unicode.org/reports/tr15/>

=item Unicode Locale Data Markup Language (LDML) - UTS #35

L<http://www.unicode.org/reports/tr35/>

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package Unicode::Normalize;

BEGIN {
    unless ('A' eq pack('U', 0x41)) {
	die "Unicode::Normalize cannot stringify a Unicode code point\n";
    }
    unless (0x41 == unpack('U', 'A')) {
	die "Unicode::Normalize cannot get Unicode code point\n";
    }
}

use 5.006;
use strict;
use warnings;
use Carp;

no warnings 'utf8';

our $VERSION = '1.17';
our $PACKAGE = __PACKAGE__;

our @EXPORT = qw( NFC NFD NFKC NFKD );
our @EXPORT_OK = qw(
    normalize decompose reorder compose
    checkNFD checkNFKD checkNFC checkNFKC check
    getCanon getCompat getComposite getCombinClass
    isExclusion isSingleton isNonStDecomp isComp2nd isComp_Ex
    isNFD_NO isNFC_NO isNFC_MAYBE isNFKD_NO isNFKC_NO isNFKC_MAYBE
    FCD checkFCD FCC checkFCC composeContiguous splitOnLastStarter
    normalize_partial NFC_partial NFD_partial NFKC_partial NFKD_partial
);
our %EXPORT_TAGS = (
    all       => [ @EXPORT, @EXPORT_OK ],
    normalize => [ @EXPORT, qw/normalize decompose reorder compose/ ],
    check     => [ qw/checkNFD checkNFKD checkNFC checkNFKC check/ ],
    fast      => [ qw/FCD checkFCD FCC checkFCC composeContiguous/ ],
);

##
## utilities for tests
##

sub pack_U {
    return pack('U*', @_);
}

sub unpack_U {
    return unpack('U*', shift(@_).pack('U*'));
}

require Exporter;

##### The above part is common to XS and PP #####

our @ISA = qw(Exporter DynaLoader);
require DynaLoader;
bootstrap Unicode::Normalize $VERSION;

##### The below part is common to XS and PP #####

##
## normalize
##

sub FCD ($) {
    my $str = shift;
    return checkFCD($str) ? $str : NFD($str);
}

our %formNorm = (
    NFC  => \&NFC,	C  => \&NFC,
    NFD  => \&NFD,	D  => \&NFD,
    NFKC => \&NFKC,	KC => \&NFKC,
    NFKD => \&NFKD,	KD => \&NFKD,
    FCD  => \&FCD,	FCC => \&FCC,
);

sub normalize($$)
{
    my $form = shift;
    my $str = shift;
    if (exists $formNorm{$form}) {
	return $formNorm{$form}->($str);
    }
    croak($PACKAGE."::normalize: invalid form name: $form");
}

##
## partial
##

sub normalize_partial ($$) {
    if (exists $formNorm{$_[0]}) {
	my $n = normalize($_[0], $_[1]);
	my($p, $u) = splitOnLastStarter($n);
	$_[1] = $u;
	return $p;
    }
    croak($PACKAGE."::normalize_partial: invalid form name: $_[0]");
}

sub NFD_partial ($) { return normalize_partial('NFD', $_[0]) }
sub NFC_partial ($) { return normalize_partial('NFC', $_[0]) }
sub NFKD_partial($) { return normalize_partial('NFKD',$_[0]) }
sub NFKC_partial($) { return normalize_partial('NFKC',$_[0]) }

##
## check
##

our %formCheck = (
    NFC  => \&checkNFC, 	C  => \&checkNFC,
    NFD  => \&checkNFD, 	D  => \&checkNFD,
    NFKC => \&checkNFKC,	KC => \&checkNFKC,
    NFKD => \&checkNFKD,	KD => \&checkNFKD,
    FCD  => \&checkFCD, 	FCC => \&checkFCC,
);

sub check($$)
{
    my $form = shift;
    my $str = shift;
    if (exists $formCheck{$form}) {
	return $formCheck{$form}->($str);
    }
    croak($PACKAGE."::check: invalid form name: $form");
}

1;
__END__

=head1 NAME

Unicode::Normalize - Unicode Normalization Forms

=head1 SYNOPSIS

(1) using function names exported by default:

  use Unicode::Normalize;

  $NFD_string  = NFD($string);  # Normalization Form D
  $NFC_string  = NFC($string);  # Normalization Form C
  $NFKD_string = NFKD($string); # Normalization Form KD
  $NFKC_string = NFKC($string); # Normalization Form KC

(2) using function names exported on request:

  use Unicode::Normalize 'normalize';

  $NFD_string  = normalize('D',  $string);  # Normalization Form D
  $NFC_string  = normalize('C',  $string);  # Normalization Form C
  $NFKD_string = normalize('KD', $string);  # Normalization Form KD
  $NFKC_string = normalize('KC', $string);  # Normalization Form KC

=head1 DESCRIPTION

Parameters:

C<$string> is used as a string under character semantics (see F<perlunicode>).

C<$code_point> should be an unsigned integer representing a Unicode code point.

Note: Between XSUB and pure Perl, there is an incompatibility
about the interpretation of C<$code_point> as a decimal number.
XSUB converts C<$code_point> to an unsigned integer, but pure Perl does not.
Do not use a floating point nor a negative sign in C<$code_point>.

=head2 Normalization Forms

=over 4

=item C<$NFD_string = NFD($string)>

It returns the Normalization Form D (formed by canonical decomposition).

=item C<$NFC_string = NFC($string)>

It returns the Normalization Form C (formed by canonical decomposition
followed by canonical composition).

=item C<$NFKD_string = NFKD($string)>

It returns the Normalization Form KD (formed by compatibility decomposition).

=item C<$NFKC_string = NFKC($string)>

It returns the Normalization Form KC (formed by compatibility decomposition
followed by B<canonical> composition).

=item C<$FCD_string = FCD($string)>

If the given string is in FCD ("Fast C or D" form; cf. UTN #5),
it returns the string without modification; otherwise it returns an FCD string.

Note: FCD is not always unique, then plural forms may be equivalent
each other. C<FCD()> will return one of these equivalent forms.

=item C<$FCC_string = FCC($string)>

It returns the FCC form ("Fast C Contiguous"; cf. UTN #5).

Note: FCC is unique, as well as four normalization forms (NF*).

=item C<$normalized_string = normalize($form_name, $string)>

It returns the normalization form of C<$form_name>.

As C<$form_name>, one of the following names must be given.

  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for "Fast C or D" Form  (UTN #5)
  'FCC'          for "Fast C Contiguous" (UTN #5)

=back

=head2 Decomposition and Composition

=over 4

=item C<$decomposed_string = decompose($string [, $useCompatMapping])>

It returns the concatenation of the decomposition of each character
in the string.

If the second parameter (a boolean) is omitted or false,
the decomposition is canonical decomposition;
if the second parameter (a boolean) is true,
the decomposition is compatibility decomposition.

The string returned is not always in NFD/NFKD. Reordering may be required.

    $NFD_string  = reorder(decompose($string));       # eq. to NFD()
    $NFKD_string = reorder(decompose($string, TRUE)); # eq. to NFKD()

=item C<$reordered_string = reorder($string)>

It returns the result of reordering the combining characters
according to Canonical Ordering Behavior.

For example, when you have a list of NFD/NFKD strings,
you can get the concatenated NFD/NFKD string from them, by saying

    $concat_NFD  = reorder(join '', @NFD_strings);
    $concat_NFKD = reorder(join '', @NFKD_strings);

=item C<$composed_string = compose($string)>

It returns the result of canonical composition
without applying any decomposition.

For example, when you have a NFD/NFKD string,
you can get its NFC/NFKC string, by saying

    $NFC_string  = compose($NFD_string);
    $NFKC_string = compose($NFKD_string);

=item C<($processed, $unprocessed) = splitOnLastStarter($normalized)>

It returns two strings: the first one, C<$processed>, is a part
before the last starter, and the second one, C<$unprocessed> is
another part after the first part. A starter is a character having
a combining class of zero (see UAX #15).

Note that C<$processed> may be empty (when C<$normalized> contains no
starter or starts with the last starter), and then C<$unprocessed>
should be equal to the entire C<$normalized>.

When you have a C<$normalized> string and an C<$unnormalized> string
following it, a simple concatenation is wrong:

    $concat = $normalized . normalize($form, $unnormalized); # wrong!

Instead of it, do like this:

    ($processed, $unprocessed) = splitOnLastStarter($normalized);
     $concat = $processed . normalize($form, $unprocessed.$unnormalized);

C<splitOnLastStarter()> should be called with a pre-normalized parameter
C<$normalized>, that is in the same form as C<$form> you want.

If you have an array of C<@string> that should be concatenated and then
normalized, you can do like this:

    my $result = "";
    my $unproc = "";
    foreach my $str (@string) {
        $unproc .= $str;
        my $n = normalize($form, $unproc);
        my($p, $u) = splitOnLastStarter($n);
        $result .= $p;
        $unproc  = $u;
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))

=item C<$processed = normalize_partial($form, $unprocessed)>

A wrapper for the combination of C<normalize()> and C<splitOnLastStarter()>.
Note that C<$unprocessed> will be modified as a side-effect.

If you have an array of C<@string> that should be concatenated and then
normalized, you can do like this:

    my $result = "";
    my $unproc = "";
    foreach my $str (@string) {
        $unproc .= $str;
        $result .= normalize_partial($form, $unproc);
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))

=item C<$processed = NFD_partial($unprocessed)>

It does like C<normalize_partial('NFD', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFC_partial($unprocessed)>

It does like C<normalize_partial('NFC', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFKD_partial($unprocessed)>

It does like C<normalize_partial('NFKD', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=item C<$processed = NFKC_partial($unprocessed)>

It does like C<normalize_partial('NFKC', $unprocessed)>.
Note that C<$unprocessed> will be modified as a side-effect.

=back

=head2 Quick Check

(see Annex 8, UAX #15; and F<DerivedNormalizationProps.txt>)

The following functions check whether the string is in that normalization form.

The result returned will be one of the following:

    YES     The string is in that normalization form.
    NO      The string is not in that normalization form.
    MAYBE   Dubious. Maybe yes, maybe no.

=over 4

=item C<$result = checkNFD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkNFC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

=item C<$result = checkNFKD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkNFKC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

=item C<$result = checkFCD($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>.

=item C<$result = checkFCC($string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

Note: If a string is not in FCD, it must not be in FCC.
So C<checkFCC($not_FCD_string)> should return C<NO>.

=item C<$result = check($form_name, $string)>

It returns true (C<1>) if C<YES>; false (C<empty string>) if C<NO>;
C<undef> if C<MAYBE>.

As C<$form_name>, one of the following names must be given.

  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for "Fast C or D" Form  (UTN #5)
  'FCC'          for "Fast C Contiguous" (UTN #5)

=back

B<Note>

In the cases of NFD, NFKD, and FCD, the answer must be
either C<YES> or C<NO>. The answer C<MAYBE> may be returned
in the cases of NFC, NFKC, and FCC.

A C<MAYBE> string should contain at least one combining character
or the like. For example, C<COMBINING ACUTE ACCENT> has
the MAYBE_NFC/MAYBE_NFKC property.

Both C<checkNFC("A\N{COMBINING ACUTE ACCENT}")>
and C<checkNFC("B\N{COMBINING ACUTE ACCENT}")> will return C<MAYBE>.
C<"A\N{COMBINING ACUTE ACCENT}"> is not in NFC
(its NFC is C<"\N{LATIN CAPITAL LETTER A WITH ACUTE}">),
while C<"B\N{COMBINING ACUTE ACCENT}"> is in NFC.

If you want to check exactly, compare the string with its NFC/NFKC/FCC.

    if ($string eq NFC($string)) {
        # $string is exactly normalized in NFC;
    } else {
        # $string is not normalized in NFC;
    }

    if ($string eq NFKC($string)) {
        # $string is exactly normalized in NFKC;
    } else {
        # $string is not normalized in NFKC;
    }

=head2 Character Data

These functions are interface of character data used internally.
If you want only to get Unicode normalization forms, you don't need
call them yourself.

=over 4

=item C<$canonical_decomposition = getCanon($code_point)>

If the character is canonically decomposable (including Hangul Syllables),
it returns the (full) canonical decomposition as a string.
Otherwise it returns C<undef>.

B<Note:> According to the Unicode standard, the canonical decomposition
of the character that is not canonically decomposable is same as
the character itself.

=item C<$compatibility_decomposition = getCompat($code_point)>

If the character is compatibility decomposable (including Hangul Syllables),
it returns the (full) compatibility decomposition as a string.
Otherwise it returns C<undef>.

B<Note:> According to the Unicode standard, the compatibility decomposition
of the character that is not compatibility decomposable is same as
the character itself.

=item C<$code_point_composite = getComposite($code_point_here, $code_point_next)>

If two characters here and next (as code points) are composable
(including Hangul Jamo/Syllables and Composition Exclusions),
it returns the code point of the composite.

If they are not composable, it returns C<undef>.

=item C<$combining_class = getCombinClass($code_point)>

It returns the combining class (as an integer) of the character.

=item C<$may_be_composed_with_prev_char = isComp2nd($code_point)>

It returns a boolean whether the character of the specified codepoint
may be composed with the previous one in a certain composition
(including Hangul Compositions, but excluding
Composition Exclusions and Non-Starter Decompositions).

=item C<$is_exclusion = isExclusion($code_point)>

It returns a boolean whether the code point is a composition exclusion.

=item C<$is_singleton = isSingleton($code_point)>

It returns a boolean whether the code point is a singleton

=item C<$is_non_starter_decomposition = isNonStDecomp($code_point)>

It returns a boolean whether the code point has Non-Starter Decomposition.

=item C<$is_Full_Composition_Exclusion = isComp_Ex($code_point)>

It returns a boolean of the derived property Comp_Ex
(Full_Composition_Exclusion). This property is generated from
Composition Exclusions + Singletons + Non-Starter Decompositions.

=item C<$NFD_is_NO = isNFD_NO($code_point)>

It returns a boolean of the derived property NFD_NO
(NFD_Quick_Check=No).

=item C<$NFC_is_NO = isNFC_NO($code_point)>

It returns a boolean of the derived property NFC_NO
(NFC_Quick_Check=No).

=item C<$NFC_is_MAYBE = isNFC_MAYBE($code_point)>

It returns a boolean of the derived property NFC_MAYBE
(NFC_Quick_Check=Maybe).

=item C<$NFKD_is_NO = isNFKD_NO($code_point)>

It returns a boolean of the derived property NFKD_NO
(NFKD_Quick_Check=No).

=item C<$NFKC_is_NO = isNFKC_NO($code_point)>

It returns a boolean of the derived property NFKC_NO
(NFKC_Quick_Check=No).

=item C<$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)>

It returns a boolean of the derived property NFKC_MAYBE
(NFKC_Quick_Check=Maybe).

=back

=head1 EXPORT

C<NFC>, C<NFD>, C<NFKC>, C<NFKD>: by default.

C<normalize> and other some functions: on request.

=head1 CAVEATS

=over 4

=item Perl's version vs. Unicode version

Since this module refers to perl core's Unicode database in the directory
F</lib/unicore> (or formerly F</lib/unicode>), the Unicode version of
normalization implemented by this module depends on your perl's version.

    perl's version     implemented Unicode version
       5.6.1              3.0.1
       5.7.2              3.1.0
       5.7.3              3.1.1 (normalization is same as 3.1.0)
       5.8.0              3.2.0
     5.8.1-5.8.3          4.0.0
     5.8.4-5.8.6          4.0.1 (normalization is same as 4.0.0)
     5.8.7-5.8.8          4.1.0
       5.10.0             5.0.0
    5.8.9, 5.10.1         5.1.0
       5.12.x             5.2.0
       5.14.x             6.0.0
       5.16.x             6.1.0
       5.18.x             6.2.0

=item Correction of decomposition mapping

In older Unicode versions, a small number of characters (all of which are
CJK compatibility ideographs as far as they have been found) may have
an erroneous decomposition mapping (see F<NormalizationCorrections.txt>).
Anyhow, this module will neither refer to F<NormalizationCorrections.txt>
nor provide any specific version of normalization. Therefore this module
running on an older perl with an older Unicode database may use
the erroneous decomposition mapping blindly conforming to the Unicode database.

=item Revised definition of canonical composition

In Unicode 4.1.0, the definition D2 of canonical composition (which
affects NFC and NFKC) has been changed (see Public Review Issue #29
and recent UAX #15). This module has used the newer definition
since the version 0.07 (Oct 31, 2001).
This module will not support the normalization according to the older
definition, even if the Unicode version implemented by perl is
lower than 4.1.0.

=back

=head1 AUTHOR

SADAHIRO Tomoyuki <SADAHIRO@cpan.org>

Copyright(C) 2001-2012, SADAHIRO Tomoyuki. Japan. All rights reserved.

This module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

=head1 SEE ALSO

=over 4

=item http://www.unicode.org/reports/tr15/

Unicode Normalization Forms - UAX #15

=item http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt

Composition Exclusion Table

=item http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt

Derived Normalization Properties

=item http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt

Normalization Corrections

=item http://www.unicode.org/review/pr-29.html

Public Review Issue #29: Normalization Issue

=item http://www.unicode.org/notes/tn5/

Canonical Equivalence in Applications - UTN #5

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package Unicode::Collate::Locale;

use strict;
use Carp;
use base qw(Unicode::Collate);

our $VERSION = '1.02';

my $PL_EXT  = '.pl';

my %LocaleFile = map { ($_, $_) } qw(
   af ar as az be bg bn ca cs cy da ee eo es et fa fi fil fo fr
   gu ha haw hi hr hu hy ig is ja kk kl kn ko kok ln lt lv
   mk ml mr mt nb nn nso om or pa pl ro ru sa se si sk sl sq
   sr sv ta te th tn to tr uk ur vi wae wo yo zh
);
   $LocaleFile{'default'} = '';
# aliases
   $LocaleFile{'bs'}      = 'hr';
   $LocaleFile{'bs_Cyrl'} = 'sr';
   $LocaleFile{'sr_Latn'} = 'hr';
# short file names
   $LocaleFile{'de__phonebook'}   = 'de_phone';
   $LocaleFile{'es__traditional'} = 'es_trad';
   $LocaleFile{'fi__phonebook'}   = 'fi_phone';
   $LocaleFile{'si__dictionary'}  = 'si_dict';
   $LocaleFile{'sv__reformed'}    = 'sv_refo';
   $LocaleFile{'zh__big5han'}     = 'zh_big5';
   $LocaleFile{'zh__gb2312han'}   = 'zh_gb';
   $LocaleFile{'zh__pinyin'}      = 'zh_pin';
   $LocaleFile{'zh__stroke'}      = 'zh_strk';
   $LocaleFile{'zh__zhuyin'}      = 'zh_zhu';

my %TypeAlias = qw(
    phone     phonebook
    phonebk   phonebook
    dict      dictionary
    reform    reformed
    trad      traditional
    big5      big5han
    gb2312    gb2312han
);

sub _locale {
    my $locale = shift;
    if ($locale) {
	$locale = lc $locale;
	$locale =~ tr/\-\ \./_/;
	$locale =~ s/_([0-9a-z]+)\z/$TypeAlias{$1} ?
				  "_$TypeAlias{$1}" : "_$1"/e;
	$LocaleFile{$locale} and return $locale;

	my @code = split /_/, $locale;
	my $lan = shift @code;
	my $scr = @code && length $code[0] == 4 ? ucfirst shift @code : '';
	my $reg = @code && length $code[0] <  4 ? uc      shift @code : '';
	my $var = @code                         ?         shift @code : '';

	my @list;
	push @list, (
	    "${lan}_${scr}_${reg}_$var",
	    "${lan}_${scr}__$var", # empty $scr should not be ${lan}__$var.
	    "${lan}_${reg}_$var",  # empty $reg may be ${lan}__$var.
	    "${lan}__$var",
	) if $var ne '';
	push @list, (
	    "${lan}_${scr}_${reg}",
	    "${lan}_${scr}",
	    "${lan}_${reg}",
	     ${lan},
	);
	for my $loc (@list) {
	    $LocaleFile{$loc} and return $loc;
	}
    }
    return 'default';
}

sub getlocale {
    return shift->{accepted_locale};
}

sub locale_version {
    return shift->{locale_version};
}

sub _fetchpl {
    my $accepted = shift;
    my $f = $LocaleFile{$accepted};
    return if !$f;
    $f .= $PL_EXT;

    # allow to search @INC
#   use File::Spec;
#   my $path = File::Spec->catfile('Unicode', 'Collate', 'Locale', $f);
    my $path = "Unicode/Collate/Locale/$f";
    my $h = do $path;
    croak "Unicode/Collate/Locale/$f can't be found" if !$h;
    return $h;
}

sub new {
    my $class = shift;
    my %hash = @_;
    $hash{accepted_locale} = _locale($hash{locale});

    if (exists $hash{table}) {
	croak "your table can't be used with Unicode::Collate::Locale";
    }

    my $href = _fetchpl($hash{accepted_locale});
    while (my($k,$v) = each %$href) {
	if (!exists $hash{$k}) {
	    $hash{$k} = $v;
	} elsif ($k eq 'entry') {
	    $hash{$k} = $v.$hash{$k};
	} else {
	    croak "$k is reserved by $hash{locale}, can't be overwritten";
	}
    }
    return $class->SUPER::new(%hash);
}

1;
__END__

MEMORANDA for developing

locale            based CLDR
----------------------------------------------------------------------------
af                22.1 = 1.8.1
ar                22.1 = 1.9.0
as                22.1 = 1.8.1
az                22.1 = 1.8.1 (type="standard")
be                22.1 = 1.9.0
bg                22.1 = 1.9.0
bn                22.1 = 2.0.1 (type="standard")
bs                22.1 = 1.9.0 (alias source="hr")
bs_Cyrl           22.1 = 22    (alias source="sr")
ca                22.1 = 1.8.1 (alt="proposed" type="standard")
cs                22.1 = 1.8.1 (type="standard")
cy                22.1 = 1.8.1
da                22.1 = 1.8.1 (type="standard") [mod aA to pass CLDR test]
de__phonebook     22.1 = 2.0   (type="phonebook")
ee                22.1 = 22
eo                22.1 = 1.8.1
es                22.1 = 1.9.0 (type="standard")
es__traditional   22.1 = 1.8.1 (type="traditional")
et                22.1 = 1.8.1
fa                22.1 = 1.8.1
fi                22.1 = 1.8.1 (type="standard" alt="proposed")
fi__phonebook     22.1 = 1.8.1 (type="phonebook")
fil               22.1 = 1.9.0 (type="standard") = 1.8.1
fo                22.1 = 1.8.1 (alt="proposed" type="standard")
fr                22.1 = 1.9.0 (fr_CA, backwards="on")
gu                22.1 = 1.9.0 (type="standard")
ha                22.1 = 1.9.0
haw               22.1 = 1.8.1
hi                22.1 = 1.9.0 (type="standard")
hr                22.1 = 1.9.0 (type="standard")
hu                22.1 = 1.8.1 (alt="proposed" type="standard")
hy                22.1 = 1.8.1
ig                22.1 = 1.8.1
is                22.1 = 1.8.1 (type="standard")
ja                22.1 = 1.8.1 (type="standard")
kk                22.1 = 1.9.0
kl                22.1 = 1.8.1 (type="standard")
kn                22.1 = 1.9.0 (type="standard")
ko                22.1 = 1.8.1 (type="standard")
kok               22.1 = 1.8.1
ln                22.1 = 2.0   (type="standard") = 1.8.1
lt                22.1 = 1.9.0
lv                22.1 = 1.9.0 (type="standard") = 1.8.1
mk                22.1 = 1.9.0
ml                22.1 = 1.9.0
mr                22.1 = 1.8.1
mt                22.1 = 1.9.0
nb                22.1 = 2.0   (type="standard")
nn                22.1 = 2.0   (type="standard")
nso               22.1 = 1.8.1
om                22.1 = 1.8.1
or                22.1 = 1.9.0
pa                22.1 = 1.8.1
pl                22.1 = 1.8.1
ro                22.1 = 1.9.0 (type="standard")
ru                22.1 = 1.9.0
sa                1.9.1 = 1.8.1 (type="standard" alt="proposed") [now /seed]
se                22.1 = 1.8.1 (type="standard")
si                22.1 = 1.9.0 (type="standard")
si__dictionary    22.1 = 1.9.0 (type="dictionary")
sk                22.1 = 1.9.0 (type="standard")
sl                22.1 = 1.8.1 (type="standard" alt="proposed")
sq                22.1 = 1.8.1 (alt="proposed" type="standard")
sr                22.1 = 1.9.0 (type="standard")
sr_Latn           22.1 = 1.8.1 (alias source="hr")
sv                22.1 = 1.9.0 (type="standard")
sv__reformed      22.1 = 1.8.1 (type="reformed")
ta                22.1 = 1.9.0
te                22.1 = 1.9.0
th                22.1 = 22
tn                22.1 = 1.8.1
to                22.1 = 22
tr                22.1 = 1.8.1 (type="standard")
uk                22.1 = 21
ur                22.1 = 1.9.0
vi                22.1 = 1.8.1
wae               22.1 = 2.0
wo                1.9.1 = 1.8.1 [now /seed]
yo                22.1 = 1.8.1
zh                22.1 = 1.8.1 (type="standard")
zh__big5han       22.1 = 1.8.1 (type="big5han")
zh__gb2312han     22.1 = 1.8.1 (type="gb2312han")
zh__pinyin        22.1 = 2.0   (type='pinyin' alt='short')
zh__stroke        22.1 = 1.9.1 (type='stroke' alt='short')
zh__zhuyin        22.1 = 22    (type='zhuyin' alt='short')
----------------------------------------------------------------------------

=head1 NAME

Unicode::Collate::Locale - Linguistic tailoring for DUCET via Unicode::Collate

=head1 SYNOPSIS

  use Unicode::Collate::Locale;

  #construct
  $Collator = Unicode::Collate::Locale->
      new(locale => $locale_name, %tailoring);

  #sort
  @sorted = $Collator->sort(@not_sorted);

  #compare
  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.

B<Note:> Strings in C<@not_sorted>, C<$a> and C<$b> are interpreted
according to Perl's Unicode support. See L<perlunicode>,
L<perluniintro>, L<perlunitut>, L<perlunifaq>, L<utf8>.
Otherwise you can use C<preprocess> (cf. C<Unicode::Collate>)
or should decode them before.

=head1 DESCRIPTION

This module provides linguistic tailoring for it
taking advantage of C<Unicode::Collate>.

=head2 Constructor

The C<new> method returns a collator object.

A parameter list for the constructor is a hash, which can include
a special key C<locale> and its value (case-insensitive) standing
for a Unicode base language code (two or three-letter).
For example, C<Unicode::Collate::Locale-E<gt>new(locale =E<gt> 'FR')>
returns a collator tailored for French.

C<$locale_name> may be suffixed with a Unicode script code (four-letter),
a Unicode region code, a Unicode language variant code. These codes are
case-insensitive, and separated with C<'_'> or C<'-'>.
E.g. C<en_US> for English in USA,
C<az_Cyrl> for Azerbaijani in the Cyrillic script,
C<es_ES_traditional> for Spanish in Spain (Traditional).

If C<$locale_name> is not available,
fallback is selected in the following order:

    1. language with a variant code
    2. language with a script code
    3. language with a region code
    4. language
    5. default

Tailoring tags provided by C<Unicode::Collate> are allowed as long as
they are not used for C<locale> support.  Esp. the C<table> tag
is always untailorable, since it is reserved for DUCET.

However C<entry> is allowed, even if it is used for C<locale> support,
to add or override mappings.

E.g. a collator for French, which ignores diacritics and case difference
(i.e. level 1), with reversed case ordering and no normalization.

    Unicode::Collate::Locale->new(
        level => 1,
        locale => 'fr',
        upper_before_lower => 1,
        normalization => undef
    )

Overriding a behavior already tailored by C<locale> is disallowed
if such a tailoring is passed to C<new()>.

    Unicode::Collate::Locale->new(
        locale => 'da',
        upper_before_lower => 0, # causes error as reserved by 'da'
    )

However C<change()> inherited from C<Unicode::Collate> allows
such a tailoring that is reserved by C<locale>. Examples:

    new(locale => 'ca')->change(backwards => undef)
    new(locale => 'da')->change(upper_before_lower => 0)
    new(locale => 'ja')->change(overrideCJK => undef)

=head2 Methods

C<Unicode::Collate::Locale> is a subclass of C<Unicode::Collate>
and methods other than C<new> are inherited from C<Unicode::Collate>.

Here is a list of additional methods:

=over 4

=item C<$Collator-E<gt>getlocale>

Returns a language code accepted and used actually on collation.
If linguistic tailoring is not provided for a language code you passed
(intensionally for some languages, or due to the incomplete implementation),
this method returns a string C<'default'> meaning no special tailoring.

=item C<$Collator-E<gt>locale_version>

(Since Unicode::Collate::Locale 0.87)
Returns the version number (perhaps C</\d\.\d\d/>) of the locale, as that
of F<Locale/*.pl>.

B<Note:> F<Locale/*.pl> that a collator uses should be identified by
a combination of return values from C<getlocale> and C<locale_version>.

=back

=head2 A list of tailorable locales

      locale name       description
    --------------------------------------------------------------
      af                Afrikaans
      ar                Arabic
      as                Assamese
      az                Azerbaijani (Azeri)
      be                Belarusian
      bg                Bulgarian
      bn                Bengali
      bs                Bosnian
      bs_Cyrl           Bosnian in Cyrillic (tailored as Serbian)
      ca                Catalan
      cs                Czech
      cy                Welsh
      da                Danish
      de__phonebook     German (umlaut as 'ae', 'oe', 'ue')
      ee                Ewe
      eo                Esperanto
      es                Spanish
      es__traditional   Spanish ('ch' and 'll' as a grapheme)
      et                Estonian
      fa                Persian
      fi                Finnish (v and w are primary equal)
      fi__phonebook     Finnish (v and w as separate characters)
      fil               Filipino
      fo                Faroese
      fr                French
      gu                Gujarati
      ha                Hausa
      haw               Hawaiian
      hi                Hindi
      hr                Croatian
      hu                Hungarian
      hy                Armenian
      ig                Igbo
      is                Icelandic
      ja                Japanese [1]
      kk                Kazakh
      kl                Kalaallisut
      kn                Kannada
      ko                Korean [2]
      kok               Konkani
      ln                Lingala
      lt                Lithuanian
      lv                Latvian
      mk                Macedonian
      ml                Malayalam
      mr                Marathi
      mt                Maltese
      nb                Norwegian Bokmal
      nn                Norwegian Nynorsk
      nso               Northern Sotho
      om                Oromo
      or                Oriya
      pa                Punjabi
      pl                Polish
      ro                Romanian
      ru                Russian
      sa                Sanskrit
      se                Northern Sami
      si                Sinhala
      si__dictionary    Sinhala (U+0DA5 = U+0DA2,0DCA,0DA4)
      sk                Slovak
      sl                Slovenian
      sq                Albanian
      sr                Serbian
      sr_Latn           Serbian in Latin (tailored as Croatian)
      sv                Swedish (v and w are primary equal)
      sv__reformed      Swedish (v and w as separate characters)
      ta                Tamil
      te                Telugu
      th                Thai
      tn                Tswana
      to                Tonga
      tr                Turkish
      uk                Ukrainian
      ur                Urdu
      vi                Vietnamese
      wae               Walser
      wo                Wolof
      yo                Yoruba
      zh                Chinese
      zh__big5han       Chinese (ideographs: big5 order)
      zh__gb2312han     Chinese (ideographs: GB-2312 order)
      zh__pinyin        Chinese (ideographs: pinyin order) [3]
      zh__stroke        Chinese (ideographs: stroke order) [3]
      zh__zhuyin        Chinese (ideographs: zhuyin order) [3]
    --------------------------------------------------------------

Locales according to the default UCA rules include
chr (Cherokee),
de (German),
en (English),
ga (Irish),
id (Indonesian),
it (Italian),
ka (Georgian),
ms (Malay),
nl (Dutch),
pt (Portuguese),
st (Southern Sotho),
sw (Swahili),
xh (Xhosa),
zu (Zulu).

B<Note>

[1] ja: Ideographs are sorted in JIS X 0208 order.
Fullwidth and halfwidth forms are identical to their regular form.
The difference between hiragana and katakana is at the 4th level,
the comparison also requires C<(variable =E<gt> 'Non-ignorable')>,
and then C<katakana_before_hiragana> has no effect.

[2] ko: Plenty of ideographs are sorted by their reading. Such
an ideograph is primary (level 1) equal to, and secondary (level 2)
greater than, the corresponding hangul syllable.

[3] zh__pinyin, zh__stroke and zh__zhuyin: implemented alt='short',
where a smaller number of ideographs are tailored.

Note: 'pinyin' is in latin, 'zhuyin' is in bopomofo.

=head1 INSTALL

Installation of C<Unicode::Collate::Locale> requires F<Collate/Locale.pm>,
F<Collate/Locale/*.pm>, F<Collate/CJK/*.pm> and F<Collate/allkeys.txt>.
On building, C<Unicode::Collate::Locale> doesn't require any of F<data/*.txt>,
F<gendata/*>, and F<mklocale>.
Tests for C<Unicode::Collate::Locale> are named F<t/loc_*.t>.

=head1 CAVEAT

=over 4

=item tailoring is not maximum

Even if a certain letter is tailored, its equivalent would not always
tailored as well as it. For example, even though W is tailored,
fullwidth W (C<U+FF37>), W with acute (C<U+1E82>), etc. are not
tailored. The result may depend on whether source strings are
normalized or not, and whether decomposed or composed.
Thus C<(normalization =E<gt> undef)> is less preferred.

=back

=head1 AUTHOR

The Unicode::Collate::Locale module for perl was written
by SADAHIRO Tomoyuki, <SADAHIRO@cpan.org>.
This module is Copyright(C) 2004-2013, SADAHIRO Tomoyuki. Japan.
All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

=over 4

=item Unicode Collation Algorithm - UTS #10

L<http://www.unicode.org/reports/tr10/>

=item The Default Unicode Collation Element Table (DUCET)

L<http://www.unicode.org/Public/UCA/latest/allkeys.txt>

=item Unicode Locale Data Markup Language (LDML) - UTS #35

L<http://www.unicode.org/reports/tr35/>

=item CLDR - Unicode Common Locale Data Repository

L<http://cldr.unicode.org/>

=item L<Unicode::Collate>

=item L<Unicode::Normalize>

=back

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_XLOCALE_H)) {
    eval 'sub _XLOCALE_H () {1;}' unless defined(&_XLOCALE_H);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
# IO::Poll.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Poll;

use strict;
use IO::Handle;
use Exporter ();
our(@ISA, @EXPORT_OK, @EXPORT, $VERSION);

@ISA = qw(Exporter);
$VERSION = "0.09";

@EXPORT = qw( POLLIN
	      POLLOUT
	      POLLERR
	      POLLHUP
	      POLLNVAL
	    );

@EXPORT_OK = qw(
 POLLPRI   
 POLLRDNORM
 POLLWRNORM
 POLLRDBAND
 POLLWRBAND
 POLLNORM  
	       );

# [0] maps fd's to requested masks
# [1] maps fd's to returned  masks
# [2] maps fd's to handles
sub new {
    my $class = shift;

    my $self = bless [{},{},{}], $class;

    $self;
}

sub mask {
    my $self = shift;
    my $io = shift;
    my $fd = fileno($io);
    return unless defined $fd;
    if (@_) {
	my $mask = shift;
	if($mask) {
	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
	  $self->[1]{$fd}      = 0;     # output mask
	  $self->[2]{$io}      = $io;   # remember handle
	} else {
          delete $self->[0]{$fd}{$io};
          unless(%{$self->[0]{$fd}}) {
            # We no longer have any handles for this FD
            delete $self->[1]{$fd};
            delete $self->[0]{$fd};
          }
          delete $self->[2]{$io};
	}
    }
    
    return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
	return $self->[0]{$fd}{$io};
}


sub poll {
    my($self,$timeout) = @_;

    $self->[1] = {};

    my($fd,$mask,$iom);
    my @poll = ();

    while(($fd,$iom) = each %{$self->[0]}) {
	$mask   = 0;
	$mask  |= $_ for values(%$iom);
	push(@poll,$fd => $mask);
    }

    my $ret = @poll ? _poll(defined($timeout) ? $timeout * 1000 : -1,@poll) : 0;

    return $ret
	unless $ret > 0;

    while(@poll) {
	my($fd,$got) = splice(@poll,0,2);
	$self->[1]{$fd} = $got if $got;
    }

    return $ret;  
}

sub events {
    my $self = shift;
    my $io = shift;
    my $fd = fileno($io);
    exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
	: 0;
}

sub remove {
    my $self = shift;
    my $io = shift;
    $self->mask($io,0);
}

sub handles {
    my $self = shift;
    return values %{$self->[2]} unless @_;

    my $events = shift || 0;
    my($fd,$ev,$io,$mask);
    my @handles = ();

    while(($fd,$ev) = each %{$self->[1]}) {
	while (($io,$mask) = each %{$self->[0]{$fd}}) {
	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
	}
    }
    return @handles;
}

1;

__END__

=head1 NAME

IO::Poll - Object interface to system poll call

=head1 SYNOPSIS

    use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);

    $poll = IO::Poll->new();

    $poll->mask($input_handle => POLLIN);
    $poll->mask($output_handle => POLLOUT);

    $poll->poll($timeout);

    $ev = $poll->events($input);

=head1 DESCRIPTION

C<IO::Poll> is a simple interface to the system level poll routine.

=head1 METHODS

=over 4

=item mask ( IO [, EVENT_MASK ] )

If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
list of file descriptors and the next call to poll will check for
any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
removed from the list of file descriptors.

If EVENT_MASK is not given then the return value will be the current
event mask value for IO.

=item poll ( [ TIMEOUT ] )

Call the system level poll routine. If TIMEOUT is not specified then the
call will block. Returns the number of handles which had events
happen, or -1 on error.

=item events ( IO )

Returns the event mask which represents the events that happened on IO
during the last call to C<poll>.

=item remove ( IO )

Remove IO from the list of file descriptors for the next poll.

=item handles( [ EVENT_MASK ] )

Returns a list of handles. If EVENT_MASK is not given then a list of all
handles known will be returned. If EVENT_MASK is given then a list
of handles will be returned which had one of the events specified by
EVENT_MASK happen during the last call ti C<poll>

=back

=head1 SEE ALSO

L<poll(2)>, L<IO::Handle>, L<IO::Select>

=head1 AUTHOR

Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perlbug@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # IO::Dir.pm
#
# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package IO::Dir;

use 5.006;

use strict;
use Carp;
use Symbol;
use Exporter;
use IO::File;
our(@ISA, $VERSION, @EXPORT_OK);
use Tie::Hash;
use File::stat;
use File::Spec;

@ISA = qw(Tie::Hash Exporter);
$VERSION = "1.10";
$VERSION = eval $VERSION;
@EXPORT_OK = qw(DIR_UNLINK);

sub DIR_UNLINK () { 1 }

sub new {
    @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
    my $class = shift;
    my $dh = gensym;
    if (@_) {
	IO::Dir::open($dh, $_[0])
	    or return undef;
    }
    bless $dh, $class;
}

sub DESTROY {
    my ($dh) = @_;
    local($., $@, $!, $^E, $?);
    no warnings 'io';
    closedir($dh);
}

sub open {
    @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
    my ($dh, $dirname) = @_;
    return undef
	unless opendir($dh, $dirname);
    # a dir name should always have a ":" in it; assume dirname is
    # in current directory
    $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
    ${*$dh}{io_dir_path} = $dirname;
    1;
}

sub close {
    @_ == 1 or croak 'usage: $dh->close()';
    my ($dh) = @_;
    closedir($dh);
}

sub read {
    @_ == 1 or croak 'usage: $dh->read()';
    my ($dh) = @_;
    readdir($dh);
}

sub seek {
    @_ == 2 or croak 'usage: $dh->seek(POS)';
    my ($dh,$pos) = @_;
    seekdir($dh,$pos);
}

sub tell {
    @_ == 1 or croak 'usage: $dh->tell()';
    my ($dh) = @_;
    telldir($dh);
}

sub rewind {
    @_ == 1 or croak 'usage: $dh->rewind()';
    my ($dh) = @_;
    rewinddir($dh);
}

sub TIEHASH {
    my($class,$dir,$options) = @_;

    my $dh = $class->new($dir)
	or return undef;

    $options ||= 0;

    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
    $dh;
}

sub FIRSTKEY {
    my($dh) = @_;
    $dh->rewind;
    scalar $dh->read;
}

sub NEXTKEY {
    my($dh) = @_;
    scalar $dh->read;
}

sub EXISTS {
    my($dh,$key) = @_;
    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
}

sub FETCH {
    my($dh,$key) = @_;
    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
}

sub STORE {
    my($dh,$key,$data) = @_;
    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
    unless(-e $file) {
	my $io = IO::File->new($file,O_CREAT | O_RDWR);
	$io->close if $io;
    }
    utime($atime,$mtime, $file);
}

sub DELETE {
    my($dh,$key) = @_;

    # Only unlink if unlink-ing is enabled
    return 0
	unless ${*$dh}{io_dir_unlink};

    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);

    -d $file
	? rmdir($file)
	: unlink($file);
}

1;

__END__

=head1 NAME 

IO::Dir - supply object methods for directory handles

=head1 SYNOPSIS

    use IO::Dir;
    $d = IO::Dir->new(".");
    if (defined $d) {
        while (defined($_ = $d->read)) { something($_); }
        $d->rewind;
        while (defined($_ = $d->read)) { something_else($_); }
        undef $d;
    }

    tie %dir, 'IO::Dir', ".";
    foreach (keys %dir) {
	print $_, " " , $dir{$_}->size,"\n";
    }

=head1 DESCRIPTION

The C<IO::Dir> package provides two interfaces to perl's directory reading
routines.

The first interface is an object approach. C<IO::Dir> provides an object
constructor and methods, which are just wrappers around perl's built in
directory reading routines.

=over 4

=item new ( [ DIRNAME ] )

C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
argument which,  if given, C<new> will pass to C<open>

=back

The following methods are wrappers for the directory related functions built
into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
for details of these functions.

=over 4

=item open ( DIRNAME )

=item read ()

=item seek ( POS )

=item tell ()

=item rewind ()

=item close ()

=back

C<IO::Dir> also provides an interface to reading directories via a tied
hash. The tied hash extends the interface beyond just the directory
reading routines by the use of C<lstat>, from the C<File::stat> package,
C<unlink>, C<rmdir> and C<utime>.

=over 4

=item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]

=back

The keys of the hash will be the names of the entries in the directory. 
Reading a value from the hash will be the result of calling
C<File::stat::lstat>.  Deleting an element from the hash will 
delete the corresponding file or subdirectory,
provided that C<DIR_UNLINK> is included in the C<OPTIONS>.

Assigning to an entry in the hash will cause the time stamps of the file
to be modified. If the file does not exist then it will be created. Assigning
a single integer to a hash element will cause both the access and 
modification times to be changed to that value. Alternatively a reference to
an array of two values can be passed. The first array element will be used to
set the access time and the second element will be used to set the modification
time.

=head1 SEE ALSO

L<File::stat>

=head1 AUTHOR

Graham Barr. Currently maintained by the Perl Porters.  Please report all
bugs to <perlbug@perl.org>.

=head1 COPYRIGHT

Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
package Compress::Raw::Bzip2;

use strict ;
use warnings ;

require 5.006 ;
require Exporter;
use Carp ;

use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, $AUTOLOAD);

$VERSION = '2.064';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@EXPORT = qw(
		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

    );

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};

}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Bzip2', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Bzip2 $XS_VERSION ; 
};

#sub Compress::Raw::Bzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}
#
#package Compress::Raw::Bunzip2 ;
#
#sub Compress::Raw::Bunzip2::new
#{
#    my $class = shift ;
#    my ($ptr, $status) = _new(@_);
#    return wantarray ? (undef, $status) : undef
#        unless $ptr ;
#    my $obj = bless [$ptr], $class ;
#    return wantarray ? ($obj, $status) : $obj;
#}

sub Compress::Raw::Bzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Bunzip2::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


package Compress::Raw::Bzip2;

1;

__END__


=head1 NAME

Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library

=head1 SYNOPSIS

    use Compress::Raw::Bzip2 ;

    my ($bz, $status) = new Compress::Raw::Bzip2 [OPTS]
        or die "Cannot create bzip2 object: $bzerno\n";
    
    $status = $bz->bzdeflate($input, $output);
    $status = $bz->bzflush($output);
    $status = $bz->bzclose($output);

    my ($bz, $status) = new Compress::Raw::Bunzip2 [OPTS]
        or die "Cannot create bunzip2 object: $bzerno\n";
    
    $status = $bz->bzinflate($input, $output);

    my $version = Compress::Raw::Bzip2::bzlibversion();

=head1 DESCRIPTION

C<Compress::Raw::Bzip2> provides an interface to the in-memory
compression/uncompression functions from the bzip2 compression library. 

Although the primary purpose for the existence of C<Compress::Raw::Bzip2>
is for use by the  C<IO::Compress::Bzip2> and C<IO::Compress::Bunzip2>
modules, it can be used on its own for simple compression/uncompression
tasks.

=head1 Compression

=head2 ($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;

Creates a new compression object. 

If successful, it will return the initialised compression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned compression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in
the C<bzdeflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$blockSize100k>

To quote the bzip2 documentation

    blockSize100k specifies the block size to be used for compression. It
    should be a value between 1 and 9 inclusive, and the actual block size
    used is 100000 x this figure. 9 gives the best compression but takes
    most memory.

Defaults to 1.

=item B<$workfactor>

To quote the bzip2 documentation

    This parameter controls how the compression phase behaves when
    presented with worst case, highly repetitive, input data. If
    compression runs into difficulties caused by repetitive data, the
    library switches from the standard sorting algorithm to a fallback
    algorithm. The fallback is slower than the standard algorithm by
    perhaps a factor of three, but always behaves reasonably, no matter how
    bad the input.

    Lower values of workFactor reduce the amount of effort the standard
    algorithm will expend before resorting to the fallback. You should set
    this parameter carefully; too low, and many inputs will be handled by
    the fallback algorithm and so compress rather slowly, too high, and
    your average-to-worst case compression times can become very large. The
    default value of 30 gives reasonable behaviour over a wide range of
    circumstances.

    Allowable values range from 0 to 250 inclusive. 0 is a special case,
    equivalent to using the default value of 30.

Defaults to 0.

=back

=head2 $status = $bz->bzdeflate($input, $output);

Reads the contents of C<$input>, compresses it and writes the compressed
data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

If C<appendOutput> is enabled in the constructor for the bzip2 object, the
compressed data will be appended to C<$output>. If not enabled, C<$output>
will be truncated before the compressed data is written to it.

=head2 $status = $bz->bzflush($output);

Flushes any pending compressed data to C<$output>.

Returns C<BZ_RUN_OK> on success and a C<bzip2> error code on failure.

=head2 $status = $bz->bzclose($output);

Terminates the compressed data stream and flushes any pending compressed
data to C<$output>.

Returns C<BZ_STREAM_END> on success and a C<bzip2> error code on failure.

=head2 Example

=head1 Uncompression

=head2 ($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;

If successful, it will return the initialised uncompression object, C<$z>
and a C<$status> of C<BZ_OK> in a list context. In scalar context it
returns the deflation object, C<$z>, only.

If not successful, the returned uncompression object, C<$z>, will be
I<undef> and C<$status> will hold the a I<bzip2> error code.

Below is a list of the valid options:

=over 5

=item B<$appendOutput>

Controls whether the compressed data is appended to the output buffer in the
C<bzinflate>, C<bzflush> and C<bzclose> methods.

Defaults to 1.

=item B<$consumeInput>

=item B<$small>

To quote the bzip2 documentation

    If small is nonzero, the library will use an alternative decompression
    algorithm which uses less memory but at the cost of decompressing more
    slowly (roughly speaking, half the speed, but the maximum memory
    requirement drops to around 2300k). 

Defaults to 0.

=item B<$limitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->bzinflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the 16k or the amount of memory already allocated to C<$output>,
whichever is larger. Predicting the output size available is tricky, so
don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->bzinflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

=item B<$verbosity>

This parameter is ignored.

Defaults to 0.

=back

=head2 $status = $z->bzinflate($input, $output);

Uncompresses C<$input> and writes the uncompressed data to C<$output>. 

Returns C<BZ_OK> if the uncompression was successful, but the end of the
compressed data stream has not been reached. Returns C<BZ_STREAM_END> on
successful uncompression and the end of the compression stream has been
reached.

If C<consumeInput> is enabled in the constructor for the bunzip2 object,
C<$input> will have all compressed data removed from it after
uncompression. On C<BZ_OK> return this will mean that C<$input> will be an
empty string; when C<BZ_STREAM_END> C<$input> will either be an empty
string or will contain whatever data immediately followed the compressed
data stream.

If C<appendOutput> is enabled in the constructor for the bunzip2 object,
the uncompressed data will be appended to C<$output>. If not enabled,
C<$output> will be truncated before the uncompressed data is written to it.

=head1 Misc

=head2 my $version = Compress::Raw::Bzip2::bzlibversion();

Returns the version of the underlying bzip2 library.

=head1 Constants

The following bzip2 constants are exported by this module

		BZ_RUN
		BZ_FLUSH
		BZ_FINISH

		BZ_OK
		BZ_RUN_OK
		BZ_FLUSH_OK
		BZ_FINISH_OK
		BZ_STREAM_END
		BZ_SEQUENCE_ERROR
		BZ_PARAM_ERROR
		BZ_MEM_ERROR
		BZ_DATA_ERROR
		BZ_DATA_ERROR_MAGIC
		BZ_IO_ERROR
		BZ_UNEXPECTED_EOF
		BZ_OUTBUFF_FULL
		BZ_CONFIG_ERROR

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

The primary site for the bzip2 program is F<http://www.bzip.org>.

See the module L<Compress::Bzip2|Compress::Bzip2>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
package Compress::Raw::Zlib;

require 5.006 ;
require Exporter;
use Carp ;

use strict ;
use warnings ;
use bytes ;
our ($VERSION, $XS_VERSION, @ISA, @EXPORT, %EXPORT_TAGS, @EXPORT_OK, $AUTOLOAD, %DEFLATE_CONSTANTS, @DEFLATE_CONSTANTS);

$VERSION = '2.065';
$XS_VERSION = $VERSION; 
$VERSION = eval $VERSION;

@ISA = qw(Exporter);
%EXPORT_TAGS = ( flush     => [qw{  
                                    Z_NO_FLUSH
                                    Z_PARTIAL_FLUSH
                                    Z_SYNC_FLUSH
                                    Z_FULL_FLUSH
                                    Z_FINISH
                                    Z_BLOCK
                              }],
                 level     => [qw{  
                                    Z_NO_COMPRESSION
                                    Z_BEST_SPEED
                                    Z_BEST_COMPRESSION
                                    Z_DEFAULT_COMPRESSION
                              }],
                 strategy  => [qw{  
                                    Z_FILTERED
                                    Z_HUFFMAN_ONLY
                                    Z_RLE
                                    Z_FIXED
                                    Z_DEFAULT_STRATEGY
                              }],
                 status   => [qw{  
                                    Z_OK
                                    Z_STREAM_END
                                    Z_NEED_DICT
                                    Z_ERRNO
                                    Z_STREAM_ERROR
                                    Z_DATA_ERROR  
                                    Z_MEM_ERROR   
                                    Z_BUF_ERROR 
                                    Z_VERSION_ERROR 
                              }],                              
              );

%DEFLATE_CONSTANTS = %EXPORT_TAGS;

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.
@DEFLATE_CONSTANTS = 
@EXPORT = qw(
        ZLIB_VERSION
        ZLIB_VERNUM

        
        OS_CODE

        MAX_MEM_LEVEL
        MAX_WBITS

        Z_ASCII
        Z_BEST_COMPRESSION
        Z_BEST_SPEED
        Z_BINARY
        Z_BLOCK
        Z_BUF_ERROR
        Z_DATA_ERROR
        Z_DEFAULT_COMPRESSION
        Z_DEFAULT_STRATEGY
        Z_DEFLATED
        Z_ERRNO
        Z_FILTERED
        Z_FIXED
        Z_FINISH
        Z_FULL_FLUSH
        Z_HUFFMAN_ONLY
        Z_MEM_ERROR
        Z_NEED_DICT
        Z_NO_COMPRESSION
        Z_NO_FLUSH
        Z_NULL
        Z_OK
        Z_PARTIAL_FLUSH
        Z_RLE
        Z_STREAM_END
        Z_STREAM_ERROR
        Z_SYNC_FLUSH
        Z_TREES
        Z_UNKNOWN
        Z_VERSION_ERROR

        WANT_GZIP
        WANT_GZIP_OR_ZLIB
);

push @EXPORT, qw(crc32 adler32 DEF_WBITS);

use constant WANT_GZIP           => 16;
use constant WANT_GZIP_OR_ZLIB   => 32;

sub AUTOLOAD {
    my($constname);
    ($constname = $AUTOLOAD) =~ s/.*:://;
    my ($error, $val) = constant($constname);
    Carp::croak $error if $error;
    no strict 'refs';
    *{$AUTOLOAD} = sub { $val };
    goto &{$AUTOLOAD};
}

use constant FLAG_APPEND             => 1 ;
use constant FLAG_CRC                => 2 ;
use constant FLAG_ADLER              => 4 ;
use constant FLAG_CONSUME_INPUT      => 8 ;
use constant FLAG_LIMIT_OUTPUT       => 16 ;

eval {
    require XSLoader;
    XSLoader::load('Compress::Raw::Zlib', $XS_VERSION);
    1;
} 
or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap Compress::Raw::Zlib $XS_VERSION ; 
};
 

use constant Parse_any      => 0x01;
use constant Parse_unsigned => 0x02;
use constant Parse_signed   => 0x04;
use constant Parse_boolean  => 0x08;
#use constant Parse_string   => 0x10;
#use constant Parse_custom   => 0x12;

#use constant Parse_store_ref => 0x100 ;

use constant OFF_PARSED     => 0 ;
use constant OFF_TYPE       => 1 ;
use constant OFF_DEFAULT    => 2 ;
use constant OFF_FIXED      => 3 ;
use constant OFF_FIRST_ONLY => 4 ;
use constant OFF_STICKY     => 5 ;



sub ParseParameters
{
    my $level = shift || 0 ; 

    my $sub = (caller($level + 1))[3] ;
    #local $Carp::CarpLevel = 1 ;
    my $p = new Compress::Raw::Zlib::Parameters() ;
    $p->parse(@_)
        or croak "$sub: $p->{Error}" ;

    return $p;
}


sub Compress::Raw::Zlib::Parameters::new
{
    my $class = shift ;

    my $obj = { Error => '',
                Got   => {},
              } ;

    #return bless $obj, ref($class) || $class || __PACKAGE__ ;
    return bless $obj, 'Compress::Raw::Zlib::Parameters' ;
}

sub Compress::Raw::Zlib::Parameters::setError
{
    my $self = shift ;
    my $error = shift ;
    my $retval = @_ ? shift : undef ;

    $self->{Error} = $error ;
    return $retval;
}
          
#sub getError
#{
#    my $self = shift ;
#    return $self->{Error} ;
#}
          
sub Compress::Raw::Zlib::Parameters::parse
{
    my $self = shift ;

    my $default = shift ;

    my $got = $self->{Got} ;
    my $firstTime = keys %{ $got } == 0 ;

    my (@Bad) ;
    my @entered = () ;

    # Allow the options to be passed as a hash reference or
    # as the complete hash.
    if (@_ == 0) {
        @entered = () ;
    }
    elsif (@_ == 1) {
        my $href = $_[0] ;    
        return $self->setError("Expected even number of parameters, got 1")
            if ! defined $href or ! ref $href or ref $href ne "HASH" ;
 
        foreach my $key (keys %$href) {
            push @entered, $key ;
            push @entered, \$href->{$key} ;
        }
    }
    else {
        my $count = @_;
        return $self->setError("Expected even number of parameters, got $count")
            if $count % 2 != 0 ;
        
        for my $i (0.. $count / 2 - 1) {
            push @entered, $_[2* $i] ;
            push @entered, \$_[2* $i+1] ;
        }
    }


    while (my ($key, $v) = each %$default)
    {
        croak "need 4 params [@$v]"
            if @$v != 4 ;

        my ($first_only, $sticky, $type, $value) = @$v ;
        my $x ;
        $self->_checkType($key, \$value, $type, 0, \$x) 
            or return undef ;

        $key = lc $key;

        if ($firstTime || ! $sticky) {
            $got->{$key} = [0, $type, $value, $x, $first_only, $sticky] ;
        }

        $got->{$key}[OFF_PARSED] = 0 ;
    }

    for my $i (0.. @entered / 2 - 1) {
        my $key = $entered[2* $i] ;
        my $value = $entered[2* $i+1] ;

        #print "Key [$key] Value [$value]" ;
        #print defined $$value ? "[$$value]\n" : "[undef]\n";

        $key =~ s/^-// ;
        my $canonkey = lc $key;
 
        if ($got->{$canonkey} && ($firstTime ||
                                  ! $got->{$canonkey}[OFF_FIRST_ONLY]  ))
        {
            my $type = $got->{$canonkey}[OFF_TYPE] ;
            my $s ;
            $self->_checkType($key, $value, $type, 1, \$s)
                or return undef ;
            #$value = $$value unless $type & Parse_store_ref ;
            $value = $$value ;
            $got->{$canonkey} = [1, $type, $value, $s] ;
        }
        else
          { push (@Bad, $key) }
    }
 
    if (@Bad) {
        my ($bad) = join(", ", @Bad) ;
        return $self->setError("unknown key value(s) @Bad") ;
    }

    return 1;
}

sub Compress::Raw::Zlib::Parameters::_checkType
{
    my $self = shift ;

    my $key   = shift ;
    my $value = shift ;
    my $type  = shift ;
    my $validate  = shift ;
    my $output  = shift;

    #local $Carp::CarpLevel = $level ;
    #print "PARSE $type $key $value $validate $sub\n" ;
#    if ( $type & Parse_store_ref)
#    {
#        #$value = $$value
#        #    if ref ${ $value } ;
#
#        $$output = $value ;
#        return 1;
#    }

    $value = $$value ;

    if ($type & Parse_any)
    {
        $$output = $value ;
        return 1;
    }
    elsif ($type & Parse_unsigned)
    {
        return $self->setError("Parameter '$key' must be an unsigned int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be an unsigned int, got '$value'")
            if $validate && $value !~ /^\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1;
    }
    elsif ($type & Parse_signed)
    {
        return $self->setError("Parameter '$key' must be a signed int, got 'undef'")
            if $validate && ! defined $value ;
        return $self->setError("Parameter '$key' must be a signed int, got '$value'")
            if $validate && $value !~ /^-?\d+$/;

        $$output = defined $value ? $value : 0 ;    
        return 1 ;
    }
    elsif ($type & Parse_boolean)
    {
        return $self->setError("Parameter '$key' must be an int, got '$value'")
            if $validate && defined $value && $value !~ /^\d*$/;
        $$output =  defined $value ? $value != 0 : 0 ;    
        return 1;
    }
#    elsif ($type & Parse_string)
#    {
#        $$output = defined $value ? $value : "" ;    
#        return 1;
#    }

    $$output = $value ;
    return 1;
}



sub Compress::Raw::Zlib::Parameters::parsed
{
    my $self = shift ;
    my $name = shift ;

    return $self->{Got}{lc $name}[OFF_PARSED] ;
}

sub Compress::Raw::Zlib::Parameters::value
{
    my $self = shift ;
    my $name = shift ;

    if (@_)
    {
        $self->{Got}{lc $name}[OFF_PARSED]  = 1;
        $self->{Got}{lc $name}[OFF_DEFAULT] = $_[0] ;
        $self->{Got}{lc $name}[OFF_FIXED]   = $_[0] ;
    }

    return $self->{Got}{lc $name}[OFF_FIXED] ;
}

our $OPTIONS_deflate =   
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],

        'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
        'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
        'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    };

sub Compress::Raw::Zlib::Deflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_deflate, @_);

    croak "Compress::Raw::Zlib::Deflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _deflateInit($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $windowBits, 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                $got->value('Dictionary')) ;

}

sub Compress::Raw::Zlib::deflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::deflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}


our $OPTIONS_inflate = 
    {
        'AppendOutput'  => [1, 1, Parse_boolean,  0],
        'LimitOutput'   => [1, 1, Parse_boolean,  0],
        'CRC32'         => [1, 1, Parse_boolean,  0],
        'ADLER32'       => [1, 1, Parse_boolean,  0],
        'ConsumeInput'  => [1, 1, Parse_boolean,  1],
        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
        'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
        'Dictionary'    => [1, 1, Parse_any,      ""],
    } ;

sub Compress::Raw::Zlib::Inflate::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0, $OPTIONS_inflate, @_);

    croak "Compress::Raw::Zlib::Inflate::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    $flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;
    $flags |= FLAG_LIMIT_OUTPUT if $got->value('LimitOutput') ;


    my $windowBits =  $got->value('WindowBits');
    $windowBits += MAX_WBITS()
        if ($windowBits & MAX_WBITS()) == 0 ;

    _inflateInit($flags, $windowBits, $got->value('Bufsize'), 
                 $got->value('Dictionary')) ;
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_freeze
{
    my $type = ref shift;
    croak "Cannot freeze $type object\n";
}

sub Compress::Raw::Zlib::inflateStream::STORABLE_thaw
{
    my $type = ref shift;
    croak "Cannot thaw $type object\n";
}

sub Compress::Raw::Zlib::InflateScan::new
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
                    {
                        'CRC32'         => [1, 1, Parse_boolean,  0],
                        'ADLER32'       => [1, 1, Parse_boolean,  0],
                        'Bufsize'       => [1, 1, Parse_unsigned, 4096],
                 
                        'WindowBits'    => [1, 1, Parse_signed,   -MAX_WBITS()],
                        'Dictionary'    => [1, 1, Parse_any,      ""],
            }, @_) ;


    croak "Compress::Raw::Zlib::InflateScan::new: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    #$flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;
    #$flags |= FLAG_CONSUME_INPUT if $got->value('ConsumeInput') ;

    _inflateScanInit($flags, $got->value('WindowBits'), $got->value('Bufsize'), 
                 '') ;
}

sub Compress::Raw::Zlib::inflateScanStream::createDeflateStream
{
    my $pkg = shift ;
    my ($got) = ParseParameters(0,
            {
                'AppendOutput'  => [1, 1, Parse_boolean,  0],
                'CRC32'         => [1, 1, Parse_boolean,  0],
                'ADLER32'       => [1, 1, Parse_boolean,  0],
                'Bufsize'       => [1, 1, Parse_unsigned, 4096],
 
                'Level'         => [1, 1, Parse_signed,   Z_DEFAULT_COMPRESSION()],
                'Method'        => [1, 1, Parse_unsigned, Z_DEFLATED()],
                'WindowBits'    => [1, 1, Parse_signed,   - MAX_WBITS()],
                'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
                'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
            }, @_) ;

    croak "Compress::Raw::Zlib::InflateScan::createDeflateStream: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;

    my $flags = 0 ;
    $flags |= FLAG_APPEND if $got->value('AppendOutput') ;
    $flags |= FLAG_CRC    if $got->value('CRC32') ;
    $flags |= FLAG_ADLER  if $got->value('ADLER32') ;

    $pkg->_createDeflateStream($flags,
                $got->value('Level'), 
                $got->value('Method'), 
                $got->value('WindowBits'), 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                ) ;

}

sub Compress::Raw::Zlib::inflateScanStream::inflate
{
    my $self = shift ;
    my $buffer = $_[1];
    my $eof = $_[2];

    my $status = $self->scan(@_);

    if ($status == Z_OK() && $_[2]) {
        my $byte = ' ';
        
        $status = $self->scan(\$byte, $_[1]) ;
    }
    
    return $status ;
}

sub Compress::Raw::Zlib::deflateStream::deflateParams
{
    my $self = shift ;
    my ($got) = ParseParameters(0, {
                'Level'      => [1, 1, Parse_signed,   undef],
                'Strategy'   => [1, 1, Parse_unsigned, undef],
                'Bufsize'    => [1, 1, Parse_unsigned, undef],
                }, 
                @_) ;

    croak "Compress::Raw::Zlib::deflateParams needs Level and/or Strategy"
        unless $got->parsed('Level') + $got->parsed('Strategy') +
            $got->parsed('Bufsize');

    croak "Compress::Raw::Zlib::Inflate::deflateParams: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        if $got->parsed('Bufsize') && $got->value('Bufsize') <= 1;

    my $flags = 0;
    $flags |= 1 if $got->parsed('Level') ;
    $flags |= 2 if $got->parsed('Strategy') ;
    $flags |= 4 if $got->parsed('Bufsize') ;

    $self->_deflateParams($flags, $got->value('Level'), 
                          $got->value('Strategy'), $got->value('Bufsize'));

}


1;
__END__


=head1 NAME

Compress::Raw::Zlib - Low-Level Interface to zlib compression library

=head1 SYNOPSIS

    use Compress::Raw::Zlib ;

    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
    $status = $d->deflate($input, $output) ;
    $status = $d->flush($output [, $flush_type]) ;
    $d->deflateReset() ;
    $d->deflateParams(OPTS) ;
    $d->deflateTune(OPTS) ;
    $d->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $d->total_in() ;
    $d->total_out() ;
    $d->msg() ;
    $d->get_Strategy();
    $d->get_Level();
    $d->get_BufSize();

    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
    $status = $i->inflate($input, $output [, $eof]) ;
    $status = $i->inflateSync($input) ;
    $i->inflateReset() ;
    $i->dict_adler() ;
    $d->crc32() ;
    $d->adler32() ;
    $i->total_in() ;
    $i->total_out() ;
    $i->msg() ;
    $d->get_BufSize();

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

    my $version = Compress::Raw::Zlib::zlib_version();
    my $flags = Compress::Raw::Zlib::zlibCompileFlags();

=head1 DESCRIPTION

The I<Compress::Raw::Zlib> module provides a Perl interface to the I<zlib>
compression library (see L</AUTHOR> for details about where to get
I<zlib>). 

=head1 Compress::Raw::Zlib::Deflate

This section defines an interface that allows in-memory compression using
the I<deflate> interface provided by zlib.

Here is a definition of the interface available:

=head2 B<($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) >

Initialises a deflation object. 

If you are familiar with the I<zlib> library, it combines the
features of the I<zlib> functions C<deflateInit>, C<deflateInit2>
and C<deflateSetDictionary>.

If successful, it will return the initialised deflation object, C<$d>
and a C<$status> of C<Z_OK> in a list context. In scalar context it
returns the deflation object, C<$d>, only.

If not successful, the returned deflation object, C<$d>, will be
I<undef> and C<$status> will hold the a I<zlib> error code.

The function optionally takes a number of named options specified as
C<< Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the name=>value pairs.

Below is a list of the valid options:

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

The default is C<Z_DEFAULT_COMPRESSION>.

=item B<-Method>

Defines the compression method. The only valid value at present (and
the default) is C<Z_DEFLATED>.

=item B<-WindowBits>

To compress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To compress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To compress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

For a definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-MemLevel>

For a definition of the meaning and valid values for C<MemLevel>
refer to the I<zlib> documentation for I<deflateInit2>.

Defaults to MAX_MEM_LEVEL.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED>, C<Z_RLE>, C<Z_FIXED> and
C<Z_HUFFMAN_ONLY>.

The default is C<Z_DEFAULT_STRATEGY>.

=item B<-Dictionary>

When a dictionary is specified I<Compress::Raw::Zlib> will automatically
call C<deflateSetDictionary> directly after calling C<deflateInit>. The
Adler32 value for the dictionary can be obtained by calling the method 
C<$d-E<gt>dict_adler()>.

The default is no dictionary.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

The default buffer size is 4096.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

If the C<AppendOutput> option is set to false, the output buffers in the
C<$d-E<gt>deflate> and C<$d-E<gt>flush>  methods will be truncated before
uncompressed data is written to them.

If the option is set to true, uncompressed data will be appended to the
output buffer in the C<$d-E<gt>deflate> and C<$d-E<gt>flush> methods.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$d-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=back

Here is an example of using the C<Compress::Raw::Zlib::Deflate> optional
parameter list to override the default buffer size and compression
level. All other options will take their default values.

    my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize => 300, 
                                               -Level   => Z_BEST_SPEED ) ;

=head2 B<$status = $d-E<gt>deflate($input, $output)>

Deflates the contents of C<$input> and writes the compressed data to
C<$output>.

The C<$input> and C<$output> parameters can be either scalars or scalar
references.

When finished, C<$input> will be completely processed (assuming there
were no errors). If the deflation was successful it writes the deflated
data to C<$output> and returns a status value of C<Z_OK>.

On error, it returns a I<zlib> error code.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

B<Note>: This method will not necessarily write compressed data to
C<$output> every time it is called. So do not assume that there has been
an error if the contents of C<$output> is empty on returning from
this method. As long as the return code from the method is C<Z_OK>,
the deflate has succeeded.

=head2 B<$status = $d-E<gt>flush($output [, $flush_type]) >

Typically used to finish the deflation. Any pending output will be
written to C<$output>.

Returns C<Z_OK> if successful.

Note that flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using C<Z_FINISH>) or
when you want to create a I<full flush point> (using C<Z_FULL_FLUSH>).

By default the C<flush_type> used is C<Z_FINISH>. Other valid values
for C<flush_type> are C<Z_NO_FLUSH>, C<Z_PARTIAL_FLUSH>, C<Z_SYNC_FLUSH>
and C<Z_FULL_FLUSH>. It is strongly recommended that you only set the
C<flush_type> parameter if you fully understand the implications of
what it does. See the C<zlib> documentation for details.

If the C<AppendOutput> option is set to true in the constructor for
the C<$d> object, the compressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any compressed data is
written to it.

=head2 B<$status = $d-E<gt>deflateReset() >

This method will reset the deflation object C<$d>. It can be used when you
are compressing multiple data streams and want to use the same object to
compress each of them. It should only be used once the previous data stream
has been flushed successfully, i.e. a call to C<< $d->flush(Z_FINISH) >> has
returned C<Z_OK>.

Returns C<Z_OK> if successful.

=head2 B<$status = $d-E<gt>deflateParams([OPT])>

Change settings for the deflate object C<$d>.

The list of the valid options is shown below. Options not specified
will remain unchanged.

=over 5

=item B<-Level>

Defines the compression level. Valid values are 0 through 9,
C<Z_NO_COMPRESSION>, C<Z_BEST_SPEED>, C<Z_BEST_COMPRESSION>, and
C<Z_DEFAULT_COMPRESSION>.

=item B<-Strategy>

Defines the strategy used to tune the compression. The valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=item B<-BufSize>

Sets the initial size for the output buffer used by the C<$d-E<gt>deflate>
and C<$d-E<gt>flush> methods. If the buffer has to be
reallocated to increase the size, it will grow in increments of
C<Bufsize>.

=back

=head2 B<$status = $d-E<gt>deflateTune($good_length, $max_lazy, $nice_length, $max_chain)>

Tune the internal settings for the deflate object C<$d>. This option is
only available if you are running zlib 1.2.2.3 or better.

Refer to the documentation in zlib.h for instructions on how to fly
C<deflateTune>.

=head2 B<$d-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$d-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date. 

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$d-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date. 

=head2 B<$d-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$d-E<gt>total_in()>

Returns the total number of bytes uncompressed bytes input to deflate.

=head2 B<$d-E<gt>total_out()>

Returns the total number of compressed bytes output from deflate.

=head2 B<$d-E<gt>get_Strategy()>

Returns the deflation strategy currently used. Valid values are
C<Z_DEFAULT_STRATEGY>, C<Z_FILTERED> and C<Z_HUFFMAN_ONLY>. 

=head2 B<$d-E<gt>get_Level()>

Returns the compression level being used. 

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the compression.

=head2 Example

Here is a trivial example of using C<deflate>. It simply reads standard
input, deflates it and writes it to standard output.

    use strict ;
    use warnings ;

    use Compress::Raw::Zlib ;

    binmode STDIN;
    binmode STDOUT;
    my $x = new Compress::Raw::Zlib::Deflate
       or die "Cannot create a deflation stream\n" ;

    my ($output, $status) ;
    while (<>)
    {
        $status = $x->deflate($_, $output) ;
    
        $status == Z_OK
            or die "deflation failed\n" ;
    
        print $output ;
    }
    
    $status = $x->flush($output) ;
    
    $status == Z_OK
        or die "deflation failed\n" ;
    
    print $output ;

=head1 Compress::Raw::Zlib::Inflate

This section defines an interface that allows in-memory uncompression using
the I<inflate> interface provided by zlib.

Here is a definition of the interface:

=head2 B< ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) >

Initialises an inflation object. 

In a list context it returns the inflation object, C<$i>, and the
I<zlib> status code (C<$status>). In a scalar context it returns the
inflation object only.

If successful, C<$i> will hold the inflation object and C<$status> will
be C<Z_OK>.

If not successful, C<$i> will be I<undef> and C<$status> will hold the
I<zlib> error code.

The function optionally takes a number of named options specified as
C<< -Name => value >> pairs. This allows individual options to be
tailored without having to specify them all in the parameter list.

For backward compatibility, it is also possible to pass the parameters
as a reference to a hash containing the C<< name=>value >> pairs.

Here is a list of the valid options:

=over 5

=item B<-WindowBits>

To uncompress an RFC 1950 data stream, set C<WindowBits> to a positive
number between 8 and 15.

To uncompress an RFC 1951 data stream, set C<WindowBits> to C<-MAX_WBITS>.

To uncompress an RFC 1952 data stream (i.e. gzip), set C<WindowBits> to
C<WANT_GZIP>.

To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e.
gzip), set C<WindowBits> to C<WANT_GZIP_OR_ZLIB>.

For a full definition of the meaning and valid values for C<WindowBits>
refer to the I<zlib> documentation for I<inflateInit2>.

Defaults to C<MAX_WBITS>.

=item B<-Bufsize>

Sets the initial size for the output buffer used by the C<$i-E<gt>inflate>
method. If the output buffer in this method has to be reallocated to
increase the size, it will grow in increments of C<Bufsize>.

Default is 4096.

=item B<-Dictionary>

The default is no dictionary.

=item B<-AppendOutput>

This option controls how data is written to the output buffer by the
C<$i-E<gt>inflate> method.

If the option is set to false, the output buffer in the C<$i-E<gt>inflate>
method will be truncated before uncompressed data is written to it.

If the option is set to true, uncompressed data will be appended to the
output buffer by the C<$i-E<gt>inflate> method.

This option defaults to false.

=item B<-CRC32>

If set to true, a crc32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>crc32> method to retrieve this value.

This option defaults to false.

=item B<-ADLER32>

If set to true, an adler32 checksum of the uncompressed data will be
calculated. Use the C<$i-E<gt>adler32> method to retrieve this value.

This option defaults to false.

=item B<-ConsumeInput>

If set to true, this option will remove compressed data from the input
buffer of the C<< $i->inflate >> method as the inflate progresses.

This option can be useful when you are processing compressed data that is
embedded in another file/buffer. In this case the data that immediately
follows the compressed stream will be left in the input buffer.

This option defaults to true.

=item B<-LimitOutput>

The C<LimitOutput> option changes the behavior of the C<< $i->inflate >>
method so that the amount of memory used by the output buffer can be
limited. 

When C<LimitOutput> is used the size of the output buffer used will either
be the value of the C<Bufsize> option or the amount of memory already
allocated to C<$output>, whichever is larger. Predicting the output size
available is tricky, so don't rely on getting an exact output buffer size.

When C<LimitOutout> is not specified C<< $i->inflate >> will use as much
memory as it takes to write all the uncompressed data it creates by
uncompressing the input buffer.

If C<LimitOutput> is enabled, the C<ConsumeInput> option will also be
enabled.

This option defaults to false.

See L</The LimitOutput option> for a discussion on why C<LimitOutput> is
needed and how to use it.

=back

Here is an example of using an optional parameter to override the default
buffer size.

    my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize => 300 ) ;

=head2 B< $status = $i-E<gt>inflate($input, $output [,$eof]) >

Inflates the complete contents of C<$input> and writes the uncompressed
data to C<$output>. The C<$input> and C<$output> parameters can either be
scalars or scalar references.

Returns C<Z_OK> if successful and C<Z_STREAM_END> if the end of the
compressed data has been successfully reached. 

If not successful C<$status> will hold the I<zlib> error code.

If the C<ConsumeInput> option has been set to true when the
C<Compress::Raw::Zlib::Inflate> object is created, the C<$input> parameter
is modified by C<inflate>. On completion it will contain what remains
of the input buffer after inflation. In practice, this means that when
the return status is C<Z_OK> the C<$input> parameter will contain an
empty string, and when the return status is C<Z_STREAM_END> the C<$input>
parameter will contains what (if anything) was stored in the input buffer
after the deflated data stream.

This feature is useful when processing a file format that encapsulates
a compressed data stream (e.g. gzip, zip) and there is useful data
immediately after the deflation stream.

If the C<AppendOutput> option is set to true in the constructor for
this object, the uncompressed data will be appended to C<$output>. If
it is false, C<$output> will be truncated before any uncompressed data
is written to it.

The C<$eof> parameter needs a bit of explanation. 

Prior to version 1.2.0, zlib assumed that there was at least one trailing
byte immediately after the compressed data stream when it was carrying out
decompression. This normally isn't a problem because the majority of zlib
applications guarantee that there will be data directly after the
compressed data stream.  For example, both gzip (RFC 1950) and zip both
define trailing data that follows the compressed data stream.

The C<$eof> parameter only needs to be used if B<all> of the following
conditions apply

=over 5

=item 1 

You are either using a copy of zlib that is older than version 1.2.0 or you
want your application code to be able to run with as many different
versions of zlib as possible.

=item 2

You have set the C<WindowBits> parameter to C<-MAX_WBITS> in the constructor
for this object, i.e. you are uncompressing a raw deflated data stream
(RFC 1951).

=item 3

There is no data immediately after the compressed data stream.

=back

If B<all> of these are the case, then you need to set the C<$eof> parameter
to true on the final call (and only the final call) to C<$i-E<gt>inflate>. 

If you have built this module with zlib >= 1.2.0, the C<$eof> parameter is
ignored. You can still set it if you want, but it won't be used behind the
scenes.

=head2 B<$status = $i-E<gt>inflateSync($input)>

This method can be used to attempt to recover good data from a compressed
data stream that is partially corrupt.
It scans C<$input> until it reaches either a I<full flush point> or the
end of the buffer.

If a I<full flush point> is found, C<Z_OK> is returned and C<$input>
will be have all data up to the flush point removed. This data can then be
passed to the C<$i-E<gt>inflate> method to be uncompressed.

Any other return code means that a flush point was not found. If more
data is available, C<inflateSync> can be called repeatedly with more
compressed data until the flush point is found.

Note I<full flush points> are not present by default in compressed
data streams. They must have been added explicitly when the data stream
was created by calling C<Compress::Deflate::flush>  with C<Z_FULL_FLUSH>.

=head2 B<$status = $i-E<gt>inflateReset() >

This method will reset the inflation object C<$i>. It can be used when you
are uncompressing multiple data streams and want to use the same object to
uncompress each of them. 

Returns C<Z_OK> if successful.

=head2 B<$i-E<gt>dict_adler()>

Returns the adler32 value for the dictionary.

=head2 B<$i-E<gt>crc32()>

Returns the crc32 value for the uncompressed data to date.

If the C<CRC32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>adler32()>

Returns the adler32 value for the uncompressed data to date.

If the C<ADLER32> option is not enabled in the constructor for this object,
this method will always return 0;

=head2 B<$i-E<gt>msg()>

Returns the last error message generated by zlib.

=head2 B<$i-E<gt>total_in()>

Returns the total number of bytes compressed bytes input to inflate.

=head2 B<$i-E<gt>total_out()>

Returns the total number of uncompressed bytes output from inflate.

=head2 B<$d-E<gt>get_BufSize()>

Returns the buffer size used to carry out the decompression.

=head2 Examples

Here is an example of using C<inflate>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The next example show how to use the C<LimitOutput> option. Notice the use
of two nested loops in this case. The outer loop reads the data from the
input source - STDIN and the inner loop repeatedly calls C<inflate> until
C<$input> is exhausted, we get an error, or the end of the stream is
reached. One point worth remembering is by using the C<LimitOutput> option
you also get C<ConsumeInput> set as well - this makes the code below much
simpler.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

=head1 CHECKSUM FUNCTIONS

Two functions are provided by I<zlib> to calculate checksums. For the
Perl interface, the order of the two parameters in both functions has
been reversed. This allows both running checksums and one off
calculations to be done.

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

The buffer parameters can either be a scalar or a scalar reference.

If the $crc parameters is C<undef>, the crc value will be reset.

If you have built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

These functions allow checksums to be merged.
Refer to the I<zlib> documentation for more details.

=head1 Misc

=head2 my $version = Compress::Raw::Zlib::zlib_version();

Returns the version of the zlib library.

=head2  my $flags = Compress::Raw::Zlib::zlibCompileFlags();

Returns the flags indicating compile-time options that were used to build 
the zlib library. See the zlib documentation for a description of the flags
returned by C<zlibCompileFlags>.

Note that when the zlib sources are built along with this module the
C<sprintf> flags (bits 24, 25 and 26) should be ignored.

If you are using zlib 1.2.0 or older, C<zlibCompileFlags> will return 0. 

=head1 The LimitOutput option.

By default C<< $i->inflate($input, $output) >> will uncompress I<all> data
in C<$input> and write I<all> of the uncompressed data it has generated to
C<$output>. This makes the interface to C<inflate> much simpler - if the
method has uncompressed C<$input> successfully I<all> compressed data in
C<$input> will have been dealt with. So if you are reading from an input
source and uncompressing as you go the code will look something like this

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x->inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

The points to note are 

=over 5

=item *

The main processing loop in the code handles reading of compressed data
from STDIN.

=item *

The status code returned from C<inflate> will only trigger termination of
the main processing loop if it isn't C<Z_OK>. When C<LimitOutput> has not
been used the C<Z_OK> status means that the end of the compressed
data stream has been reached or there has been an error in uncompression.

=item *

After the call to C<inflate> I<all> of the uncompressed data in C<$input>
will have been processed. This means the subsequent call to C<read> can
overwrite it's contents without any problem.

=back

For most use-cases the behavior described above is acceptable (this module
and it's predecessor, C<Compress::Zlib>, have used it for over 10 years
without an issue), but in a few very specific use-cases the amount of
memory required for C<$output> can prohibitively large. For example, if the
compressed data stream contains the same pattern repeated thousands of
times, a relatively small compressed data stream can uncompress into
hundreds of megabytes.  Remember C<inflate> will keep allocating memory
until I<all> the uncompressed data has been written to the output buffer -
the size of C<$output> is unbounded. 

The C<LimitOutput> option is designed to help with this use-case.

The main difference in your code when using C<LimitOutput> is having to
deal with cases where the C<$input> parameter still contains some
uncompressed data that C<inflate> hasn't processed yet. The status code
returned from C<inflate> will be C<Z_OK> if uncompression took place and
C<Z_BUF_ERROR> if the output buffer is full.

Below is typical code that shows how to use C<LimitOutput>.

    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput => 1)
       or die "Cannot create a inflation stream\n" ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x->inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK && length $input);
    }
    
    die "inflation failed\n"
        unless $status == Z_STREAM_END ;

Points to note this time:

=over 5

=item *

There are now two nested loops in the code: the outer loop for reading the
compressed data from STDIN, as before; and the inner loop to carry out the
uncompression.

=item *

There are two exit points from the inner uncompression loop.

Firstly when C<inflate> has returned a status other than C<Z_OK> or
C<Z_BUF_ERROR>.  This means that either the end of the compressed data
stream has been reached (C<Z_STREAM_END>) or there is an error in the
compressed data. In either of these cases there is no point in continuing
with reading the compressed data, so both loops are terminated.

The second exit point tests if there is any data left in the input buffer,
C<$input> - remember that the C<ConsumeInput> option is automatically
enabled when C<LimitOutput> is used.  When the input buffer has been
exhausted, the outer loop can run again and overwrite a now empty
C<$input>.

=back

=head1 ACCESSING ZIP FILES

Although it is possible (with some effort on your part) to use this module
to access .zip files, there are other perl modules available that will do
all the hard work for you. Check out C<Archive::Zip>,
C<Archive::Zip::SimpleZip>, C<IO::Compress::Zip> and
C<IO::Uncompress::Unzip>.

=head1 FAQ

=head2 Compatibility with Unix compress/uncompress.

This module is not compatible with Unix C<compress>.

If you have the C<uncompress> program available, you can use this to read
compressed files

    open F, "uncompress -c $filename |";
    while (<F>)
    {
        ...

Alternatively, if you have the C<gunzip> program available, you can use
this to read compressed files

    open F, "gunzip -c $filename |";
    while (<F>)
    {
        ...

and this to write compress files, if you have the C<compress> program
available

    open F, "| compress -c $filename ";
    print F "data";
    ...
    close F ;

=head2 Accessing .tar.Z files

See previous FAQ item.

If the C<Archive::Tar> module is installed and either the C<uncompress> or
C<gunzip> programs are available, you can use one of these workarounds to
read C<.tar.Z> files.

Firstly with C<uncompress>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "uncompress -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

and this with C<gunzip>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "gunzip -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

Similarly, if the C<compress> program is available, you can use this to
write a C<.tar.Z> file

    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File "| compress -c >$filename";
    my $tar = Archive::Tar->new();
    ...
    $tar->write($fh);
    $fh->close ;

=head2 Zlib Library Version Support

By default C<Compress::Raw::Zlib> will build with a private copy of version
1.2.5 of the zlib library. (See the F<README> file for details of
how to override this behaviour)

If you decide to use a different version of the zlib library, you need to be
aware of the following issues

=over 5

=item *

First off, you must have zlib 1.0.5 or better.

=item *

You need to have zlib 1.2.1 or better if you want to use the C<-Merge>
option with C<IO::Compress::Gzip>, C<IO::Compress::Deflate> and
C<IO::Compress::RawDeflate>.

=back

=head1 CONSTANTS

All the I<zlib> constants are automatically imported when you make use
of I<Compress::Raw::Zlib>.

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_ENDIAN_H)) {
    eval 'sub _ENDIAN_H () {1;}' unless defined(&_ENDIAN_H);
    require 'features.ph';
    eval 'sub __LITTLE_ENDIAN () {1234;}' unless defined(&__LITTLE_ENDIAN);
    eval 'sub __BIG_ENDIAN () {4321;}' unless defined(&__BIG_ENDIAN);
    eval 'sub __PDP_ENDIAN () {3412;}' unless defined(&__PDP_ENDIAN);
    require 'bits/endian.ph';
    unless(defined(&__FLOAT_WORD_ORDER)) {
	eval 'sub __FLOAT_WORD_ORDER () { &__BYTE_ORDER;}' unless defined(&__FLOAT_WORD_ORDER);
    }
    if(defined(&__USE_BSD)) {
	eval 'sub LITTLE_ENDIAN () { &__LITTLE_ENDIAN;}' unless defined(&LITTLE_ENDIAN);
	eval 'sub BIG_ENDIAN () { &__BIG_ENDIAN;}' unless defined(&BIG_ENDIAN);
	eval 'sub PDP_ENDIAN () { &__PDP_ENDIAN;}' unless defined(&PDP_ENDIAN);
	eval 'sub BYTE_ORDER () { &__BYTE_ORDER;}' unless defined(&BYTE_ORDER);
    }
    if((defined(&__BYTE_ORDER) ? &__BYTE_ORDER : undef) == (defined(&__LITTLE_ENDIAN) ? &__LITTLE_ENDIAN : undef)) {
	eval 'sub __LONG_LONG_PAIR {
	    my($HI, $LO) = @_;
    	    eval q($LO, $HI);
	}' unless defined(&__LONG_LONG_PAIR);
    }
 elsif((defined(&__BYTE_ORDER) ? &__BYTE_ORDER : undef) == (defined(&__BIG_ENDIAN) ? &__BIG_ENDIAN : undef)) {
	eval 'sub __LONG_LONG_PAIR {
	    my($HI, $LO) = @_;
    	    eval q($HI, $LO);
	}' unless defined(&__LONG_LONG_PAIR);
    }
    if(defined (&__USE_BSD)  && !defined (&__ASSEMBLER__)) {
	require 'bits/byteswap.ph';
	if((defined(&__BYTE_ORDER) ? &__BYTE_ORDER : undef) == (defined(&__LITTLE_ENDIAN) ? &__LITTLE_ENDIAN : undef)) {
	    eval 'sub htobe16 {
	        my($x) = @_;
    		eval q( &__bswap_16 ($x));
	    }' unless defined(&htobe16);
	    eval 'sub htole16 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htole16);
	    eval 'sub be16toh {
	        my($x) = @_;
    		eval q( &__bswap_16 ($x));
	    }' unless defined(&be16toh);
	    eval 'sub le16toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&le16toh);
	    eval 'sub htobe32 {
	        my($x) = @_;
    		eval q( &__bswap_32 ($x));
	    }' unless defined(&htobe32);
	    eval 'sub htole32 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htole32);
	    eval 'sub be32toh {
	        my($x) = @_;
    		eval q( &__bswap_32 ($x));
	    }' unless defined(&be32toh);
	    eval 'sub le32toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&le32toh);
	    eval 'sub htobe64 {
	        my($x) = @_;
    		eval q( &__bswap_64 ($x));
	    }' unless defined(&htobe64);
	    eval 'sub htole64 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htole64);
	    eval 'sub be64toh {
	        my($x) = @_;
    		eval q( &__bswap_64 ($x));
	    }' unless defined(&be64toh);
	    eval 'sub le64toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&le64toh);
	} else {
	    eval 'sub htobe16 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htobe16);
	    eval 'sub htole16 {
	        my($x) = @_;
    		eval q( &__bswap_16 ($x));
	    }' unless defined(&htole16);
	    eval 'sub be16toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&be16toh);
	    eval 'sub le16toh {
	        my($x) = @_;
    		eval q( &__bswap_16 ($x));
	    }' unless defined(&le16toh);
	    eval 'sub htobe32 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htobe32);
	    eval 'sub htole32 {
	        my($x) = @_;
    		eval q( &__bswap_32 ($x));
	    }' unless defined(&htole32);
	    eval 'sub be32toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&be32toh);
	    eval 'sub le32toh {
	        my($x) = @_;
    		eval q( &__bswap_32 ($x));
	    }' unless defined(&le32toh);
	    eval 'sub htobe64 {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&htobe64);
	    eval 'sub htole64 {
	        my($x) = @_;
    		eval q( &__bswap_64 ($x));
	    }' unless defined(&htole64);
	    eval 'sub be64toh {
	        my($x) = @_;
    		eval q(($x));
	    }' unless defined(&be64toh);
	    eval 'sub le64toh {
	        my($x) = @_;
    		eval q( &__bswap_64 ($x));
	    }' unless defined(&le64toh);
	}
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        package ODBM_File;

use strict;
use warnings;

require Tie::Hash;
require XSLoader;

our @ISA = qw(Tie::Hash);
our $VERSION = "1.12";

XSLoader::load();

1;

__END__

=head1 NAME

ODBM_File - Tied access to odbm files

=head1 SYNOPSIS

 use Fcntl;   # For O_RDWR, O_CREAT, etc.
 use ODBM_File;

  # Now read and change the hash
  $h{newkey} = newvalue;
  print $h{oldkey}; 
  ...

  untie %h;

=head1 DESCRIPTION

C<ODBM_File> establishes a connection between a Perl hash variable and
a file in ODBM_File format;.  You can manipulate the data in the file
just as if it were in a Perl hash, but when your program exits, the
data will remain in the file, to be used the next time your program
runs.

Use C<ODBM_File> with the Perl built-in C<tie> function to establish
the connection between the variable and the file.  The arguments to
C<tie> should be:

=over 4

=item 1.

The hash variable you want to tie.

=item 2. 

The string C<"ODBM_File">.  (Ths tells Perl to use the C<ODBM_File>
package to perform the functions of the hash.)

=item 3. 

The name of the file you want to tie to the hash.  

=item 4.

Flags.  Use one of:

=over 2

=item C<O_RDONLY>

Read-only access to the data in the file.

=item C<O_WRONLY>

Write-only access to the data in the file.

=item C<O_RDWR>

Both read and write access.

=back

If you want to create the file if it does not exist, add C<O_CREAT> to
any of these, as in the example.  If you omit C<O_CREAT> and the file
does not already exist, the C<tie> call will fail.

=item 5.

The default permissions to use if a new file is created.  The actual
permissions will be modified by the user's umask, so you should
probably use 0666 here. (See L<perlfunc/umask>.)

=back

=head1 DIAGNOSTICS

On failure, the C<tie> call returns an undefined value and probably
sets C<$!> to contain the reason the file could not be tied.

=head2 C<odbm store returned -1, errno 22, key "..." at ...>

This warning is emitted when you try to store a key or a value that
is too long.  It means that the change was not recorded in the
database.  See BUGS AND WARNINGS below.

=head1 BUGS AND WARNINGS

There are a number of limits on the size of the data that you can
store in the ODBM file.  The most important is that the length of a
key, plus the length of its associated value, may not exceed 1008
bytes.

See L<perlfunc/tie>, L<perldbmfilter>, L<Fcntl>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_STDARG_H)) {
    unless(defined(&_ANSI_STDARG_H_)) {
	unless(defined(&__need___va_list)) {
	    eval 'sub _STDARG_H () {1;}' unless defined(&_STDARG_H);
	    eval 'sub _ANSI_STDARG_H_ () {1;}' unless defined(&_ANSI_STDARG_H_);
	}
	undef(&__need___va_list) if defined(&__need___va_list);
	unless(defined(&__GNUC_VA_LIST)) {
	    eval 'sub __GNUC_VA_LIST () {1;}' unless defined(&__GNUC_VA_LIST);
	}
	if(defined(&_STDARG_H)) {
	    eval 'sub va_start {
	        my($v,$l) = @_;
    		eval q( &__builtin_va_start($v,$l));
	    }' unless defined(&va_start);
	    eval 'sub va_end {
	        my($v) = @_;
    		eval q( &__builtin_va_end($v));
	    }' unless defined(&va_end);
	    eval 'sub va_arg {
	        my($v,$l) = @_;
    		eval q( &__builtin_va_arg($v,$l));
	    }' unless defined(&va_arg);
	    if(!defined(&__STRICT_ANSI__) || (defined(&__STDC_VERSION__) ? &__STDC_VERSION__ : undef) + 0>= 199900 || defined(&__GXX_EXPERIMENTAL_CXX0X__)) {
		eval 'sub va_copy {
		    my($d,$s) = @_;
    		    eval q( &__builtin_va_copy($d,$s));
		}' unless defined(&va_copy);
	    }
	    eval 'sub __va_copy {
	        my($d,$s) = @_;
    		eval q( &__builtin_va_copy($d,$s));
	    }' unless defined(&__va_copy);
	    if(defined(&_BSD_VA_LIST)) {
		undef(&_BSD_VA_LIST) if defined(&_BSD_VA_LIST);
	    }
	    if(defined(&__svr4__) || (defined(&_SCO_DS)  && !defined(&__VA_LIST))) {
		unless(defined(&_VA_LIST_)) {
		    eval 'sub _VA_LIST_ () {1;}' unless defined(&_VA_LIST_);
		    if(defined(&__i860__)) {
			unless(defined(&_VA_LIST)) {
			    eval 'sub _VA_LIST () { &va_list;}' unless defined(&_VA_LIST);
			}
		    }
		    if(defined(&_SCO_DS)) {
			eval 'sub __VA_LIST () {1;}' unless defined(&__VA_LIST);
		    }
		}
	    } else {
		if(!defined (&_VA_LIST_) || defined (&__BSD_NET2__) || defined (&____386BSD____) || defined (&__bsdi__) || defined (&__sequent__) || defined (&__FreeBSD__) || defined(&WINNT)) {
		    unless(defined(&_VA_LIST_DEFINED)) {
			unless(defined(&_VA_LIST)) {
			    unless(defined(&_VA_LIST_T_H)) {
				unless(defined(&__va_list__)) {
				}
			    }
			}
		    }
		    if(!(defined (&__BSD_NET2__) || defined (&____386BSD____) || defined (&__bsdi__) || defined (&__sequent__) || defined (&__FreeBSD__))) {
			eval 'sub _VA_LIST_ () {1;}' unless defined(&_VA_LIST_);
		    }
		    unless(defined(&_VA_LIST)) {
			eval 'sub _VA_LIST () {1;}' unless defined(&_VA_LIST);
		    }
		    unless(defined(&_VA_LIST_DEFINED)) {
			eval 'sub _VA_LIST_DEFINED () {1;}' unless defined(&_VA_LIST_DEFINED);
		    }
		    unless(defined(&_VA_LIST_T_H)) {
			eval 'sub _VA_LIST_T_H () {1;}' unless defined(&_VA_LIST_T_H);
		    }
		    unless(defined(&__va_list__)) {
			eval 'sub __va_list__ () {1;}' unless defined(&__va_list__);
		    }
		}
	    }
	}
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package Time::HiRes;

{ use 5.006; }
use strict;

require Exporter;
require DynaLoader;

our @ISA = qw(Exporter DynaLoader);

our @EXPORT = qw( );
our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
		 getitimer setitimer nanosleep clock_gettime clock_getres
		 clock clock_nanosleep
		 CLOCK_HIGHRES CLOCK_MONOTONIC CLOCK_PROCESS_CPUTIME_ID
		 CLOCK_REALTIME CLOCK_SOFTTIME CLOCK_THREAD_CPUTIME_ID
		 CLOCK_TIMEOFDAY CLOCKS_PER_SEC
		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
		 TIMER_ABSTIME
		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
		 d_nanosleep d_clock_gettime d_clock_getres
		 d_clock d_clock_nanosleep
		 stat lstat
		);

our $VERSION = '1.9726';
our $XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

our $AUTOLOAD;
sub AUTOLOAD {
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    # print "AUTOLOAD: constname = $constname ($AUTOLOAD)\n";
    die "&Time::HiRes::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    # print "AUTOLOAD: error = $error, val = $val\n";
    if ($error) {
        my (undef,$file,$line) = caller;
        die "$error at $file line $line.\n";
    }
    {
	no strict 'refs';
	*$AUTOLOAD = sub { $val };
    }
    goto &$AUTOLOAD;
}

sub import {
    my $this = shift;
    for my $i (@_) {
	if (($i eq 'clock_getres'    && !&d_clock_getres)    ||
	    ($i eq 'clock_gettime'   && !&d_clock_gettime)   ||
	    ($i eq 'clock_nanosleep' && !&d_clock_nanosleep) ||
	    ($i eq 'clock'           && !&d_clock)           ||
	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
	    ($i eq 'usleep'          && !&d_usleep)          ||
	    ($i eq 'ualarm'          && !&d_ualarm)) {
	    require Carp;
	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
	}
    }
    Time::HiRes->export_to_level(1, $this, @_);
}

bootstrap Time::HiRes;

# Preloaded methods go here.

sub tv_interval {
    # probably could have been done in C
    my ($a, $b) = @_;
    $b = [gettimeofday()] unless defined($b);
    (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);
}

# Autoload methods go after =cut, and are processed by the autosplit program.

1;
__END__

=head1 NAME

Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers

=head1 SYNOPSIS

  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
		      clock_gettime clock_getres clock_nanosleep clock
                      stat lstat );

  usleep ($microseconds);
  nanosleep ($nanoseconds);

  ualarm ($microseconds);
  ualarm ($microseconds, $interval_microseconds);

  $t0 = [gettimeofday];
  ($seconds, $microseconds) = gettimeofday;

  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
  $elapsed = tv_interval ( $t0, [gettimeofday]);
  $elapsed = tv_interval ( $t0 );

  use Time::HiRes qw ( time alarm sleep );

  $now_fractions = time;
  sleep ($floating_seconds);
  alarm ($floating_seconds);
  alarm ($floating_seconds, $floating_interval);

  use Time::HiRes qw( setitimer getitimer );

  setitimer ($which, $floating_seconds, $floating_interval );
  getitimer ($which);

  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );

  $realtime   = clock_gettime(CLOCK_REALTIME);
  $resolution = clock_getres(CLOCK_REALTIME);

  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);

  my $ticktock = clock();

  use Time::HiRes qw( stat lstat );

  my @stat = stat("file");
  my @stat = stat(FH);
  my @stat = lstat("file");

=head1 DESCRIPTION

The C<Time::HiRes> module implements a Perl interface to the
C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
C<setitimer>/C<getitimer> system calls, in other words, high
resolution time and timers. See the L</EXAMPLES> section below and the
test scripts for usage; see your system documentation for the
description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
C<gettimeofday>, and C<setitimer>/C<getitimer> calls.

If your system lacks C<gettimeofday()> or an emulation of it you don't
get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
If your system lacks all of C<nanosleep()>, C<usleep()>,
C<select()>, and C<poll>, you don't get C<Time::HiRes::usleep()>,
C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.
If your system lacks both C<ualarm()> and C<setitimer()> you don't get
C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.

If you try to import an unimplemented function in the C<use> statement
it will fail at compile time.

If your subsecond sleeping is implemented with C<nanosleep()> instead
of C<usleep()>, you can mix subsecond sleeping with signals since
C<nanosleep()> does not use signals.  This, however, is not portable,
and you should first check for the truth value of
C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
then carefully read your C<nanosleep()> C API documentation for any
peculiarities.

If you are using C<nanosleep> for something else than mixing sleeping
with signals, give some thought to whether Perl is the tool you should
be using for work requiring nanosecond accuracies.

Remember that unless you are working on a I<hard realtime> system,
any clocks and timers will be imprecise, especially so if you are working
in a pre-emptive multiuser system.  Understand the difference between
I<wallclock time> and process time (in UNIX-like systems the sum of
I<user> and I<system> times).  Any attempt to sleep for X seconds will
most probably end up sleeping B<more> than that, but don't be surprised
if you end up sleeping slightly B<less>.

The following functions can be imported from this module.
No functions are exported by default.

=over 4

=item gettimeofday ()

In array context returns a two-element array with the seconds and
microseconds since the epoch.  In scalar context returns floating
seconds like C<Time::HiRes::time()> (see below).

=item usleep ( $useconds )

Sleeps for the number of microseconds (millionths of a second)
specified.  Returns the number of microseconds actually slept.
Can sleep for more than one second, unlike the C<usleep> system call.
Can also sleep for zero seconds, which often works like a I<thread yield>.
See also C<Time::HiRes::usleep()>, C<Time::HiRes::sleep()>, and
C<Time::HiRes::clock_nanosleep()>.

Do not expect usleep() to be exact down to one microsecond.

=item nanosleep ( $nanoseconds )

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept (accurate only to
microseconds, the nearest thousand of them).  Can sleep for more than
one second.  Can also sleep for zero seconds, which often works like
a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::clock_nanosleep()>.

Do not expect nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item ualarm ( $useconds [, $interval_useconds ] )

Issues a C<ualarm> call; the C<$interval_useconds> is optional and
will be zero if unspecified, resulting in C<alarm>-like behaviour.

Returns the remaining time in the alarm in microseconds, or C<undef>
if an error occurred.

ualarm(0) will cancel an outstanding ualarm().

Note that the interaction between alarms and sleeps is unspecified.

=item tv_interval 

tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )

Returns the floating seconds between the two times, which should have
been returned by C<gettimeofday()>. If the second argument is omitted,
then the current time is used.

=item time ()

Returns a floating seconds since the epoch. This function can be
imported, resulting in a nice drop-in replacement for the C<time>
provided with core Perl; see the L</EXAMPLES> below.

B<NOTE 1>: This higher resolution timer can return values either less
or more than the core C<time()>, depending on whether your platform
rounds the higher resolution timer values up, down, or to the nearest second
to get the core C<time()>, but naturally the difference should be never
more than half a second.  See also L</clock_getres>, if available
in your system.

B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
the C<time()> seconds since epoch rolled over to 1_000_000_000, the
default floating point format of Perl and the seconds since epoch have
conspired to produce an apparent bug: if you print the value of
C<Time::HiRes::time()> you seem to be getting only five decimals, not
six as promised (microseconds).  Not to worry, the microseconds are
there (assuming your platform supports such granularity in the first
place).  What is going on is that the default floating point format of
Perl only outputs 15 digits.  In this case that means ten digits
before the decimal separator and five after.  To see the microseconds
you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
C<gettimeofday()> function in list context, which will give you the
seconds and microseconds as two separate values.

=item sleep ( $floating_seconds )

Sleeps for the specified amount of seconds.  Returns the number of
seconds actually slept (a floating point value).  This function can
be imported, resulting in a nice drop-in replacement for the C<sleep>
provided with perl, see the L</EXAMPLES> below.

Note that the interaction between alarms and sleeps is unspecified.

=item alarm ( $floating_seconds [, $interval_floating_seconds ] )

The C<SIGALRM> signal is sent after the specified number of seconds.
Implemented using C<setitimer()> if available, C<ualarm()> if not.
The C<$interval_floating_seconds> argument is optional and will be
zero if unspecified, resulting in C<alarm()>-like behaviour.  This
function can be imported, resulting in a nice drop-in replacement for
the C<alarm> provided with perl, see the L</EXAMPLES> below.

Returns the remaining time in the alarm in seconds, or C<undef>
if an error occurred.

B<NOTE 1>: With some combinations of operating systems and Perl
releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
This means that an C<alarm()> followed by a C<select()> may together
take the sum of the times specified for the C<alarm()> and the
C<select()>, not just the time of the C<alarm()>.

Note that the interaction between alarms and sleeps is unspecified.

=item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )

Start up an interval timer: after a certain time, a signal ($which) arrives,
and more signals may keep arriving at certain intervals.  To disable
an "itimer", use C<$floating_seconds> of zero.  If the
C<$interval_floating_seconds> is set to zero (or unspecified), the
timer is disabled B<after> the next delivered signal.

Use of interval timers may interfere with C<alarm()>, C<sleep()>,
and C<usleep()>.  In standard-speak the "interaction is unspecified",
which means that I<anything> may happen: it may work, it may not.

In scalar context, the remaining time in the timer is returned.

In list context, both the remaining time and the interval are returned.

There are usually three or four interval timers (signals) available: the
C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
C<ITIMER_REALPROF>.  Note that which ones are available depends: true
UNIX platforms usually have the first three, but only Solaris seems to
have C<ITIMER_REALPROF> (which is used to profile multithreaded programs).
Win32 unfortunately does not have interval timers.

C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
the timer expires.

C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
only when the process is running.  In multiprocessor/user/CPU systems
this may be more or less than real or wallclock time.  (This time is
also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
timer expires.

C<ITIMER_PROF> counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as I/O).
(This time is also known as the I<system time>.)  (The sum of user
time and system time is known as the I<CPU time>.)  C<SIGPROF> is
delivered when the timer expires.  C<SIGPROF> can interrupt system calls.

The semantics of interval timers for multithreaded programs are
system-specific, and some systems may support additional interval
timers.  For example, it is unspecified which thread gets the signals.
See your C<setitimer()> documentation.

=item getitimer ( $which )

Return the remaining time in the interval timer specified by C<$which>.

In scalar context, the remaining time is returned.

In list context, both the remaining time and the interval are returned.
The interval is always what you put in using C<setitimer()>.

=item clock_gettime ( $which )

Return as seconds the current value of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, which is supposed to return results close to the
results of C<gettimeofday>, or the number of seconds since 00:00:00:00
January 1, 1970 Greenwich Mean Time (GMT).  Do not assume that
CLOCK_REALTIME is zero, it might be one, or something else.
Another potentially useful (but not available everywhere) value is
C<CLOCK_MONOTONIC>, which guarantees a monotonically increasing time
value (unlike time() or gettimeofday(), which can be adjusted).
See your system documentation for other possibly supported values.

=item clock_getres ( $which )

Return as seconds the resolution of the POSIX high resolution timer
specified by C<$which>.  All implementations that support POSIX high
resolution timers are supposed to support at least the C<$which> value
of C<CLOCK_REALTIME>, see L</clock_gettime>.

=item clock_nanosleep ( $which, $nanoseconds, $flags = 0)

Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept.  The $which is the
"clock id", as with clock_gettime() and clock_getres().  The flags
default to zero but C<TIMER_ABSTIME> can specified (must be exported
explicitly) which means that C<$nanoseconds> is not a time interval
(as is the default) but instead an absolute time.  Can sleep for more
than one second.  Can also sleep for zero seconds, which often works
like a I<thread yield>.  See also C<Time::HiRes::sleep()>,
C<Time::HiRes::usleep()>, and C<Time::HiRes::nanosleep()>.

Do not expect clock_nanosleep() to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.

=item clock()

Return as seconds the I<process time> (user + system time) spent by
the process since the first call to clock() (the definition is B<not>
"since the start of the process", though if you are lucky these times
may be quite close to each other, depending on the system).  What this
means is that you probably need to store the result of your first call
to clock(), and subtract that value from the following results of clock().

The time returned also includes the process times of the terminated
child processes for which wait() has been executed.  This value is
somewhat like the second value returned by the times() of core Perl,
but not necessarily identical.  Note that due to backward
compatibility limitations the returned value may wrap around at about
2147 seconds or at about 36 minutes.

=item stat

=item stat FH

=item stat EXPR

=item lstat

=item lstat FH

=item lstat EXPR

As L<perlfunc/stat> or L<perlfunc/lstat>
but with the access/modify/change file timestamps
in subsecond resolution, if the operating system and the filesystem
both support such timestamps.  To override the standard stat():

    use Time::HiRes qw(stat);

Test for the value of &Time::HiRes::d_hires_stat to find out whether
the operating system supports subsecond file timestamps: a value
larger than zero means yes. There are unfortunately no easy
ways to find out whether the filesystem supports such timestamps.
UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp
granularity is B<two> seconds).

A zero return value of &Time::HiRes::d_hires_stat means that
Time::HiRes::stat is a no-op passthrough for CORE::stat()
(and likewise for lstat),
and therefore the timestamps will stay integers.  The same
thing will happen if the filesystem does not do subsecond timestamps,
even if the &Time::HiRes::d_hires_stat is non-zero.

In any case do not expect nanosecond resolution, or even a microsecond
resolution.  Also note that the modify/access timestamps might have
different resolutions, and that they need not be synchronized, e.g.
if the operations are

    write
    stat # t1
    read
    stat # t2

the access time stamp from t2 need not be greater-than the modify
time stamp from t1: it may be equal or I<less>.

=back

=head1 EXAMPLES

  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

  $microseconds = 750_000;
  usleep($microseconds);

  # signal alarm in 2.5s & every .1s thereafter
  ualarm(2_500_000, 100_000);
  # cancel that ualarm
  ualarm(0);

  # get seconds and microseconds since the epoch
  ($s, $usec) = gettimeofday();

  # measure elapsed time 
  # (could also do by subtracting 2 gettimeofday return values)
  $t0 = [gettimeofday];
  # do bunch of stuff here
  $t1 = [gettimeofday];
  # do more stuff here
  $t0_t1 = tv_interval $t0, $t1;

  $elapsed = tv_interval ($t0, [gettimeofday]);
  $elapsed = tv_interval ($t0);	# equivalent code

  #
  # replacements for time, alarm and sleep that know about
  # floating seconds
  #
  use Time::HiRes;
  $now_fractions = Time::HiRes::time;
  Time::HiRes::sleep (2.5);
  Time::HiRes::alarm (10.6666666);

  use Time::HiRes qw ( time alarm sleep );
  $now_fractions = time;
  sleep (2.5);
  alarm (10.6666666);

  # Arm an interval timer to go off first at 10 seconds and
  # after that every 2.5 seconds, in process virtual time

  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

  $SIG{VTALRM} = sub { print time, "\n" };
  setitimer(ITIMER_VIRTUAL, 10, 2.5);

  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
  # Read the POSIX high resolution timer.
  my $high = clock_gettime(CLOCK_REALTIME);
  # But how accurate we can be, really?
  my $reso = clock_getres(CLOCK_REALTIME);

  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
  clock_nanosleep(CLOCK_REALTIME, 1e6);
  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

  use Time::HiRes qw( clock );
  my $clock0 = clock();
  ... # Do something.
  my $clock1 = clock();
  my $clockd = $clock1 - $clock0;

  use Time::HiRes qw( stat );
  my ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];

=head1 C API

In addition to the perl API described above, a C API is available for
extension writers.  The following C functions are available in the
modglobal hash:

  name             C prototype
  ---------------  ----------------------
  Time::NVtime     double (*)()
  Time::U2time     void (*)(pTHX_ UV ret[2])

Both functions return equivalent information (like C<gettimeofday>)
but with different representations.  The names C<NVtime> and C<U2time>
were selected mainly because they are operating system independent.
(C<gettimeofday> is Unix-centric, though some platforms like Win32 and
VMS have emulations for it.)

Here is an example of using C<NVtime> from C:

  double (*myNVtime)(); /* Returns -1 on failure. */
  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  if (!svp)         croak("Time::HiRes is required");
  if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
  myNVtime = INT2PTR(double(*)(), SvIV(*svp));
  printf("The current time is: %f\n", (*myNVtime)());

=head1 DIAGNOSTICS

=head2 useconds or interval more than ...

In ualarm() you tried to use number of microseconds or interval (also
in microseconds) more than 1_000_000 and setitimer() is not available
in your system to emulate that case.

=head2 negative time not invented yet

You tried to use a negative time argument.

=head2 internal error: useconds < 0 (unsigned ... signed ...)

Something went horribly wrong-- the number of microseconds that cannot
become negative just became negative.  Maybe your compiler is broken?

=head2 useconds or uinterval equal to or more than 1000000

In some platforms it is not possible to get an alarm with subsecond
resolution and later than one second.

=head2 unimplemented in this platform

Some calls simply aren't available, real or emulated, on every platform.

=head1 CAVEATS

Notice that the core C<time()> maybe rounding rather than truncating.
What this means is that the core C<time()> may be reporting the time
as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.

Adjusting the system clock (either manually or by services like ntp)
may cause problems, especially for long running programs that assume
a monotonously increasing time (note that all platforms do not adjust
time as gracefully as UNIX ntp does).  For example in Win32 (and derived
platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
drift off from the system clock (and the original time())  by up to 0.5
seconds. Time::HiRes will notice this eventually and recalibrate.
Note that since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC)
might help in this (in case your system supports CLOCK_MONOTONIC).

Some systems have APIs but not implementations: for example QNX and Haiku
have the interval timer APIs but not the functionality.

=head1 SEE ALSO

Perl modules L<BSD::Resource>, L<Time::TAI64>.

Your system documentation for C<clock>, C<clock_gettime>,
C<clock_getres>, C<clock_nanosleep>, C<clock_settime>, C<getitimer>,
C<gettimeofday>, C<setitimer>, C<sleep>, C<stat>, C<ualarm>.

=head1 AUTHORS

D. Wegscheid <wegscd@whirlpool.com>
R. Schertler <roderick@argon.org>
J. Hietaniemi <jhi@iki.fi>
G. Aas <gisle@aas.no>

=head1 COPYRIGHT AND LICENSE

Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.

Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi.
All rights reserved.

Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         package Time::Seconds;
use strict;
use vars qw/@EXPORT @EXPORT_OK/;

our $VERSION = '1.27';

use Exporter 5.57 'import';

@EXPORT = qw(
    ONE_MINUTE 
    ONE_HOUR 
    ONE_DAY 
    ONE_WEEK 
    ONE_MONTH
    ONE_REAL_MONTH
    ONE_YEAR
    ONE_REAL_YEAR
    ONE_FINANCIAL_MONTH
    LEAP_YEAR 
    NON_LEAP_YEAR
);

@EXPORT_OK = qw(cs_sec cs_mon);

use constant ONE_MINUTE => 60;
use constant ONE_HOUR => 3_600;
use constant ONE_DAY => 86_400;
use constant ONE_WEEK => 604_800;
use constant ONE_MONTH => 2_629_744; # ONE_YEAR / 12
use constant ONE_REAL_MONTH => '1M';
use constant ONE_YEAR => 31_556_930; # 365.24225 days
use constant ONE_REAL_YEAR  => '1Y';
use constant ONE_FINANCIAL_MONTH => 2_592_000; # 30 days
use constant LEAP_YEAR => 31_622_400; # 366 * ONE_DAY
use constant NON_LEAP_YEAR => 31_536_000; # 365 * ONE_DAY

# hacks to make Time::Piece compile once again
use constant cs_sec => 0;
use constant cs_mon => 1;

use overload 
                'fallback' => 'undef',
                '0+' => \&seconds,
                '""' => \&seconds,
                '<=>' => \&compare,
                '+' => \&add,
                '-' => \&subtract,
                '-=' => \&subtract_from,
                '+=' => \&add_to,
                '=' => \&copy;

sub new {
    my $class = shift;
    my ($val) = @_;
    $val = 0 unless defined $val;
    bless \$val, $class;
}

sub _get_ovlvals {
    my ($lhs, $rhs, $reverse) = @_;
    $lhs = $lhs->seconds;

    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }
    elsif (ref($rhs)) {
        die "Can't use non Seconds object in operator overload";
    }

    if ($reverse) {
        return $rhs, $lhs;
    }

    return $lhs, $rhs;
}

sub compare {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return $lhs <=> $rhs;
}

sub add {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return Time::Seconds->new($lhs + $rhs);
}

sub add_to {
    my $lhs = shift;
    my $rhs = shift;
    $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
    $$lhs += $rhs;
    return $lhs;
}

sub subtract {
    my ($lhs, $rhs) = _get_ovlvals(@_);
    return Time::Seconds->new($lhs - $rhs);
}

sub subtract_from {
    my $lhs = shift;
    my $rhs = shift;
    $rhs = $rhs->seconds if UNIVERSAL::isa($rhs, 'Time::Seconds');
    $$lhs -= $rhs;
    return $lhs;
}

sub copy {
	Time::Seconds->new(${$_[0]});
}

sub seconds {
    my $s = shift;
    return $$s;
}

sub minutes {
    my $s = shift;
    return $$s / 60;
}

sub hours {
    my $s = shift;
    $s->minutes / 60;
}

sub days {
    my $s = shift;
    $s->hours / 24;
}

sub weeks {
    my $s = shift;
    $s->days / 7;
}

sub months {
    my $s = shift;
    $s->days / 30.4368541;
}

sub financial_months {
    my $s = shift;
    $s->days / 30;
}

sub years {
    my $s = shift;
    $s->days / 365.24225;
}

sub pretty {
    my $s = shift;
    my $str = "";
    if ($s < 0) {
        $s = -$s;
        $str = "minus ";
    }
    if ($s >= ONE_MINUTE) {
        if ($s >= ONE_HOUR) {
            if ($s >= ONE_DAY) {
                my $days = sprintf("%d", $s->days); # does a "floor"
                $str = $days . " days, ";
                $s -= ($days * ONE_DAY);
            }
            my $hours = sprintf("%d", $s->hours);
            $str .= $hours . " hours, ";
            $s -= ($hours * ONE_HOUR);
        }
        my $mins = sprintf("%d", $s->minutes);
        $str .= $mins . " minutes, ";
        $s -= ($mins * ONE_MINUTE);
    }
    $str .= $s->seconds . " seconds";
    return $str;
}

1;
__END__

=encoding utf8

=head1 NAME

Time::Seconds - a simple API to convert seconds to other date values

=head1 SYNOPSIS

    use Time::Piece;
    use Time::Seconds;
    
    my $t = localtime;
    $t += ONE_DAY;
    
    my $t2 = localtime;
    my $s = $t - $t2;
    
    print "Difference is: ", $s->days, "\n";

=head1 DESCRIPTION

This module is part of the Time::Piece distribution. It allows the user
to find out the number of minutes, hours, days, weeks or years in a given
number of seconds. It is returned by Time::Piece when you delta two
Time::Piece objects.

Time::Seconds also exports the following constants:

    ONE_DAY
    ONE_WEEK
    ONE_HOUR
    ONE_MINUTE
    ONE_MONTH
    ONE_YEAR
    ONE_FINANCIAL_MONTH
    LEAP_YEAR
    NON_LEAP_YEAR

Since perl does not (yet?) support constant objects, these constants are in
seconds only, so you cannot, for example, do this: C<print ONE_WEEK-E<gt>minutes;>

=head1 METHODS

The following methods are available:

    my $val = Time::Seconds->new(SECONDS)
    $val->seconds;
    $val->minutes;
    $val->hours;
    $val->days;
    $val->weeks;
	$val->months;
	$val->financial_months; # 30 days
    $val->years;
    $val->pretty; # gives English representation of the delta

The usual arithmetic (+,-,+=,-=) is also available on the objects.

The methods make the assumption that there are 24 hours in a day, 7 days in
a week, 365.24225 days in a year and 12 months in a year.
(from The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)

=head1 AUTHOR

Matt Sergeant, matt@sergeant.org

Tobias Brox, tobiasb@tobiasb.funcom.com

Balzs Szab (dLux), dlux@kapu.hu

=head1 COPYRIGHT AND LICENSE

Copyright 2001, Larry Wall.

This module is free software, you may distribute it under the same terms
as Perl.

=head1 Bugs

Currently the methods aren't as efficient as they could be, for reasons of
clarity. This is probably a bad idea.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         package Time::Piece;

use strict;

require Exporter;
require DynaLoader;
use Time::Seconds;
use Carp;
use Time::Local;

our @ISA = qw(Exporter DynaLoader);

our @EXPORT = qw(
    localtime
    gmtime
);

our %EXPORT_TAGS = (
    ':override' => 'internal',
    );

our $VERSION = '1.27';

bootstrap Time::Piece $VERSION;

my $DATE_SEP = '-';
my $TIME_SEP = ':';
my @MON_LIST = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
my @FULLMON_LIST = qw(January February March April May June July
                      August September October November December);
my @DAY_LIST = qw(Sun Mon Tue Wed Thu Fri Sat);
my @FULLDAY_LIST = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);

use constant 'c_sec' => 0;
use constant 'c_min' => 1;
use constant 'c_hour' => 2;
use constant 'c_mday' => 3;
use constant 'c_mon' => 4;
use constant 'c_year' => 5;
use constant 'c_wday' => 6;
use constant 'c_yday' => 7;
use constant 'c_isdst' => 8;
use constant 'c_epoch' => 9;
use constant 'c_islocal' => 10;

sub localtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class->_mktime($time, 1);
}

sub gmtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]->isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class->_mktime($time, 0);
}

sub new {
    my $class = shift;
    my ($time) = @_;
    
    my $self;
    
    if (defined($time)) {
        $self = $class->localtime($time);
    }
    elsif (ref($class) && $class->isa(__PACKAGE__)) {
        $self = $class->_mktime($class->epoch, $class->[c_islocal]);
    }
    else {
        $self = $class->localtime();
    }
    
    return bless $self, ref($class) || $class;
}

sub parse {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my @components;
    if (@_ > 1) {
        @components = @_;
    }
    else {
        @components = shift =~ /(\d+)$DATE_SEP(\d+)$DATE_SEP(\d+)(?:(?:T|\s+)(\d+)$TIME_SEP(\d+)(?:$TIME_SEP(\d+)))/;
        @components = reverse(@components[0..5]);
    }
    return $class->new(_strftime("%s", @components));
}

sub _mktime {
    my ($class, $time, $islocal) = @_;
    $class = eval { (ref $class) && (ref $class)->isa('Time::Piece') }
           ? ref $class
           : $class;
    if (ref($time)) {
        $time->[c_epoch] = undef;
        return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
    }
    _tzset();
    my @time = $islocal ?
            CORE::localtime($time)
                :
            CORE::gmtime($time);
    wantarray ? @time : bless [@time, $time, $islocal], $class;
}

my %_special_exports = (
  localtime => sub { my $c = $_[0]; sub { $c->localtime(@_) } },
  gmtime    => sub { my $c = $_[0]; sub { $c->gmtime(@_)    } },
);

sub export {
  my ($class, $to, @methods) = @_;
  for my $method (@methods) {
    if (exists $_special_exports{$method}) {
      no strict 'refs';
      no warnings 'redefine';
      *{$to . "::$method"} = $_special_exports{$method}->($class);
    } else {
      $class->SUPER::export($to, $method);
    }
  }
}

sub import {
    # replace CORE::GLOBAL localtime and gmtime if required
    my $class = shift;
    my %params;
    map($params{$_}++,@_,@EXPORT);
    if (delete $params{':override'}) {
        $class->export('CORE::GLOBAL', keys %params);
    }
    else {
        $class->export((caller)[0], keys %params);
    }
}

## Methods ##

sub sec {
    my $time = shift;
    $time->[c_sec];
}

*second = \&sec;

sub min {
    my $time = shift;
    $time->[c_min];
}

*minute = \&min;

sub hour {
    my $time = shift;
    $time->[c_hour];
}

sub mday {
    my $time = shift;
    $time->[c_mday];
}

*day_of_month = \&mday;

sub mon {
    my $time = shift;
    $time->[c_mon] + 1;
}

sub _mon {
    my $time = shift;
    $time->[c_mon];
}

sub month {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_mon]];
    }
    elsif (@MON_LIST) {
        return $MON_LIST[$time->[c_mon]];
    }
    else {
        return $time->strftime('%b');
    }
}

*monname = \&month;

sub fullmonth {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_mon]];
    }
    elsif (@FULLMON_LIST) {
        return $FULLMON_LIST[$time->[c_mon]];
    }
    else {
        return $time->strftime('%B');
    }
}

sub year {
    my $time = shift;
    $time->[c_year] + 1900;
}

sub _year {
    my $time = shift;
    $time->[c_year];
}

sub yy {
    my $time = shift;
    my $res = $time->[c_year] % 100;
    return $res > 9 ? $res : "0$res";
}

sub wday {
    my $time = shift;
    $time->[c_wday] + 1;
}

sub _wday {
    my $time = shift;
    $time->[c_wday];
}

*day_of_week = \&_wday;

sub wdayname {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_wday]];
    }
    elsif (@DAY_LIST) {
        return $DAY_LIST[$time->[c_wday]];
    }
    else {
        return $time->strftime('%a');
    }
}

*day = \&wdayname;

sub fullday {
    my $time = shift;
    if (@_) {
        return $_[$time->[c_wday]];
    }
    elsif (@FULLDAY_LIST) {
        return $FULLDAY_LIST[$time->[c_wday]];
    }
    else {
        return $time->strftime('%A');
    }
}

sub yday {
    my $time = shift;
    $time->[c_yday];
}

*day_of_year = \&yday;

sub isdst {
    my $time = shift;
    $time->[c_isdst];
}

*daylight_savings = \&isdst;

# Thanks to Tony Olekshy <olekshy@cs.ualberta.ca> for this algorithm
sub tzoffset {
    my $time = shift;
    
    return Time::Seconds->new(0) unless $time->[c_islocal];

    my $epoch = $time->epoch;

    my $j = sub {

        my ($s,$n,$h,$d,$m,$y) = @_; $m += 1; $y += 1900;

        $time->_jd($y, $m, $d, $h, $n, $s);

    };

    # Compute floating offset in hours.
    #
    # Note use of crt methods so the tz is properly set...
    # See: http://perlmonks.org/?node_id=820347
    my $delta = 24 * ($j->(_crt_localtime($epoch)) - $j->(_crt_gmtime($epoch)));

    # Return value in seconds rounded to nearest minute.
    return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
}

sub epoch {
    my $time = shift;
    if (defined($time->[c_epoch])) {
        return $time->[c_epoch];
    }
    else {
        my $epoch = $time->[c_islocal] ?
          timelocal(@{$time}[c_sec .. c_mon], $time->[c_year]+1900)
          :
          timegm(@{$time}[c_sec .. c_mon], $time->[c_year]+1900);
        $time->[c_epoch] = $epoch;
        return $epoch;
    }
}

sub hms {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $TIME_SEP;
    sprintf("%02d$sep%02d$sep%02d", $time->[c_hour], $time->[c_min], $time->[c_sec]);
}

*time = \&hms;

sub ymd {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%d$sep%02d$sep%02d", $time->year, $time->mon, $time->[c_mday]);
}

*date = \&ymd;

sub mdy {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%02d$sep%02d$sep%d", $time->mon, $time->[c_mday], $time->year);
}

sub dmy {
    my $time = shift;
    my $sep = @_ ? shift(@_) : $DATE_SEP;
    sprintf("%02d$sep%02d$sep%d", $time->[c_mday], $time->mon, $time->year);
}

sub datetime {
    my $time = shift;
    my %seps = (date => $DATE_SEP, T => 'T', time => $TIME_SEP, @_);
    return join($seps{T}, $time->date($seps{date}), $time->time($seps{time}));
}



# Julian Day is always calculated for UT regardless
# of local time
sub julian_day {
    my $time = shift;
    # Correct for localtime
    $time = $time->gmtime( $time->epoch ) if $time->[c_islocal];

    # Calculate the Julian day itself
    my $jd = $time->_jd( $time->year, $time->mon, $time->mday,
                        $time->hour, $time->min, $time->sec);

    return $jd;
}

# MJD is defined as JD - 2400000.5 days
sub mjd {
    return shift->julian_day - 2_400_000.5;
}

# Internal calculation of Julian date. Needed here so that
# both tzoffset and mjd/jd methods can share the code
# Algorithm from Hatcher 1984 (QJRAS 25, 53-55), and
#  Hughes et al, 1989, MNRAS, 238, 15
# See: http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1989MNRAS.238.1529H&db_key=AST
# for more details

sub _jd {
    my $self = shift;
    my ($y, $m, $d, $h, $n, $s) = @_;

    # Adjust input parameters according to the month
    $y = ( $m > 2 ? $y : $y - 1);
    $m = ( $m > 2 ? $m - 3 : $m + 9);

    # Calculate the Julian Date (assuming Julian calendar)
    my $J = int( 365.25 *( $y + 4712) )
      + int( (30.6 * $m) + 0.5)
        + 59
          + $d
            - 0.5;

    # Calculate the Gregorian Correction (since we have Gregorian dates)
    my $G = 38 - int( 0.75 * int(49+($y/100)));

    # Calculate the actual Julian Date
    my $JD = $J + $G;

    # Modify to include hours/mins/secs in floating portion.
    return $JD + ($h + ($n + $s / 60) / 60) / 24;
}

sub week {
    my $self = shift;

    my $J  = $self->julian_day;
    # Julian day is independent of time zone so add on tzoffset
    # if we are using local time here since we want the week day
    # to reflect the local time rather than UTC
    $J += ($self->tzoffset/(24*3600)) if $self->[c_islocal];

    # Now that we have the Julian day including fractions
    # convert it to an integer Julian Day Number using nearest
    # int (since the day changes at midday we convert all Julian
    # dates to following midnight).
    $J = int($J+0.5);

    use integer;
    my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
    my $L  = $d4 / 1460;
    my $d1 = (($d4 - $L) % 365) + $L;
    return $d1 / 7 + 1;
}

sub _is_leap_year {
    my $year = shift;
    return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0)
               ? 1 : 0;
}

sub is_leap_year {
    my $time = shift;
    my $year = $time->year;
    return _is_leap_year($year);
}

my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);

sub month_last_day {
    my $time = shift;
    my $year = $time->year;
    my $_mon = $time->_mon;
    return $MON_LAST[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
}

sub strftime {
    my $time = shift;
    my $tzname = $time->[c_islocal] ? '%Z' : 'UTC';
    my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S $tzname";
    if (!defined $time->[c_wday]) {
        if ($time->[c_islocal]) {
            return _strftime($format, CORE::localtime($time->epoch));
        }
        else {
            return _strftime($format, CORE::gmtime($time->epoch));
        }
    }
    return _strftime($format, (@$time)[c_sec..c_isdst]);
}

sub strptime {
    my $time = shift;
    my $string = shift;
    my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S %Z";
    my @vals = _strptime($string, $format);
#    warn(sprintf("got vals: %d-%d-%d %d:%d:%d\n", reverse(@vals)));
    return scalar $time->_mktime(\@vals, (ref($time) ? $time->[c_islocal] : 0));
}

sub day_list {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
    my @old = @DAY_LIST;
    if (@_) {
        @DAY_LIST = @_;
    }
    return @old;
}

sub mon_list {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
    my @old = @MON_LIST;
    if (@_) {
        @MON_LIST = @_;
    }
    return @old;
}

sub time_separator {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
    my $old = $TIME_SEP;
    if (@_) {
        $TIME_SEP = $_[0];
    }
    return $old;
}

sub date_separator {
    shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
    my $old = $DATE_SEP;
    if (@_) {
        $DATE_SEP = $_[0];
    }
    return $old;
}

use overload '""' => \&cdate,
             'cmp' => \&str_compare,
             'fallback' => undef;

sub cdate {
    my $time = shift;
    if ($time->[c_islocal]) {
        return scalar(CORE::localtime($time->epoch));
    }
    else {
        return scalar(CORE::gmtime($time->epoch));
    }
}

sub str_compare {
    my ($lhs, $rhs, $reverse) = @_;
    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
        $rhs = "$rhs";
    }
    return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
}

use overload
        '-' => \&subtract,
        '+' => \&add;

sub subtract {
    my $time = shift;
    my $rhs = shift;
    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }

    if (shift)
    {
	# SWAPED is set (so someone tried an expression like NOTDATE - DATE).
	# Imitate Perl's standard behavior and return the result as if the
	# string $time resolves to was subtracted from NOTDATE.  This way,
	# classes which override this one and which have a stringify function
	# that resolves to something that looks more like a number don't need
	# to override this function.
	return $rhs - "$time";
    }
    
    if (UNIVERSAL::isa($rhs, 'Time::Piece')) {
        return Time::Seconds->new($time->epoch - $rhs->epoch);
    }
    else {
        # rhs is seconds.
        return $time->_mktime(($time->epoch - $rhs), $time->[c_islocal]);
    }
}

sub add {
    my $time = shift;
    my $rhs = shift;
    if (UNIVERSAL::isa($rhs, 'Time::Seconds')) {
        $rhs = $rhs->seconds;
    }
    croak "Invalid rhs of addition: $rhs" if ref($rhs);

    return $time->_mktime(($time->epoch + $rhs), $time->[c_islocal]);
}

use overload
        '<=>' => \&compare;

sub get_epochs {
    my ($lhs, $rhs, $reverse) = @_;
    if (!UNIVERSAL::isa($rhs, 'Time::Piece')) {
        $rhs = $lhs->new($rhs);
    }
    if ($reverse) {
        return $rhs->epoch, $lhs->epoch;
    }
    return $lhs->epoch, $rhs->epoch;
}

sub compare {
    my ($lhs, $rhs) = get_epochs(@_);
    return $lhs <=> $rhs;
}

sub add_months {
    my ($time, $num_months) = @_;
    
    croak("add_months requires a number of months") unless defined($num_months);
    
    my $final_month = $time->_mon + $num_months;
    my $num_years = 0;
    if ($final_month > 11 || $final_month < 0) {
        # these two ops required because we have no POSIX::floor and don't
        # want to load POSIX.pm
        if ($final_month < 0 && $final_month % 12 == 0) {
            $num_years = int($final_month / 12) + 1;
        }
        else {
            $num_years = int($final_month / 12);
        }
        $num_years-- if ($final_month < 0);
        
        $final_month = $final_month % 12;
    }
    
    my @vals = _mini_mktime($time->sec, $time->min, $time->hour,
                            $time->mday, $final_month, $time->year - 1900 + $num_years);
    # warn(sprintf("got %d vals: %d-%d-%d %d:%d:%d [%d]\n", scalar(@vals), reverse(@vals), $time->[c_islocal]));
    return scalar $time->_mktime(\@vals, $time->[c_islocal]);
}

sub add_years {
    my ($time, $years) = @_;
    $time->add_months($years * 12);
}

1;
__END__

=head1 NAME

Time::Piece - Object Oriented time objects

=head1 SYNOPSIS

    use Time::Piece;
    
    my $t = localtime;
    print "Time is $t\n";
    print "Year is ", $t->year, "\n";

=head1 DESCRIPTION

This module replaces the standard C<localtime> and C<gmtime> functions with
implementations that return objects. It does so in a backwards
compatible manner, so that using localtime/gmtime in the way documented
in perlfunc will still return what you expect.

The module actually implements most of an interface described by
Larry Wall on the perl5-porters mailing list here:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html

=head1 USAGE

After importing this module, when you use localtime or gmtime in a scalar
context, rather than getting an ordinary scalar string representing the
date and time, you get a Time::Piece object, whose stringification happens
to produce the same effect as the localtime and gmtime functions. There is 
also a new() constructor provided, which is the same as localtime(), except
when passed a Time::Piece object, in which case it's a copy constructor. The
following methods are available on the object:

    $t->sec                 # also available as $t->second
    $t->min                 # also available as $t->minute
    $t->hour                # 24 hour
    $t->mday                # also available as $t->day_of_month
    $t->mon                 # 1 = January
    $t->_mon                # 0 = January
    $t->monname             # Feb
    $t->month               # same as $t->monname
    $t->fullmonth           # February
    $t->year                # based at 0 (year 0 AD is, of course 1 BC)
    $t->_year               # year minus 1900
    $t->yy                  # 2 digit year
    $t->wday                # 1 = Sunday
    $t->_wday               # 0 = Sunday
    $t->day_of_week         # 0 = Sunday
    $t->wdayname            # Tue
    $t->day                 # same as wdayname
    $t->fullday             # Tuesday
    $t->yday                # also available as $t->day_of_year, 0 = Jan 01
    $t->isdst               # also available as $t->daylight_savings

    $t->hms                 # 12:34:56
    $t->hms(".")            # 12.34.56
    $t->time                # same as $t->hms

    $t->ymd                 # 2000-02-29
    $t->date                # same as $t->ymd
    $t->mdy                 # 02-29-2000
    $t->mdy("/")            # 02/29/2000
    $t->dmy                 # 29-02-2000
    $t->dmy(".")            # 29.02.2000
    $t->datetime            # 2000-02-29T12:34:56 (ISO 8601)
    $t->cdate               # Tue Feb 29 12:34:56 2000
    "$t"                    # same as $t->cdate

    $t->epoch               # seconds since the epoch
    $t->tzoffset            # timezone offset in a Time::Seconds object

    $t->julian_day          # number of days since Julian period began
    $t->mjd                 # modified Julian date (JD-2400000.5 days)

    $t->week                # week number (ISO 8601)

    $t->is_leap_year        # true if it its
    $t->month_last_day      # 28-31

    $t->time_separator($s)  # set the default separator (default ":")
    $t->date_separator($s)  # set the default separator (default "-")
    $t->day_list(@days)     # set the default weekdays
    $t->mon_list(@days)     # set the default months

    $t->strftime(FORMAT)    # same as POSIX::strftime (without the overhead
                            # of the full POSIX extension)
    $t->strftime()          # "Tue, 29 Feb 2000 12:34:56 GMT"
    
    Time::Piece->strptime(STRING, FORMAT)
                            # see strptime man page. Creates a new
                            # Time::Piece object

Note that C<localtime> and C<gmtime> are not listed above.  If called as
methods on a Time::Piece object, they act as constructors, returning a new
Time::Piece object for the current time.  In other words: they're not useful as
methods.

=head2 Local Locales

Both wdayname (day) and monname (month) allow passing in a list to use
to index the name of the days against. This can be useful if you need
to implement some form of localisation without actually installing or
using locales.

  my @days = qw( Dimanche Lundi Merdi Mercredi Jeudi Vendredi Samedi );

  my $french_day = localtime->day(@days);

These settings can be overridden globally too:

  Time::Piece::day_list(@days);

Or for months:

  Time::Piece::mon_list(@months);

And locally for months:

  print localtime->month(@months);

=head2 Date Calculations

It's possible to use simple addition and subtraction of objects:

    use Time::Seconds;
    
    my $seconds = $t1 - $t2;
    $t1 += ONE_DAY; # add 1 day (constant from Time::Seconds)

The following are valid ($t1 and $t2 are Time::Piece objects):

    $t1 - $t2; # returns Time::Seconds object
    $t1 - 42; # returns Time::Piece object
    $t1 + 533; # returns Time::Piece object

However adding a Time::Piece object to another Time::Piece object
will cause a runtime error.

Note that the first of the above returns a Time::Seconds object, so
while examining the object will print the number of seconds (because
of the overloading), you can also get the number of minutes, hours,
days, weeks and years in that delta, using the Time::Seconds API.

In addition to adding seconds, there are two APIs for adding months and
years:

    $t->add_months(6);
    $t->add_years(5);

The months and years can be negative for subtractions. Note that there
is some "strange" behaviour when adding and subtracting months at the
ends of months. Generally when the resulting month is shorter than the
starting month then the number of overlap days is added. For example
subtracting a month from 2008-03-31 will not result in 2008-02-31 as this
is an impossible date. Instead you will get 2008-03-02. This appears to
be consistent with other date manipulation tools.

=head2 Date Comparisons

Date comparisons are also possible, using the full suite of "<", ">",
"<=", ">=", "<=>", "==" and "!=".

=head2 Date Parsing

Time::Piece has a built-in strptime() function (from FreeBSD), allowing
you incredibly flexible date parsing routines. For example:

  my $t = Time::Piece->strptime("Sunday 3rd Nov, 1943",
                                "%A %drd %b, %Y");
  
  print $t->strftime("%a, %d %b %Y");

Outputs:

  Wed, 03 Nov 1943

(see, it's even smart enough to fix my obvious date bug)

For more information see "man strptime", which should be on all unix
systems.

Alternatively look here: http://www.unix.com/man-page/FreeBSD/3/strftime/

=head2 YYYY-MM-DDThh:mm:ss

The ISO 8601 standard defines the date format to be YYYY-MM-DD, and
the time format to be hh:mm:ss (24 hour clock), and if combined, they
should be concatenated with date first and with a capital 'T' in front
of the time.

=head2 Week Number

The I<week number> may be an unknown concept to some readers.  The ISO
8601 standard defines that weeks begin on a Monday and week 1 of the
year is the week that includes both January 4th and the first Thursday
of the year.  In other words, if the first Monday of January is the
2nd, 3rd, or 4th, the preceding days of the January are part of the
last week of the preceding year.  Week numbers range from 1 to 53.

=head2 Global Overriding

Finally, it's possible to override localtime and gmtime everywhere, by
including the ':override' tag in the import list:

    use Time::Piece ':override';

=head1 CAVEATS

=head2 Setting $ENV{TZ} in Threads on Win32

Note that when using perl in the default build configuration on Win32
(specifically, when perl is built with PERL_IMPLICIT_SYS), each perl
interpreter maintains its own copy of the environment and only the main
interpreter will update the process environment seen by strftime.

Therefore, if you make changes to $ENV{TZ} from inside a thread other than
the main thread then those changes will not be seen by strftime if you
subsequently call that with the %Z formatting code. You must change $ENV{TZ}
in the main thread to have the desired effect in this case (and you must
also call _tzset() in the main thread to register the environment change).

Furthermore, remember that this caveat also applies to fork(), which is
emulated by threads on Win32.

=head2 Use of epoch seconds

This module internally uses the epoch seconds system that is provided via
the perl C<time()> function and supported by C<gmtime()> and C<localtime()>.

If your perl does not support times larger than C<2^31> seconds then this
module is likely to fail at processing dates beyond the year 2038. There are
moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none
of those are options, use the L<DateTime> module which has support for years
well into the future and past.

=head1 AUTHOR

Matt Sergeant, matt@sergeant.org
Jarkko Hietaniemi, jhi@iki.fi (while creating Time::Piece for core perl)

=head1 COPYRIGHT AND LICENSE

Copyright 2001, Larry Wall.

This module is free software, you may distribute it under the same terms
as Perl.

=head1 SEE ALSO

The excellent Calendar FAQ at http://www.tondering.dk/claus/calendar.html

=head1 BUGS

The test harness leaves much to be desired. Patches welcome.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #
#  Copyright (c) 1995-2001, Raphael Manfredi
#  Copyright (c) 2002-2013 by the Perl 5 Porters
#  
#  You may redistribute only under the same terms as Perl 5, as specified
#  in the README file that comes with the distribution.
#

require XSLoader;
require Exporter;
package Storable; @ISA = qw(Exporter);

@EXPORT = qw(store retrieve);
@EXPORT_OK = qw(
	nstore store_fd nstore_fd fd_retrieve
	freeze nfreeze thaw
	dclone
	retrieve_fd
	lock_store lock_nstore lock_retrieve
        file_magic read_magic
);

use vars qw($canonical $forgive_me $VERSION);

$VERSION = '2.49_01';

BEGIN {
    if (eval {
        local $SIG{__DIE__};
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Log::Agent;
        1;
    }) {
        Log::Agent->import;
    }
    #
    # Use of Log::Agent is optional. If it hasn't imported these subs then
    # provide a fallback implementation.
    #
    unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {
        require Carp;
        *logcroak = sub {
            Carp::croak(@_);
        };
    }
    unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {
	require Carp;
        *logcarp = sub {
          Carp::carp(@_);
        };
    }
}

#
# They might miss :flock in Fcntl
#

BEGIN {
	if (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {
		Fcntl->import(':flock');
	} else {
		eval q{
			sub LOCK_SH ()	{1}
			sub LOCK_EX ()	{2}
		};
	}
}

sub CLONE {
    # clone context under threads
    Storable::init_perinterp();
}

# By default restricted hashes are downgraded on earlier perls.

$Storable::downgrade_restricted = 1;
$Storable::accept_future_minor = 1;

XSLoader::load('Storable', $Storable::VERSION);

#
# Determine whether locking is possible, but only when needed.
#

sub CAN_FLOCK; my $CAN_FLOCK; sub CAN_FLOCK {
	return $CAN_FLOCK if defined $CAN_FLOCK;
	require Config; import Config;
	return $CAN_FLOCK =
		$Config{'d_flock'} ||
		$Config{'d_fcntl_can_lock'} ||
		$Config{'d_lockf'};
}

sub show_file_magic {
    print <<EOM;
#
# To recognize the data files of the Perl module Storable,
# the following lines need to be added to the local magic(5) file,
# usually either /usr/share/misc/magic or /etc/magic.
#
0	string	perl-store	perl Storable(v0.6) data
>4	byte	>0	(net-order %d)
>>4	byte	&01	(network-ordered)
>>4	byte	=3	(major 1)
>>4	byte	=2	(major 1)

0	string	pst0	perl Storable(v0.7) data
>4	byte	>0
>>4	byte	&01	(network-ordered)
>>4	byte	=5	(major 2)
>>4	byte	=4	(major 2)
>>5	byte	>0	(minor %d)
EOM
}

sub file_magic {
    require IO::File;

    my $file = shift;
    my $fh = IO::File->new;
    open($fh, "<". $file) || die "Can't open '$file': $!";
    binmode($fh);
    defined(sysread($fh, my $buf, 32)) || die "Can't read from '$file': $!";
    close($fh);

    $file = "./$file" unless $file;  # ensure TRUE value

    return read_magic($buf, $file);
}

sub read_magic {
    my($buf, $file) = @_;
    my %info;

    my $buflen = length($buf);
    my $magic;
    if ($buf =~ s/^(pst0|perl-store)//) {
	$magic = $1;
	$info{file} = $file || 1;
    }
    else {
	return undef if $file;
	$magic = "";
    }

    return undef unless length($buf);

    my $net_order;
    if ($magic eq "perl-store" && ord(substr($buf, 0, 1)) > 1) {
	$info{version} = -1;
	$net_order = 0;
    }
    else {
	$buf =~ s/(.)//s;
	my $major = (ord $1) >> 1;
	return undef if $major > 4; # sanity (assuming we never go that high)
	$info{major} = $major;
	$net_order = (ord $1) & 0x01;
	if ($major > 1) {
	    return undef unless $buf =~ s/(.)//s;
	    my $minor = ord $1;
	    $info{minor} = $minor;
	    $info{version} = "$major.$minor";
	    $info{version_nv} = sprintf "%d.%03d", $major, $minor;
	}
	else {
	    $info{version} = $major;
	}
    }
    $info{version_nv} ||= $info{version};
    $info{netorder} = $net_order;

    unless ($net_order) {
	return undef unless $buf =~ s/(.)//s;
	my $len = ord $1;
	return undef unless length($buf) >= $len;
	return undef unless $len == 4 || $len == 8;  # sanity
	@info{qw(byteorder intsize longsize ptrsize)}
	    = unpack "a${len}CCC", $buf;
	(substr $buf, 0, $len + 3) = '';
	if ($info{version_nv} >= 2.002) {
	    return undef unless $buf =~ s/(.)//s;
	    $info{nvsize} = ord $1;
	}
    }
    $info{hdrsize} = $buflen - length($buf);

    return \%info;
}

sub BIN_VERSION_NV {
    sprintf "%d.%03d", BIN_MAJOR(), BIN_MINOR();
}

sub BIN_WRITE_VERSION_NV {
    sprintf "%d.%03d", BIN_MAJOR(), BIN_WRITE_MINOR();
}

#
# store
#
# Store target object hierarchy, identified by a reference to its root.
# The stored object tree may later be retrieved to memory via retrieve.
# Returns undef if an I/O error occurred, in which case the file is
# removed.
#
sub store {
	return _store(\&pstore, @_, 0);
}

#
# nstore
#
# Same as store, but in network order.
#
sub nstore {
	return _store(\&net_pstore, @_, 0);
}

#
# lock_store
#
# Same as store, but flock the file first (advisory locking).
#
sub lock_store {
	return _store(\&pstore, @_, 1);
}

#
# lock_nstore
#
# Same as nstore, but flock the file first (advisory locking).
#
sub lock_nstore {
	return _store(\&net_pstore, @_, 1);
}

# Internal store to file routine
sub _store {
	my $xsptr = shift;
	my $self = shift;
	my ($file, $use_locking) = @_;
	logcroak "not a reference" unless ref($self);
	logcroak "wrong argument number" unless @_ == 2;	# No @foo in arglist
	local *FILE;
	if ($use_locking) {
		open(FILE, ">>$file") || logcroak "can't write into $file: $!";
		unless (&CAN_FLOCK) {
			logcarp "Storable::lock_store: fcntl/flock emulation broken on $^O";
			return undef;
		}
		flock(FILE, LOCK_EX) ||
			logcroak "can't get exclusive lock on $file: $!";
		truncate FILE, 0;
		# Unlocking will happen when FILE is closed
	} else {
		open(FILE, ">$file") || logcroak "can't create $file: $!";
	}
	binmode FILE;				# Archaic systems...
	my $da = $@;				# Don't mess if called from exception handler
	my $ret;
	# Call C routine nstore or pstore, depending on network order
	eval { $ret = &$xsptr(*FILE, $self) };
	# close will return true on success, so the or short-circuits, the ()
	# expression is true, and for that case the block will only be entered
	# if $@ is true (ie eval failed)
	# if close fails, it returns false, $ret is altered, *that* is (also)
	# false, so the () expression is false, !() is true, and the block is
	# entered.
	if (!(close(FILE) or undef $ret) || $@) {
		unlink($file) or warn "Can't unlink $file: $!\n";
	}
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	$@ = $da;
	return $ret;
}

#
# store_fd
#
# Same as store, but perform on an already opened file descriptor instead.
# Returns undef if an I/O error occurred.
#
sub store_fd {
	return _store_fd(\&pstore, @_);
}

#
# nstore_fd
#
# Same as store_fd, but in network order.
#
sub nstore_fd {
	my ($self, $file) = @_;
	return _store_fd(\&net_pstore, @_);
}

# Internal store routine on opened file descriptor
sub _store_fd {
	my $xsptr = shift;
	my $self = shift;
	my ($file) = @_;
	logcroak "not a reference" unless ref($self);
	logcroak "too many arguments" unless @_ == 1;	# No @foo in arglist
	my $fd = fileno($file);
	logcroak "not a valid file descriptor" unless defined $fd;
	my $da = $@;				# Don't mess if called from exception handler
	my $ret;
	# Call C routine nstore or pstore, depending on network order
	eval { $ret = &$xsptr($file, $self) };
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	local $\; print $file '';	# Autoflush the file if wanted
	$@ = $da;
	return $ret;
}

#
# freeze
#
# Store object and its hierarchy in memory and return a scalar
# containing the result.
#
sub freeze {
	_freeze(\&mstore, @_);
}

#
# nfreeze
#
# Same as freeze but in network order.
#
sub nfreeze {
	_freeze(\&net_mstore, @_);
}

# Internal freeze routine
sub _freeze {
	my $xsptr = shift;
	my $self = shift;
	logcroak "not a reference" unless ref($self);
	logcroak "too many arguments" unless @_ == 0;	# No @foo in arglist
	my $da = $@;				# Don't mess if called from exception handler
	my $ret;
	# Call C routine mstore or net_mstore, depending on network order
	eval { $ret = &$xsptr($self) };
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	$@ = $da;
	return $ret ? $ret : undef;
}

#
# retrieve
#
# Retrieve object hierarchy from disk, returning a reference to the root
# object of that tree.
#
sub retrieve {
	_retrieve($_[0], 0);
}

#
# lock_retrieve
#
# Same as retrieve, but with advisory locking.
#
sub lock_retrieve {
	_retrieve($_[0], 1);
}

# Internal retrieve routine
sub _retrieve {
	my ($file, $use_locking) = @_;
	local *FILE;
	open(FILE, $file) || logcroak "can't open $file: $!";
	binmode FILE;							# Archaic systems...
	my $self;
	my $da = $@;							# Could be from exception handler
	if ($use_locking) {
		unless (&CAN_FLOCK) {
			logcarp "Storable::lock_store: fcntl/flock emulation broken on $^O";
			return undef;
		}
		flock(FILE, LOCK_SH) || logcroak "can't get shared lock on $file: $!";
		# Unlocking will happen when FILE is closed
	}
	eval { $self = pretrieve(*FILE) };		# Call C routine
	close(FILE);
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	$@ = $da;
	return $self;
}

#
# fd_retrieve
#
# Same as retrieve, but perform from an already opened file descriptor instead.
#
sub fd_retrieve {
	my ($file) = @_;
	my $fd = fileno($file);
	logcroak "not a valid file descriptor" unless defined $fd;
	my $self;
	my $da = $@;							# Could be from exception handler
	eval { $self = pretrieve($file) };		# Call C routine
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	$@ = $da;
	return $self;
}

sub retrieve_fd { &fd_retrieve }		# Backward compatibility

#
# thaw
#
# Recreate objects in memory from an existing frozen image created
# by freeze.  If the frozen image passed is undef, return undef.
#
sub thaw {
	my ($frozen) = @_;
	return undef unless defined $frozen;
	my $self;
	my $da = $@;							# Could be from exception handler
	eval { $self = mretrieve($frozen) };	# Call C routine
	logcroak $@ if $@ =~ s/\.?\n$/,/;
	$@ = $da;
	return $self;
}

1;
__END__

=head1 NAME

Storable - persistence for Perl data structures

=head1 SYNOPSIS

 use Storable;
 store \%table, 'file';
 $hashref = retrieve('file');

 use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);

 # Network order
 nstore \%table, 'file';
 $hashref = retrieve('file');	# There is NO nretrieve()

 # Storing to and retrieving from an already opened file
 store_fd \@array, \*STDOUT;
 nstore_fd \%table, \*STDOUT;
 $aryref = fd_retrieve(\*SOCKET);
 $hashref = fd_retrieve(\*SOCKET);

 # Serializing to memory
 $serialized = freeze \%table;
 %table_clone = %{ thaw($serialized) };

 # Deep (recursive) cloning
 $cloneref = dclone($ref);

 # Advisory locking
 use Storable qw(lock_store lock_nstore lock_retrieve)
 lock_store \%table, 'file';
 lock_nstore \%table, 'file';
 $hashref = lock_retrieve('file');

=head1 DESCRIPTION

The Storable package brings persistence to your Perl data structures
containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be
conveniently stored to disk and retrieved at a later time.

It can be used in the regular procedural way by calling C<store> with
a reference to the object to be stored, along with the file name where
the image should be written.

The routine returns C<undef> for I/O problems or other internal error,
a true value otherwise. Serious errors are propagated as a C<die> exception.

To retrieve data stored to disk, use C<retrieve> with a file name.
The objects stored into that file are recreated into memory for you,
and a I<reference> to the root object is returned. In case an I/O error
occurs while reading, C<undef> is returned instead. Other serious
errors are propagated via C<die>.

Since storage is performed recursively, you might want to stuff references
to objects that share a lot of common data into a single array or hash
table, and then store that object. That way, when you retrieve back the
whole thing, the objects will continue to share what they originally shared.

At the cost of a slight header overhead, you may store to an already
opened file descriptor using the C<store_fd> routine, and retrieve
from a file via C<fd_retrieve>. Those names aren't imported by default,
so you will have to do that explicitly if you need those routines.
The file descriptor you supply must be already opened, for read
if you're going to retrieve and for write if you wish to store.

	store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
	$hashref = fd_retrieve(*STDIN);

You can also store data in network order to allow easy sharing across
multiple platforms, or when storing on a socket known to be remotely
connected. The routines to call have an initial C<n> prefix for I<network>,
as in C<nstore> and C<nstore_fd>. At retrieval time, your data will be
correctly restored so you don't have to know whether you're restoring
from native or network ordered data.  Double values are stored stringified
to ensure portability as well, at the slight risk of loosing some precision
in the last decimals.

When using C<fd_retrieve>, objects are retrieved in sequence, one
object (i.e. one recursive tree) per associated C<store_fd>.

If you're more from the object-oriented camp, you can inherit from
Storable and directly store your objects by invoking C<store> as
a method. The fact that the root of the to-be-stored tree is a
blessed reference (i.e. an object) is special-cased so that the
retrieve does not provide a reference to that object but rather the
blessed object reference itself. (Otherwise, you'd get a reference
to that blessed object).

=head1 MEMORY STORE

The Storable engine can also store data into a Perl scalar instead, to
later retrieve them. This is mainly used to freeze a complex structure in
some safe compact memory place (where it can possibly be sent to another
process via some IPC, since freezing the structure also serializes it in
effect). Later on, and maybe somewhere else, you can thaw the Perl scalar
out and recreate the original complex structure in memory.

Surprisingly, the routines to be called are named C<freeze> and C<thaw>.
If you wish to send out the frozen scalar to another machine, use
C<nfreeze> instead to get a portable image.

Note that freezing an object structure and immediately thawing it
actually achieves a deep cloning of that structure:

    dclone(.) = thaw(freeze(.))

Storable provides you with a C<dclone> interface which does not create
that intermediary scalar but instead freezes the structure in some
internal memory space and then immediately thaws it out.

=head1 ADVISORY LOCKING

The C<lock_store> and C<lock_nstore> routine are equivalent to
C<store> and C<nstore>, except that they get an exclusive lock on
the file before writing.  Likewise, C<lock_retrieve> does the same
as C<retrieve>, but also gets a shared lock on the file before reading.

As with any advisory locking scheme, the protection only works if you
systematically use C<lock_store> and C<lock_retrieve>.  If one side of
your application uses C<store> whilst the other uses C<lock_retrieve>,
you will get no protection at all.

The internal advisory locking is implemented using Perl's flock()
routine.  If your system does not support any form of flock(), or if
you share your files across NFS, you might wish to use other forms
of locking by using modules such as LockFile::Simple which lock a
file using a filesystem entry, instead of locking the file descriptor.

=head1 SPEED

The heart of Storable is written in C for decent speed. Extra low-level
optimizations have been made when manipulating perl internals, to
sacrifice encapsulation for the benefit of greater speed.

=head1 CANONICAL REPRESENTATION

Normally, Storable stores elements of hashes in the order they are
stored internally by Perl, i.e. pseudo-randomly.  If you set
C<$Storable::canonical> to some C<TRUE> value, Storable will store
hashes with the elements sorted by their key.  This allows you to
compare data structures by comparing their frozen representations (or
even the compressed frozen representations), which can be useful for
creating lookup tables for complicated queries.

Canonical order does not imply network order; those are two orthogonal
settings.

=head1 CODE REFERENCES

Since Storable version 2.05, CODE references may be serialized with
the help of L<B::Deparse>. To enable this feature, set
C<$Storable::Deparse> to a true value. To enable deserialization,
C<$Storable::Eval> should be set to a true value. Be aware that
deserialization is done through C<eval>, which is dangerous if the
Storable file contains malicious data. You can set C<$Storable::Eval>
to a subroutine reference which would be used instead of C<eval>. See
below for an example using a L<Safe> compartment for deserialization
of CODE references.

If C<$Storable::Deparse> and/or C<$Storable::Eval> are set to false
values, then the value of C<$Storable::forgive_me> (see below) is
respected while serializing and deserializing.

=head1 FORWARD COMPATIBILITY

This release of Storable can be used on a newer version of Perl to
serialize data which is not supported by earlier Perls.  By default,
Storable will attempt to do the right thing, by C<croak()>ing if it
encounters data that it cannot deserialize.  However, the defaults
can be changed as follows:

=over 4

=item utf8 data

Perl 5.6 added support for Unicode characters with code points > 255,
and Perl 5.8 has full support for Unicode characters in hash keys.
Perl internally encodes strings with these characters using utf8, and
Storable serializes them as utf8.  By default, if an older version of
Perl encounters a utf8 value it cannot represent, it will C<croak()>.
To change this behaviour so that Storable deserializes utf8 encoded
values as the string of bytes (effectively dropping the I<is_utf8> flag)
set C<$Storable::drop_utf8> to some C<TRUE> value.  This is a form of
data loss, because with C<$drop_utf8> true, it becomes impossible to tell
whether the original data was the Unicode string, or a series of bytes
that happen to be valid utf8.

=item restricted hashes

Perl 5.8 adds support for restricted hashes, which have keys
restricted to a given set, and can have values locked to be read only.
By default, when Storable encounters a restricted hash on a perl
that doesn't support them, it will deserialize it as a normal hash,
silently discarding any placeholder keys and leaving the keys and
all values unlocked.  To make Storable C<croak()> instead, set
C<$Storable::downgrade_restricted> to a C<FALSE> value.  To restore
the default set it back to some C<TRUE> value.

=item files from future versions of Storable

Earlier versions of Storable would immediately croak if they encountered
a file with a higher internal version number than the reading Storable
knew about.  Internal version numbers are increased each time new data
types (such as restricted hashes) are added to the vocabulary of the file
format.  This meant that a newer Storable module had no way of writing a
file readable by an older Storable, even if the writer didn't store newer
data types.

This version of Storable will defer croaking until it encounters a data
type in the file that it does not recognize.  This means that it will
continue to read files generated by newer Storable modules which are careful
in what they write out, making it easier to upgrade Storable modules in a
mixed environment.

The old behaviour of immediate croaking can be re-instated by setting
C<$Storable::accept_future_minor> to some C<FALSE> value.

=back

All these variables have no effect on a newer Perl which supports the
relevant feature.

=head1 ERROR REPORTING

Storable uses the "exception" paradigm, in that it does not try to workaround
failures: if something bad happens, an exception is generated from the
caller's perspective (see L<Carp> and C<croak()>).  Use eval {} to trap
those exceptions.

When Storable croaks, it tries to report the error via the C<logcroak()>
routine from the C<Log::Agent> package, if it is available.

Normal errors are reported by having store() or retrieve() return C<undef>.
Such errors are usually I/O errors (or truncated stream errors at retrieval).

=head1 WIZARDS ONLY

=head2 Hooks

Any class may define hooks that will be called during the serialization
and deserialization process on objects that are instances of that class.
Those hooks can redefine the way serialization is performed (and therefore,
how the symmetrical deserialization should be conducted).

Since we said earlier:

    dclone(.) = thaw(freeze(.))

everything we say about hooks should also hold for deep cloning. However,
hooks get to know whether the operation is a mere serialization, or a cloning.

Therefore, when serializing hooks are involved,

    dclone(.) <> thaw(freeze(.))

Well, you could keep them in sync, but there's no guarantee it will always
hold on classes somebody else wrote.  Besides, there is little to gain in
doing so: a serializing hook could keep only one attribute of an object,
which is probably not what should happen during a deep cloning of that
same object.

Here is the hooking interface:

=over 4

=item C<STORABLE_freeze> I<obj>, I<cloning>

The serializing hook, called on the object during serialization.  It can be
inherited, or defined in the class itself, like any other method.

Arguments: I<obj> is the object to serialize, I<cloning> is a flag indicating
whether we're in a dclone() or a regular serialization via store() or freeze().

Returned value: A LIST C<($serialized, $ref1, $ref2, ...)> where $serialized
is the serialized form to be used, and the optional $ref1, $ref2, etc... are
extra references that you wish to let the Storable engine serialize.

At deserialization time, you will be given back the same LIST, but all the
extra references will be pointing into the deserialized structure.

The B<first time> the hook is hit in a serialization flow, you may have it
return an empty list.  That will signal the Storable engine to further
discard that hook for this class and to therefore revert to the default
serialization of the underlying Perl data.  The hook will again be normally
processed in the next serialization.

Unless you know better, serializing hook should always say:

    sub STORABLE_freeze {
        my ($self, $cloning) = @_;
        return if $cloning;         # Regular default serialization
        ....
    }

in order to keep reasonable dclone() semantics.

=item C<STORABLE_thaw> I<obj>, I<cloning>, I<serialized>, ...

The deserializing hook called on the object during deserialization.
But wait: if we're deserializing, there's no object yet... right?

Wrong: the Storable engine creates an empty one for you.  If you know Eiffel,
you can view C<STORABLE_thaw> as an alternate creation routine.

This means the hook can be inherited like any other method, and that
I<obj> is your blessed reference for this particular instance.

The other arguments should look familiar if you know C<STORABLE_freeze>:
I<cloning> is true when we're part of a deep clone operation, I<serialized>
is the serialized string you returned to the engine in C<STORABLE_freeze>,
and there may be an optional list of references, in the same order you gave
them at serialization time, pointing to the deserialized objects (which
have been processed courtesy of the Storable engine).

When the Storable engine does not find any C<STORABLE_thaw> hook routine,
it tries to load the class by requiring the package dynamically (using
the blessed package name), and then re-attempts the lookup.  If at that
time the hook cannot be located, the engine croaks.  Note that this mechanism
will fail if you define several classes in the same file, but L<perlmod>
warned you.

It is up to you to use this information to populate I<obj> the way you want.

Returned value: none.

=item C<STORABLE_attach> I<class>, I<cloning>, I<serialized>

While C<STORABLE_freeze> and C<STORABLE_thaw> are useful for classes where
each instance is independent, this mechanism has difficulty (or is
incompatible) with objects that exist as common process-level or
system-level resources, such as singleton objects, database pools, caches
or memoized objects.

The alternative C<STORABLE_attach> method provides a solution for these
shared objects. Instead of C<STORABLE_freeze> --E<gt> C<STORABLE_thaw>,
you implement C<STORABLE_freeze> --E<gt> C<STORABLE_attach> instead.

Arguments: I<class> is the class we are attaching to, I<cloning> is a flag
indicating whether we're in a dclone() or a regular de-serialization via
thaw(), and I<serialized> is the stored string for the resource object.

Because these resource objects are considered to be owned by the entire
process/system, and not the "property" of whatever is being serialized,
no references underneath the object should be included in the serialized
string. Thus, in any class that implements C<STORABLE_attach>, the
C<STORABLE_freeze> method cannot return any references, and C<Storable>
will throw an error if C<STORABLE_freeze> tries to return references.

All information required to "attach" back to the shared resource object
B<must> be contained B<only> in the C<STORABLE_freeze> return string.
Otherwise, C<STORABLE_freeze> behaves as normal for C<STORABLE_attach>
classes.

Because C<STORABLE_attach> is passed the class (rather than an object),
it also returns the object directly, rather than modifying the passed
object.

Returned value: object of type C<class>

=back

=head2 Predicates

Predicates are not exportable.  They must be called by explicitly prefixing
them with the Storable package name.

=over 4

=item C<Storable::last_op_in_netorder>

The C<Storable::last_op_in_netorder()> predicate will tell you whether
network order was used in the last store or retrieve operation.  If you
don't know how to use this, just forget about it.

=item C<Storable::is_storing>

Returns true if within a store operation (via STORABLE_freeze hook).

=item C<Storable::is_retrieving>

Returns true if within a retrieve operation (via STORABLE_thaw hook).

=back

=head2 Recursion

With hooks comes the ability to recurse back to the Storable engine.
Indeed, hooks are regular Perl code, and Storable is convenient when
it comes to serializing and deserializing things, so why not use it
to handle the serialization string?

There are a few things you need to know, however:

=over 4

=item *

You can create endless loops if the things you serialize via freeze()
(for instance) point back to the object we're trying to serialize in
the hook.

=item *

Shared references among objects will not stay shared: if we're serializing
the list of object [A, C] where both object A and C refer to the SAME object
B, and if there is a serializing hook in A that says freeze(B), then when
deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D,
a deep clone of B'.  The topology was not preserved.

=back

That's why C<STORABLE_freeze> lets you provide a list of references
to serialize.  The engine guarantees that those will be serialized in the
same context as the other objects, and therefore that shared objects will
stay shared.

In the above [A, C] example, the C<STORABLE_freeze> hook could return:

	("something", $self->{B})

and the B part would be serialized by the engine.  In C<STORABLE_thaw>, you
would get back the reference to the B' object, deserialized for you.

Therefore, recursion should normally be avoided, but is nonetheless supported.

=head2 Deep Cloning

There is a Clone module available on CPAN which implements deep cloning
natively, i.e. without freezing to memory and thawing the result.  It is
aimed to replace Storable's dclone() some day.  However, it does not currently
support Storable hooks to redefine the way deep cloning is performed.

=head1 Storable magic

Yes, there's a lot of that :-) But more precisely, in UNIX systems
there's a utility called C<file>, which recognizes data files based on
their contents (usually their first few bytes).  For this to work,
a certain file called F<magic> needs to taught about the I<signature>
of the data.  Where that configuration file lives depends on the UNIX
flavour; often it's something like F</usr/share/misc/magic> or
F</etc/magic>.  Your system administrator needs to do the updating of
the F<magic> file.  The necessary signature information is output to
STDOUT by invoking Storable::show_file_magic().  Note that the GNU
implementation of the C<file> utility, version 3.38 or later,
is expected to contain support for recognising Storable files
out-of-the-box, in addition to other kinds of Perl files.

You can also use the following functions to extract the file header
information from Storable images:

=over

=item $info = Storable::file_magic( $filename )

If the given file is a Storable image return a hash describing it.  If
the file is readable, but not a Storable image return C<undef>.  If
the file does not exist or is unreadable then croak.

The hash returned has the following elements:

=over

=item C<version>

This returns the file format version.  It is a string like "2.7".

Note that this version number is not the same as the version number of
the Storable module itself.  For instance Storable v0.7 create files
in format v2.0 and Storable v2.15 create files in format v2.7.  The
file format version number only increment when additional features
that would confuse older versions of the module are added.

Files older than v2.0 will have the one of the version numbers "-1",
"0" or "1".  No minor number was used at that time.

=item C<version_nv>

This returns the file format version as number.  It is a string like
"2.007".  This value is suitable for numeric comparisons.

The constant function C<Storable::BIN_VERSION_NV> returns a comparable
number that represents the highest file version number that this
version of Storable fully supports (but see discussion of
C<$Storable::accept_future_minor> above).  The constant
C<Storable::BIN_WRITE_VERSION_NV> function returns what file version
is written and might be less than C<Storable::BIN_VERSION_NV> in some
configurations.

=item C<major>, C<minor>

This also returns the file format version.  If the version is "2.7"
then major would be 2 and minor would be 7.  The minor element is
missing for when major is less than 2.

=item C<hdrsize>

The is the number of bytes that the Storable header occupies.

=item C<netorder>

This is TRUE if the image store data in network order.  This means
that it was created with nstore() or similar.

=item C<byteorder>

This is only present when C<netorder> is FALSE.  It is the
$Config{byteorder} string of the perl that created this image.  It is
a string like "1234" (32 bit little endian) or "87654321" (64 bit big
endian).  This must match the current perl for the image to be
readable by Storable.

=item C<intsize>, C<longsize>, C<ptrsize>, C<nvsize>

These are only present when C<netorder> is FALSE. These are the sizes of
various C datatypes of the perl that created this image.  These must
match the current perl for the image to be readable by Storable.

The C<nvsize> element is only present for file format v2.2 and
higher.

=item C<file>

The name of the file.

=back

=item $info = Storable::read_magic( $buffer )

=item $info = Storable::read_magic( $buffer, $must_be_file )

The $buffer should be a Storable image or the first few bytes of it.
If $buffer starts with a Storable header, then a hash describing the
image is returned, otherwise C<undef> is returned.

The hash has the same structure as the one returned by
Storable::file_magic().  The C<file> element is true if the image is a
file image.

If the $must_be_file argument is provided and is TRUE, then return
C<undef> unless the image looks like it belongs to a file dump.

The maximum size of a Storable header is currently 21 bytes.  If the
provided $buffer is only the first part of a Storable image it should
at least be this long to ensure that read_magic() will recognize it as
such.

=back

=head1 EXAMPLES

Here are some code samples showing a possible usage of Storable:

	use Storable qw(store retrieve freeze thaw dclone);

	%color = ('Blue' => 0.1, 'Red' => 0.8, 'Black' => 0, 'White' => 1);

	store(\%color, 'mycolors') or die "Can't store %a in mycolors!\n";

	$colref = retrieve('mycolors');
	die "Unable to retrieve from mycolors!\n" unless defined $colref;
	printf "Blue is still %lf\n", $colref->{'Blue'};

	$colref2 = dclone(\%color);

	$str = freeze(\%color);
	printf "Serialization of %%color is %d bytes long.\n", length($str);
	$colref3 = thaw($str);

which prints (on my machine):

	Blue is still 0.100000
	Serialization of %color is 102 bytes long.

Serialization of CODE references and deserialization in a safe
compartment:

=for example begin

	use Storable qw(freeze thaw);
	use Safe;
	use strict;
	my $safe = new Safe;
        # because of opcodes used in "use strict":
	$safe->permit(qw(:default require));
	local $Storable::Deparse = 1;
	local $Storable::Eval = sub { $safe->reval($_[0]) };
	my $serialized = freeze(sub { 42 });
	my $code = thaw($serialized);
	$code->() == 42;

=for example end

=for example_testing
        is( $code->(), 42 );

=head1 SECURITY WARNING

B<Do not accept Storable documents from untrusted sources!>

Some features of Storable can lead to security vulnerabilities if you
accept Storable documents from untrusted sources. Most obviously, the
optional (off by default) CODE reference serialization feature allows
transfer of code to the deserializing process. Furthermore, any
serialized object will cause Storable to helpfully load the module
corresponding to the class of the object in the deserializing module.
For manipulated module names, this can load almost arbitrary code.
Finally, the deserialized object's destructors will be invoked when
the objects get destroyed in the deserializing process. Maliciously
crafted Storable documents may put such objects in the value of
a hash key that is overridden by another key/value pair in the
same hash, thus causing immediate destructor execution.

In a future version of Storable, we intend to provide options to disable
loading modules for classes and to disable deserializing objects
altogether. I<Nonetheless, Storable deserializing documents from
untrusted sources is expected to have other, yet undiscovered,
security concerns such as allowing an attacker to cause the deserializer
to crash hard.>

B<Therefore, let me repeat: Do not accept Storable documents from
untrusted sources!>

If your application requires accepting data from untrusted sources, you
are best off with a less powerful and more-likely safe serialization format
and implementation. If your data is sufficiently simple, JSON is a good
choice and offers maximum interoperability.

=head1 WARNING

If you're using references as keys within your hash tables, you're bound
to be disappointed when retrieving your data. Indeed, Perl stringifies
references used as hash table keys. If you later wish to access the
items via another reference stringification (i.e. using the same
reference that was used for the key originally to record the value into
the hash table), it will work because both references stringify to the
same string.

It won't work across a sequence of C<store> and C<retrieve> operations,
however, because the addresses in the retrieved objects, which are
part of the stringified references, will probably differ from the
original addresses. The topology of your structure is preserved,
but not hidden semantics like those.

On platforms where it matters, be sure to call C<binmode()> on the
descriptors that you pass to Storable functions.

Storing data canonically that contains large hashes can be
significantly slower than storing the same data normally, as
temporary arrays to hold the keys for each hash have to be allocated,
populated, sorted and freed.  Some tests have shown a halving of the
speed of storing -- the exact penalty will depend on the complexity of
your data.  There is no slowdown on retrieval.

=head1 BUGS

You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics
for those operations, feel free to enhance Storable so that it can
deal with them.

The store functions will C<croak> if they run into such references
unless you set C<$Storable::forgive_me> to some C<TRUE> value. In that
case, the fatal message is converted to a warning and some meaningless
string is stored instead.

Setting C<$Storable::canonical> may not yield frozen strings that
compare equal due to possible stringification of numbers. When the
string version of a scalar exists, it is the form stored; therefore,
if you happen to use your numbers as strings between two freezing
operations on the same data structures, you will get different
results.

When storing doubles in network order, their value is stored as text.
However, you should also not expect non-numeric floating-point values
such as infinity and "not a number" to pass successfully through a
nstore()/retrieve() pair.

As Storable neither knows nor cares about character sets (although it
does know that characters may be more than eight bits wide), any difference
in the interpretation of character codes between a host and a target
system is your problem.  In particular, if host and target use different
code points to represent the characters used in the text representation
of floating-point numbers, you will not be able be able to exchange
floating-point data, even with nstore().

C<Storable::drop_utf8> is a blunt tool.  There is no facility either to
return B<all> strings as utf8 sequences, or to attempt to convert utf8
data back to 8 bit and C<croak()> if the conversion fails.

Prior to Storable 2.01, no distinction was made between signed and
unsigned integers on storing.  By default Storable prefers to store a
scalars string representation (if it has one) so this would only cause
problems when storing large unsigned integers that had never been converted
to string or floating point.  In other words values that had been generated
by integer operations such as logic ops and then not used in any string or
arithmetic context before storing.

=head2 64 bit data in perl 5.6.0 and 5.6.1

This section only applies to you if you have existing data written out
by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which
has been configured with 64 bit integer support (not the default)
If you got a precompiled perl, rather than running Configure to build
your own perl from source, then it almost certainly does not affect you,
and you can stop reading now (unless you're curious). If you're using perl
on Windows it does not affect you.

Storable writes a file header which contains the sizes of various C
language types for the C compiler that built Storable (when not writing in
network order), and will refuse to load files written by a Storable not
on the same (or compatible) architecture.  This check and a check on
machine byteorder is needed because the size of various fields in the file
are given by the sizes of the C language types, and so files written on
different architectures are incompatible.  This is done for increased speed.
(When writing in network order, all fields are written out as standard
lengths, which allows full interworking, but takes longer to read and write)

Perl 5.6.x introduced the ability to optional configure the perl interpreter
to use C's C<long long> type to allow scalars to store 64 bit integers on 32
bit systems.  However, due to the way the Perl configuration system
generated the C configuration files on non-Windows platforms, and the way
Storable generates its header, nothing in the Storable file header reflected
whether the perl writing was using 32 or 64 bit integers, despite the fact
that Storable was storing some data differently in the file.  Hence Storable
running on perl with 64 bit integers will read the header from a file
written by a 32 bit perl, not realise that the data is actually in a subtly
incompatible format, and then go horribly wrong (possibly crashing) if it
encountered a stored integer.  This is a design failure.

Storable has now been changed to write out and read in a file header with
information about the size of integers.  It's impossible to detect whether
an old file being read in was written with 32 or 64 bit integers (they have
the same header) so it's impossible to automatically switch to a correct
backwards compatibility mode.  Hence this Storable defaults to the new,
correct behaviour.

What this means is that if you have data written by Storable 1.x running
on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux
then by default this Storable will refuse to read it, giving the error
I<Byte order is not compatible>.  If you have such data then you
should set C<$Storable::interwork_56_64bit> to a true value to make this
Storable read and write files with the old header.  You should also
migrate your data, or any older perl you are communicating with, to this
current version of Storable.

If you don't have data written with specific configuration of perl described
above, then you do not and should not do anything.  Don't set the flag -
not only will Storable on an identically configured perl refuse to load them,
but Storable a differently configured perl will load them believing them
to be correct for it, and then may well fail or crash part way through
reading them.

=head1 CREDITS

Thank you to (in chronological order):

	Jarkko Hietaniemi <jhi@iki.fi>
	Ulrich Pfeifer <pfeifer@charly.informatik.uni-dortmund.de>
	Benjamin A. Holzman <bholzman@earthlink.net>
	Andrew Ford <A.Ford@ford-mason.co.uk>
	Gisle Aas <gisle@aas.no>
	Jeff Gresham <gresham_jeffrey@jpmorgan.com>
	Murray Nesbitt <murray@activestate.com>
	Marc Lehmann <pcg@opengroup.org>
	Justin Banks <justinb@wamnet.com>
	Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
	Salvador Ortiz Garcia <sog@msg.com.mx>
	Dominic Dunlop <domo@computer.org>
	Erik Haugan <erik@solbors.no>
	Benjamin A. Holzman <ben.holzman@grantstreet.com>
	Reini Urban <rurban@cpanel.net>

for their bug reports, suggestions and contributions.

Benjamin Holzman contributed the tied variable support, Andrew Ford
contributed the canonical order for hashes, and Gisle Aas fixed
a few misunderstandings of mine regarding the perl internals,
and optimized the emission of "tags" in the output streams by
simply counting the objects instead of tagging them (leading to
a binary incompatibility for the Storable image starting at version
0.6--older images are, of course, still properly understood).
Murray Nesbitt made Storable thread-safe.  Marc Lehmann added overloading
and references to tied items support.  Benjamin Holzman added a performance
improvement for overloaded classes; thanks to Grant Street Group for footing
the bill.

=head1 AUTHOR

Storable was written by Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
Maintenance is now done by the perl5-porters F<E<lt>perl5-porters@perl.orgE<gt>>

Please e-mail us with problems, bug fixes, comments and complaints,
although if you have compliments you should send them to Raphael.
Please don't e-mail Raphael with problems, as he no longer works on
Storable, and your message will be delayed while he forwards it to us.

=head1 SEE ALSO

L<Clone>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                use Errno ':POSIX';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #      B.pm
#
#      Copyright (c) 1996, 1997, 1998 Malcolm Beattie
#
#      You may distribute under the terms of either the GNU General Public
#      License or the Artistic License, as specified in the README file.
#
package B;
use strict;

require Exporter;
@B::ISA = qw(Exporter);

# walkoptree_slow comes from B.pm (you are there),
# walkoptree comes from B.xs

BEGIN {
    $B::VERSION = '1.48';
    @B::EXPORT_OK = ();

    # Our BOOT code needs $VERSION set, and will append to @EXPORT_OK.
    # Want our constants loaded before the compiler meets OPf_KIDS below, as
    # the combination of having the constant stay a Proxy Constant Subroutine
    # and its value being inlined saves a little over .5K

    require XSLoader;
    XSLoader::load();
}

push @B::EXPORT_OK, (qw(minus_c ppname save_BEGINs
			class peekop cast_I32 cstring cchar hash threadsv_names
			main_root main_start main_cv svref_2object opnumber
			sub_generation amagic_generation perlstring
			walkoptree_slow walkoptree walkoptree_exec walksymtable
			parents comppadlist sv_undef compile_stats timing_info
			begin_av init_av check_av end_av regex_padav dowarn
			defstash curstash warnhook diehook inc_gv @optype
			@specialsv_name unitcheck_av));

@B::SV::ISA = 'B::OBJECT';
@B::NULL::ISA = 'B::SV';
@B::PV::ISA = 'B::SV';
@B::IV::ISA = 'B::SV';
@B::NV::ISA = 'B::SV';
# RV is eliminated with 5.11.0, but effectively is a specialisation of IV now.
@B::RV::ISA = $] >= 5.011 ? 'B::IV' : 'B::SV';
@B::PVIV::ISA = qw(B::PV B::IV);
@B::PVNV::ISA = qw(B::PVIV B::NV);
@B::PVMG::ISA = 'B::PVNV';
@B::REGEXP::ISA = 'B::PVMG' if $] >= 5.011;
@B::INVLIST::ISA = 'B::PV'  if $] >= 5.019;
@B::PVLV::ISA = 'B::GV';
@B::BM::ISA = 'B::GV';
@B::AV::ISA = 'B::PVMG';
@B::GV::ISA = 'B::PVMG';
@B::HV::ISA = 'B::PVMG';
@B::CV::ISA = 'B::PVMG';
@B::IO::ISA = 'B::PVMG';
@B::FM::ISA = 'B::CV';

@B::OP::ISA = 'B::OBJECT';
@B::UNOP::ISA = 'B::OP';
@B::BINOP::ISA = 'B::UNOP';
@B::LOGOP::ISA = 'B::UNOP';
@B::LISTOP::ISA = 'B::BINOP';
@B::SVOP::ISA = 'B::OP';
@B::PADOP::ISA = 'B::OP';
@B::PVOP::ISA = 'B::OP';
@B::LOOP::ISA = 'B::LISTOP';
@B::PMOP::ISA = 'B::LISTOP';
@B::COP::ISA = 'B::OP';

@B::SPECIAL::ISA = 'B::OBJECT';

@B::optype = qw(OP UNOP BINOP LOGOP LISTOP PMOP SVOP PADOP PVOP LOOP COP);
# bytecode.pl contained the following comment:
# Nullsv *must* come first in the following so that the condition
# ($$sv == 0) can continue to be used to test (sv == Nullsv).
@B::specialsv_name = qw(Nullsv &PL_sv_undef &PL_sv_yes &PL_sv_no
			(SV*)pWARN_ALL (SV*)pWARN_NONE (SV*)pWARN_STD);

{
    # Stop "-w" from complaining about the lack of a real B::OBJECT class
    package B::OBJECT;
}

sub B::GV::SAFENAME {
  my $name = (shift())->NAME;

  # The regex below corresponds to the isCONTROLVAR macro
  # from toke.c

  $name =~ s/^\c?/^?/
    or $name =~ s/^([\cA-\cZ\c\\c[\c]\c_\c^])/
                "^" .  chr( utf8::unicode_to_native( 64 ^ ord($1) ))/e;

  # When we say unicode_to_native we really mean ascii_to_native,
  # which matters iff this is a non-ASCII platform (EBCDIC).  '\c?' would
  # not have to be special cased, except for non-ASCII.

  return $name;
}

sub B::IV::int_value {
  my ($self) = @_;
  return (($self->FLAGS() & SVf_IVisUV()) ? $self->UVX : $self->IV);
}

sub B::NULL::as_string() {""}
*B::IV::as_string = \*B::IV::int_value;
*B::PV::as_string = \*B::PV::PV;

#  The input typemap checking makes no distinction between different SV types,
#  so the XS body will generate the same C code, despite the different XS
#  "types". So there is no change in behaviour from doing "newXS" like this,
#  compared with the old approach of having a (near) duplicate XS body.
#  We should fix the typemap checking.
*B::IV::RV = \*B::PV::RV if $] > 5.012;

my $debug;
my $op_count = 0;
my @parents = ();

sub debug {
    my ($class, $value) = @_;
    $debug = $value;
    walkoptree_debug($value);
}

sub class {
    my $obj = shift;
    my $name = ref $obj;
    $name =~ s/^.*:://;
    return $name;
}

sub parents { \@parents }

# For debugging
sub peekop {
    my $op = shift;
    return sprintf("%s (0x%x) %s", class($op), $$op, $op->name);
}

sub walkoptree_slow {
    my($op, $method, $level) = @_;
    $op_count++; # just for statistics
    $level ||= 0;
    warn(sprintf("walkoptree: %d. %s\n", $level, peekop($op))) if $debug;
    $op->$method($level) if $op->can($method);
    if ($$op && ($op->flags & OPf_KIDS)) {
	my $kid;
	unshift(@parents, $op);
	for ($kid = $op->first; $$kid; $kid = $kid->sibling) {
	    walkoptree_slow($kid, $method, $level + 1);
	}
	shift @parents;
    }
    if (class($op) eq 'PMOP'
	&& ref($op->pmreplroot)
	&& ${$op->pmreplroot}
	&& $op->pmreplroot->isa( 'B::OP' ))
    {
	unshift(@parents, $op);
	walkoptree_slow($op->pmreplroot, $method, $level + 1);
	shift @parents;
    }
}

sub compile_stats {
    return "Total number of OPs processed: $op_count\n";
}

sub timing_info {
    my ($sec, $min, $hr) = localtime;
    my ($user, $sys) = times;
    sprintf("%02d:%02d:%02d user=$user sys=$sys",
	    $hr, $min, $sec, $user, $sys);
}

my %symtable;

sub clearsym {
    %symtable = ();
}

sub savesym {
    my ($obj, $value) = @_;
#    warn(sprintf("savesym: sym_%x => %s\n", $$obj, $value)); # debug
    $symtable{sprintf("sym_%x", $$obj)} = $value;
}

sub objsym {
    my $obj = shift;
    return $symtable{sprintf("sym_%x", $$obj)};
}

sub walkoptree_exec {
    my ($op, $method, $level) = @_;
    $level ||= 0;
    my ($sym, $ppname);
    my $prefix = "    " x $level;
    for (; $$op; $op = $op->next) {
	$sym = objsym($op);
	if (defined($sym)) {
	    print $prefix, "goto $sym\n";
	    return;
	}
	savesym($op, sprintf("%s (0x%lx)", class($op), $$op));
	$op->$method($level);
	$ppname = $op->name;
	if ($ppname =~
	    /^(d?or(assign)?|and(assign)?|mapwhile|grepwhile|entertry|range|cond_expr)$/)
	{
	    print $prefix, uc($1), " => {\n";
	    walkoptree_exec($op->other, $method, $level + 1);
	    print $prefix, "}\n";
	} elsif ($ppname eq "match" || $ppname eq "subst") {
	    my $pmreplstart = $op->pmreplstart;
	    if ($$pmreplstart) {
		print $prefix, "PMREPLSTART => {\n";
		walkoptree_exec($pmreplstart, $method, $level + 1);
		print $prefix, "}\n";
	    }
	} elsif ($ppname eq "substcont") {
	    print $prefix, "SUBSTCONT => {\n";
	    walkoptree_exec($op->other->pmreplstart, $method, $level + 1);
	    print $prefix, "}\n";
	    $op = $op->other;
	} elsif ($ppname eq "enterloop") {
	    print $prefix, "REDO => {\n";
	    walkoptree_exec($op->redoop, $method, $level + 1);
	    print $prefix, "}\n", $prefix, "NEXT => {\n";
	    walkoptree_exec($op->nextop, $method, $level + 1);
	    print $prefix, "}\n", $prefix, "LAST => {\n";
	    walkoptree_exec($op->lastop,  $method, $level + 1);
	    print $prefix, "}\n";
	} elsif ($ppname eq "subst") {
	    my $replstart = $op->pmreplstart;
	    if ($$replstart) {
		print $prefix, "SUBST => {\n";
		walkoptree_exec($replstart, $method, $level + 1);
		print $prefix, "}\n";
	    }
	}
    }
}

sub walksymtable {
    my ($symref, $method, $recurse, $prefix) = @_;
    my $sym;
    my $ref;
    my $fullname;
    no strict 'refs';
    $prefix = '' unless defined $prefix;
    foreach my $sym ( sort keys %$symref ) {
        $ref= $symref->{$sym};
        $fullname = "*main::".$prefix.$sym;
	if ($sym =~ /::$/) {
	    $sym = $prefix . $sym;
	    if (svref_2object(\*$sym)->NAME ne "main::" && $sym ne "<none>::" && &$recurse($sym)) {
               walksymtable(\%$fullname, $method, $recurse, $sym);
	    }
	} else {
           svref_2object(\*$fullname)->$method();
	}
    }
}

{
    package B::Section;
    my $output_fh;
    my %sections;

    sub new {
	my ($class, $section, $symtable, $default) = @_;
	$output_fh ||= FileHandle->new_tmpfile;
	my $obj = bless [-1, $section, $symtable, $default], $class;
	$sections{$section} = $obj;
	return $obj;
    }

    sub get {
	my ($class, $section) = @_;
	return $sections{$section};
    }

    sub add {
	my $section = shift;
	while (defined($_ = shift)) {
	    print $output_fh "$section->[1]\t$_\n";
	    $section->[0]++;
	}
    }

    sub index {
	my $section = shift;
	return $section->[0];
    }

    sub name {
	my $section = shift;
	return $section->[1];
    }

    sub symtable {
	my $section = shift;
	return $section->[2];
    }

    sub default {
	my $section = shift;
	return $section->[3];
    }

    sub output {
	my ($section, $fh, $format) = @_;
	my $name = $section->name;
	my $sym = $section->symtable || {};
	my $default = $section->default;

	seek($output_fh, 0, 0);
	while (<$output_fh>) {
	    chomp;
	    s/^(.*?)\t//;
	    if ($1 eq $name) {
		s{(s\\_[0-9a-f]+)} {
		    exists($sym->{$1}) ? $sym->{$1} : $default;
		}ge;
		printf $fh $format, $_;
	    }
	}
    }
}

1;

__END__

=head1 NAME

B - The Perl Compiler Backend

=head1 SYNOPSIS

	use B;

=head1 DESCRIPTION

The C<B> module supplies classes which allow a Perl program to delve
into its own innards.  It is the module used to implement the
"backends" of the Perl compiler.  Usage of the compiler does not
require knowledge of this module: see the F<O> module for the
user-visible part.  The C<B> module is of use to those who want to
write new compiler backends.  This documentation assumes that the
reader knows a fair amount about perl's internals including such
things as SVs, OPs and the internal symbol table and syntax tree
of a program.

=head1 OVERVIEW

The C<B> module contains a set of utility functions for querying the
current state of the Perl interpreter; typically these functions
return objects from the B::SV and B::OP classes, or their derived
classes.  These classes in turn define methods for querying the
resulting objects about their own internal state.

=head1 Utility Functions

The C<B> module exports a variety of functions: some are simple
utility functions, others provide a Perl program with a way to
get an initial "handle" on an internal object.

=head2 Functions Returning C<B::SV>, C<B::AV>, C<B::HV>, and C<B::CV> objects

For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, L<"OVERVIEW OF
CLASSES"> and L<"SV-RELATED CLASSES">.

=over 4

=item sv_undef

Returns the SV object corresponding to the C variable C<sv_undef>.

=item sv_yes

Returns the SV object corresponding to the C variable C<sv_yes>.

=item sv_no

Returns the SV object corresponding to the C variable C<sv_no>.

=item svref_2object(SVREF)

Takes a reference to any Perl value, and turns the referred-to value
into an object in the appropriate B::OP-derived or B::SV-derived
class.  Apart from functions such as C<main_root>, this is the primary
way to get an initial "handle" on an internal perl data structure
which can then be followed with the other access methods.

The returned object will only be valid as long as the underlying OPs
and SVs continue to exist.  Do not attempt to use the object after the
underlying structures are freed.

=item amagic_generation

Returns the SV object corresponding to the C variable C<amagic_generation>.
As of Perl 5.18, this is just an alias to C<PL_na>, so its value is
meaningless.

=item init_av

Returns the AV object (i.e. in class B::AV) representing INIT blocks.

=item check_av

Returns the AV object (i.e. in class B::AV) representing CHECK blocks.

=item unitcheck_av

Returns the AV object (i.e. in class B::AV) representing UNITCHECK blocks.

=item begin_av

Returns the AV object (i.e. in class B::AV) representing BEGIN blocks.

=item end_av

Returns the AV object (i.e. in class B::AV) representing END blocks.

=item comppadlist

Returns the PADLIST object (i.e. in class B::PADLIST) of the global
comppadlist.  In Perl 5.16 and earlier it returns an AV object (class
B::AV).

=item regex_padav

Only when perl was compiled with ithreads.

=item main_cv

Return the (faked) CV corresponding to the main part of the Perl
program.

=back

=head2 Functions for Examining the Symbol Table

=over 4

=item walksymtable(SYMREF, METHOD, RECURSE, PREFIX)

Walk the symbol table starting at SYMREF and call METHOD on each
symbol (a B::GV object) visited.  When the walk reaches package
symbols (such as "Foo::") it invokes RECURSE, passing in the symbol
name, and only recurses into the package if that sub returns true.

PREFIX is the name of the SYMREF you're walking.

For example:

  # Walk CGI's symbol table calling print_subs on each symbol.
  # Recurse only into CGI::Util::
  walksymtable(\%CGI::, 'print_subs',
               sub { $_[0] eq 'CGI::Util::' }, 'CGI::');

print_subs() is a B::GV method you have declared.  Also see L<"B::GV
Methods">, below.

=back

=head2 Functions Returning C<B::OP> objects or for walking op trees

For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, L<"OVERVIEW OF
CLASSES"> and L<"OP-RELATED CLASSES">.

=over 4

=item main_root

Returns the root op (i.e. an object in the appropriate B::OP-derived
class) of the main part of the Perl program.

=item main_start

Returns the starting op of the main part of the Perl program.

=item walkoptree(OP, METHOD)

Does a tree-walk of the syntax tree based at OP and calls METHOD on
each op it visits.  Each node is visited before its children.  If
C<walkoptree_debug> (see below) has been called to turn debugging on then
the method C<walkoptree_debug> is called on each op before METHOD is
called.

=item walkoptree_debug(DEBUG)

Returns the current debugging flag for C<walkoptree>.  If the optional
DEBUG argument is non-zero, it sets the debugging flag to that.  See
the description of C<walkoptree> above for what the debugging flag
does.

=back

=head2 Miscellaneous Utility Functions

=over 4

=item ppname(OPNUM)

Return the PP function name (e.g. "pp_add") of op number OPNUM.

=item hash(STR)

Returns a string in the form "0x..." representing the value of the
internal hash function used by perl on string STR.

=item cast_I32(I)

Casts I to the internal I32 type used by that perl.

=item minus_c

Does the equivalent of the C<-c> command-line option.  Obviously, this
is only useful in a BEGIN block or else the flag is set too late.

=item cstring(STR)

Returns a double-quote-surrounded escaped version of STR which can
be used as a string in C source code.

=item perlstring(STR)

Returns a double-quote-surrounded escaped version of STR which can
be used as a string in Perl source code.

=item class(OBJ)

Returns the class of an object without the part of the classname
preceding the first C<"::">.  This is used to turn C<"B::UNOP"> into
C<"UNOP"> for example.

=item threadsv_names

In a perl compiled for threads, this returns a list of the special
per-thread threadsv variables.

=back

=head2 Exported utility variables

=over 4

=item @optype

  my $op_type = $optype[$op_type_num];

A simple mapping of the op type number to its type (like 'COP' or 'BINOP').

=item @specialsv_name

  my $sv_name = $specialsv_name[$sv_index];

Certain SV types are considered 'special'.  They're represented by
B::SPECIAL and are referred to by a number from the specialsv_list.
This array maps that number back to the name of the SV (like 'Nullsv'
or '&PL_sv_undef').

=back


=head1 OVERVIEW OF CLASSES

The C structures used by Perl's internals to hold SV and OP
information (PVIV, AV, HV, ..., OP, SVOP, UNOP, ...) are modelled on a
class hierarchy and the C<B> module gives access to them via a true
object hierarchy.  Structure fields which point to other objects
(whether types of SV or types of OP) are represented by the C<B>
module as Perl objects of the appropriate class.

The bulk of the C<B> module is the methods for accessing fields of
these structures.

Note that all access is read-only.  You cannot modify the internals by
using this module.  Also, note that the B::OP and B::SV objects created
by this module are only valid for as long as the underlying objects
exist; their creation doesn't increase the reference counts of the
underlying objects.  Trying to access the fields of a freed object will
give incomprehensible results, or worse.

=head2 SV-RELATED CLASSES

B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO.  These classes
correspond in the obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C "inheritance".  For the
5.10.x branch, (I<ie> 5.10.0, 5.10.1 I<etc>) this is:

                           B::SV
                             |
                +------------+------------+------------+
                |            |            |            |
              B::PV        B::IV        B::NV        B::RV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
                   +-----+-----+-----+-----+
                   |     |     |     |     |
                 B::AV B::GV B::HV B::CV B::IO
                         |           |
                         |           |
                      B::PVLV      B::FM

For 5.9.0 and earlier, PVLV is a direct subclass of PVMG, and BM is still
present as a distinct type, so the base of this diagram is


                               |
                               |
                            B::PVMG
                               |
            +------+-----+-----+-----+-----+-----+
            |      |     |     |     |     |     |
         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
                                           |
                                           |
                                         B::FM

For 5.11.0 and later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving this structure:

                           B::SV
                             |
                +------------+------------+
                |            |            |
              B::PV        B::IV        B::NV
                  \         /           /
                   \       /           /
                    B::PVIV           /
                         \           /
                          \         /
                           \       /
                            B::PVNV
                               |
                               |
                            B::PVMG
                               |
           +-------+-------+---+---+-------+-------+
           |       |       |       |       |       |
         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
                   |               |
                   |               |
                B::PVLV          B::FM


Access methods correspond to the underlying C macros for field access,
usually with the leading "class indication" prefix removed (Sv, Av,
Hv, ...).  The leading prefix is only left in cases where its removal
would cause a clash in method name.  For example, C<GvREFCNT> stays
as-is since its abbreviation would clash with the "superclass" method
C<REFCNT> (corresponding to the C function C<SvREFCNT>).

=head2 B::SV Methods

=over 4

=item REFCNT

=item FLAGS

=item object_2svref

Returns a reference to the regular scalar corresponding to this
B::SV object.  In other words, this method is the inverse operation
to the svref_2object() subroutine.  This scalar and other data it points
at should be considered read-only: modifying them is neither safe nor
guaranteed to have a sensible effect.

=back

=head2 B::IV Methods

=over 4

=item IV

Returns the value of the IV, I<interpreted as
a signed integer>.  This will be misleading
if C<FLAGS & SVf_IVisUV>.  Perhaps you want the
C<int_value> method instead?

=item IVX

=item UVX

=item int_value

This method returns the value of the IV as an integer.
It differs from C<IV> in that it returns the correct
value regardless of whether it's stored signed or
unsigned.

=item needs64bits

=item packiv

=back

=head2 B::NV Methods

=over 4

=item NV

=item NVX

=back

=head2 B::RV Methods

=over 4

=item RV

=back

=head2 B::PV Methods

=over 4

=item PV

This method is the one you usually want.  It constructs a
string using the length and offset information in the struct:
for ordinary scalars it will return the string that you'd see
from Perl, even if it contains null characters.

=item RV

Same as B::RV::RV, except that it will die() if the PV isn't
a reference.

=item PVX

This method is less often useful.  It assumes that the string
stored in the struct is null-terminated, and disregards the
length information.

It is the appropriate method to use if you need to get the name
of a lexical variable from a padname array.  Lexical variable names
are always stored with a null terminator, and the length field
(CUR) is overloaded for other purposes and can't be relied on here.

=item CUR

This method returns the internal length field, which consists of the number
of internal bytes, not necessarily the number of logical characters.

=item LEN

This method returns the number of bytes allocated (via malloc) for storing
the string.  This is 0 if the scalar does not "own" the string.

=back

=head2 B::PVMG Methods

=over 4

=item MAGIC

=item SvSTASH

=back

=head2 B::MAGIC Methods

=over 4

=item MOREMAGIC

=item precomp

Only valid on r-magic, returns the string that generated the regexp.

=item PRIVATE

=item TYPE

=item FLAGS

=item OBJ

Will die() if called on r-magic.

=item PTR

=item REGEX

Only valid on r-magic, returns the integer value of the REGEX stored
in the MAGIC.

=back

=head2 B::PVLV Methods

=over 4

=item TARGOFF

=item TARGLEN

=item TYPE

=item TARG

=back

=head2 B::BM Methods

=over 4

=item USEFUL

=item PREVIOUS

=item RARE

=item TABLE

=back

=head2 B::GV Methods

=over 4

=item is_empty

This method returns TRUE if the GP field of the GV is NULL.

=item NAME

=item SAFENAME

This method returns the name of the glob, but if the first
character of the name is a control character, then it converts
it to ^X first, so that *^G would return "^G" rather than "\cG".

It's useful if you want to print out the name of a variable.
If you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
C<${"^G"} = 1> is compiled as two ops - a constant string and
a dereference (rv2gv) - so that the glob is created at runtime.

If you're working with globs at runtime, and need to disambiguate
*^G from *{"^G"}, then you should use the raw NAME method.

=item STASH

=item SV

=item IO

=item FORM

=item AV

=item HV

=item EGV

=item CV

=item CVGEN

=item LINE

=item FILE

=item FILEGV

=item GvREFCNT

=item FLAGS

=back

=head2 B::IO Methods

B::IO objects derive from IO objects and you will get more information from
the IO object itself.

For example:

  $gvio = B::svref_2object(\*main::stdin)->IO;
  $IO = $gvio->object_2svref();
  $fd = $IO->fileno();

=over 4

=item LINES

=item PAGE

=item PAGE_LEN

=item LINES_LEFT

=item TOP_NAME

=item TOP_GV

=item FMT_NAME

=item FMT_GV

=item BOTTOM_NAME

=item BOTTOM_GV

=item SUBPROCESS

=item IoTYPE

A character symbolizing the type of IO Handle.

  -     STDIN/OUT
  I     STDIN/OUT/ERR
  <     read-only
  >     write-only
  a     append
  +     read and write
  s     socket
  |     pipe
  I     IMPLICIT
  #     NUMERIC
  space closed handle
  \0    closed internal handle

=item IoFLAGS

=item IsSTD

Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true
if the IoIFP of the object is equal to the handle whose name was
passed as argument; i.e., $io->IsSTD('stderr') is true if
IoIFP($io) == PerlIO_stderr().

=back

=head2 B::AV Methods

=over 4

=item FILL

=item MAX

=item ARRAY

=item ARRAYelt

Like C<ARRAY>, but takes an index as an argument to get only one element,
rather than a list of all of them.

=item OFF

This method is deprecated if running under Perl 5.8, and is no longer present
if running under Perl 5.9

=item AvFLAGS

This method returns the AV specific
flags.  In Perl 5.9 these are now stored
in with the main SV flags, so this method is no longer present.

=back

=head2 B::CV Methods

=over 4

=item STASH

=item START

=item ROOT

=item GV

=item FILE

=item DEPTH

=item PADLIST

Returns a B::PADLIST object under Perl 5.18 or higher, or a B::AV in
earlier versions.

=item OUTSIDE

=item OUTSIDE_SEQ

=item XSUB

=item XSUBANY

For constant subroutines, returns the constant SV returned by the subroutine.

=item CvFLAGS

=item const_sv

=item NAME_HEK

Returns the name of a lexical sub, otherwise C<undef>.

=back

=head2 B::HV Methods

=over 4

=item FILL

=item MAX

=item KEYS

=item RITER

=item NAME

=item ARRAY

=item PMROOT

This method is not present if running under Perl 5.9, as the PMROOT
information is no longer stored directly in the hash.

=back

=head2 OP-RELATED CLASSES

C<B::OP>, C<B::UNOP>, C<B::BINOP>, C<B::LOGOP>, C<B::LISTOP>, C<B::PMOP>,
C<B::SVOP>, C<B::PADOP>, C<B::PVOP>, C<B::LOOP>, C<B::COP>.

These classes correspond in the obvious way to the underlying C
structures of similar names.  The inheritance hierarchy mimics the
underlying C "inheritance":

                                 B::OP
                                   |
                   +---------------+--------+--------+-------+
                   |               |        |        |       |
                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
                 ,'  `-.
                /       `--.
           B::BINOP     B::LOGOP
               |
               |
           B::LISTOP
             ,' `.
            /     \
        B::LOOP B::PMOP

Access methods correspond to the underlying C structure field names,
with the leading "class indication" prefix (C<"op_">) removed.

=head2 B::OP Methods

These methods get the values of similarly named fields within the OP
data structure.  See top of C<op.h> for more info.

=over 4

=item next

=item sibling

=item name

This returns the op name as a string (e.g. "add", "rv2av").

=item ppaddr

This returns the function name as a string (e.g. "PL_ppaddr[OP_ADD]",
"PL_ppaddr[OP_RV2AV]").

=item desc

This returns the op description from the global C PL_op_desc array
(e.g. "addition" "array deref").

=item targ

=item type

=item opt

=item flags

=item private

=item spare

=back

=head2 B::UNOP METHOD

=over 4

=item first

=back

=head2 B::BINOP METHOD

=over 4

=item last

=back

=head2 B::LOGOP METHOD

=over 4

=item other

=back

=head2 B::LISTOP METHOD

=over 4

=item children

=back

=head2 B::PMOP Methods

=over 4

=item pmreplroot

=item pmreplstart

=item pmnext

Only up to Perl 5.9.4

=item pmflags

=item extflags

Since Perl 5.9.5

=item precomp

=item pmoffset

Only when perl was compiled with ithreads.

=item code_list

Since perl 5.17.1

=back

=head2 B::SVOP METHOD

=over 4

=item sv

=item gv

=back

=head2 B::PADOP METHOD

=over 4

=item padix

=back

=head2 B::PVOP METHOD

=over 4

=item pv

=back

=head2 B::LOOP Methods

=over 4

=item redoop

=item nextop

=item lastop

=back

=head2 B::COP Methods

=over 4

=item label

=item stash

=item stashpv

=item stashoff (threaded only)

=item file

=item cop_seq

=item arybase

=item line

=item warnings

=item io

=item hints

=item hints_hash

=back

=head2 OTHER CLASSES

Perl 5.18 introduces a new class, B::PADLIST, returned by B::CV's
C<PADLIST> method.

=head2 B::PADLIST Methods

=over 4

=item MAX

=item ARRAY

A list of pads.  The first one contains the names.  These are currently
B::AV objects, but that is likely to change in future versions.

=item ARRAYelt

Like C<ARRAY>, but takes an index as an argument to get only one element,
rather than a list of all of them.

=item REFCNT

=back

=head2 $B::overlay

Although the optree is read-only, there is an overlay facility that allows
you to override what values the various B::*OP methods return for a
particular op. C<$B::overlay> should be set to reference a two-deep hash:
indexed by OP address, then method name. Whenever a an op method is
called, the value in the hash is returned if it exists. This facility is
used by B::Deparse to "undo" some optimisations. For example:


    local $B::overlay = {};
    ...
    if ($op->name eq "foo") {
        $B::overlay->{$$op} = {
                name => 'bar',
                next => $op->next->next,
        };
    }
    ...
    $op->name # returns "bar"
    $op->next # returns the next op but one


=head1 AUTHOR

Malcolm Beattie, C<mbeattie@sable.ox.ac.uk>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Digest::SHA;

require 5.003000;

use strict;
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
use Fcntl;
use integer;

$VERSION = '5.88';

require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
@EXPORT_OK = qw(
	hmac_sha1	hmac_sha1_base64	hmac_sha1_hex
	hmac_sha224	hmac_sha224_base64	hmac_sha224_hex
	hmac_sha256	hmac_sha256_base64	hmac_sha256_hex
	hmac_sha384	hmac_sha384_base64	hmac_sha384_hex
	hmac_sha512	hmac_sha512_base64	hmac_sha512_hex
	hmac_sha512224	hmac_sha512224_base64	hmac_sha512224_hex
	hmac_sha512256	hmac_sha512256_base64	hmac_sha512256_hex
	sha1		sha1_base64		sha1_hex
	sha224		sha224_base64		sha224_hex
	sha256		sha256_base64		sha256_hex
	sha384		sha384_base64		sha384_hex
	sha512		sha512_base64		sha512_hex
	sha512224	sha512224_base64	sha512224_hex
	sha512256	sha512256_base64	sha512256_hex);

# If possible, inherit from Digest::base

eval {
	require Digest::base;
	push(@ISA, 'Digest::base');
};

*addfile   = \&Addfile;
*hexdigest = \&Hexdigest;
*b64digest = \&B64digest;

# The following routines aren't time-critical, so they can be left in Perl

sub new {
	my($class, $alg) = @_;
	$alg =~ s/\D+//g if defined $alg;
	if (ref($class)) {	# instance method
		unless (defined($alg) && ($alg != $class->algorithm)) {
			sharewind($$class);
			return($class);
		}
		if ($$class) { shaclose($$class); $$class = undef }
		return unless $$class = shaopen($alg);
		return($class);
	}
	$alg = 1 unless defined $alg;
	my $state = shaopen($alg) || return;
	my $self = \$state;
	bless($self, $class);
	return($self);
}

sub DESTROY {
	my $self = shift;
	if ($$self) { shaclose($$self); $$self = undef }
}

sub clone {
	my $self = shift;
	my $state = shadup($$self) || return;
	my $copy = \$state;
	bless($copy, ref($self));
	return($copy);
}

*reset = \&new;

sub add_bits {
	my($self, $data, $nbits) = @_;
	unless (defined $nbits) {
		$nbits = length($data);
		$data = pack("B*", $data);
	}
	$nbits = length($data) * 8 if $nbits > length($data) * 8;
	shawrite($data, $nbits, $$self);
	return($self);
}

sub _bail {
	my $msg = shift;

	$msg .= ": $!";
        require Carp;
        Carp::croak($msg);
}

sub _addfile {  # this is "addfile" from Digest::base 1.00
    my ($self, $handle) = @_;

    my $n;
    my $buf = "";

    while (($n = read($handle, $buf, 4096))) {
        $self->add($buf);
    }
    _bail("Read failed") unless defined $n;

    $self;
}

my $_can_T_filehandle;

sub _istext {
	local *FH = shift;
	my $file = shift;

	if (! defined $_can_T_filehandle) {
		local $^W = 0;
		eval { -T FH };
		$_can_T_filehandle = $@ ? 0 : 1;
	}
	return $_can_T_filehandle ? -T FH : -T $file;
}

sub Addfile {
	my ($self, $file, $mode) = @_;

	return(_addfile($self, $file)) unless ref(\$file) eq 'SCALAR';

	$mode = defined($mode) ? $mode : "";
	my ($binary, $portable, $BITS) = map { $_ eq $mode } ("b", "p", "0");

		## Always interpret "-" to mean STDIN; otherwise use
		## sysopen to handle full range of POSIX file names
	local *FH;
	$file eq '-' and open(FH, '< -')
		or sysopen(FH, $file, O_RDONLY)
			or _bail('Open failed');

	if ($BITS) {
		my ($n, $buf) = (0, "");
		while (($n = read(FH, $buf, 4096))) {
			$buf =~ s/[^01]//g;
			$self->add_bits($buf);
		}
		_bail("Read failed") unless defined $n;
		close(FH);
		return($self);
	}

	binmode(FH) if $binary || $portable;
	unless ($portable && _istext(*FH, $file)) {
		$self->_addfile(*FH);
		close(FH);
		return($self);
	}

	while (<FH>) {
		s/\015?\015\012/\012/g;		# DOS/Windows
		s/\015/\012/g;			# early MacOS
		$self->add($_);
	}
	close(FH);

	$self;
}

sub getstate {
	my $self = shift;

	my $alg = $self->algorithm or return;
	my $state = $self->_getstate or return;
	my $nD = $alg <= 256 ?  8 :  16;
	my $nH = $alg <= 256 ? 32 :  64;
	my $nB = $alg <= 256 ? 64 : 128;
	my($H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) =
		$state =~ /^(.{$nH})(.{$nB})(.{4})(.{4})(.{4})(.{4})(.{4})$/s;
	for ($alg, $H, $block, $blockcnt, $lenhh, $lenhl, $lenlh, $lenll) {
		return unless defined $_;
	}

	my @s = ();
	push(@s, "alg:" . $alg);
	push(@s, "H:" . join(":", unpack("H*", $H) =~ /.{$nD}/g));
	push(@s, "block:" . join(":", unpack("H*", $block) =~ /.{2}/g));
	push(@s, "blockcnt:" . unpack("N", $blockcnt));
	push(@s, "lenhh:" . unpack("N", $lenhh));
	push(@s, "lenhl:" . unpack("N", $lenhl));
	push(@s, "lenlh:" . unpack("N", $lenlh));
	push(@s, "lenll:" . unpack("N", $lenll));
	join("\n", @s) . "\n";
}

sub putstate {
	my $class = shift;
	my $state = shift;

	my %s = ();
	for (split(/\n/, $state)) {
		s/^\s+//;
		s/\s+$//;
		next if (/^(#|$)/);
		my @f = split(/[:\s]+/);
		my $tag = shift(@f);
		$s{$tag} = join('', @f);
	}

	# H and block may contain arbitrary values, but check everything else
	grep { $_ == $s{'alg'} } (1,224,256,384,512,512224,512256) or return;
	length($s{'H'}) == ($s{'alg'} <= 256 ? 64 : 128) or return;
	length($s{'block'}) == ($s{'alg'} <= 256 ? 128 : 256) or return;
	{
		no integer;
		for (qw(blockcnt lenhh lenhl lenlh lenll)) {
			0 <= $s{$_} or return;
			$s{$_} <= 4294967295 or return;
		}
		$s{'blockcnt'} < ($s{'alg'} <= 256 ? 512 : 1024) or return;
	}

	my $state_packed = (
		pack("H*", $s{'H'}) .
		pack("H*", $s{'block'}) .
		pack("N", $s{'blockcnt'}) .
		pack("N", $s{'lenhh'}) .
		pack("N", $s{'lenhl'}) .
		pack("N", $s{'lenlh'}) .
		pack("N", $s{'lenll'})
	);

	if (ref($class)) {	# instance method
		if ($$class) { shaclose($$class); $$class = undef }
		return unless $$class = shaopen($s{'alg'});
		return $class->_putstate($state_packed);
	}
	else {
		my $sha = shaopen($s{'alg'}) or return;
		my $self = \$sha;
		bless($self, $class);
		return $self->_putstate($state_packed);
	}
}

sub dump {
	my $self = shift;
	my $file = shift;

	my $state = $self->getstate or return;
	$file = "-" if (!defined($file) || $file eq "");

	local *FH;
	open(FH, "> $file") or return;
	print FH $state;
	close(FH);

	return($self);
}

sub load {
	my $class = shift;
	my $file = shift;

	$file = "-" if (!defined($file) || $file eq "");

	local *FH;
	open(FH, "< $file") or return;
	my $str = join('', <FH>);
	close(FH);

	$class->putstate($str);
}

Digest::SHA->bootstrap($VERSION);

1;
__END__

=head1 NAME

Digest::SHA - Perl extension for SHA-1/224/256/384/512

=head1 SYNOPSIS

In programs:

		# Functional interface

	use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);

	$digest = sha1($data);
	$digest = sha1_hex($data);
	$digest = sha1_base64($data);

	$digest = sha256($data);
	$digest = sha384_hex($data);
	$digest = sha512_base64($data);

		# Object-oriented

	use Digest::SHA;

	$sha = Digest::SHA->new($alg);

	$sha->add($data);		# feed data into stream

	$sha->addfile(*F);
	$sha->addfile($filename);

	$sha->add_bits($bits);
	$sha->add_bits($data, $nbits);

	$sha_copy = $sha->clone;	# make copy of digest object
	$state = $sha->getstate;	# save current state to string
	$sha->putstate($state);		# restore previous $state

	$digest = $sha->digest;		# compute digest
	$digest = $sha->hexdigest;
	$digest = $sha->b64digest;

From the command line:

	$ shasum files

	$ shasum --help

=head1 SYNOPSIS (HMAC-SHA)

		# Functional interface only

	use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);

	$digest = hmac_sha1($data, $key);
	$digest = hmac_sha224_hex($data, $key);
	$digest = hmac_sha256_base64($data, $key);

=head1 ABSTRACT

Digest::SHA is a complete implementation of the NIST Secure Hash Standard.
It gives Perl programmers a convenient way to calculate SHA-1, SHA-224,
SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests.
The module can handle all types of input, including partial-byte data.

=head1 DESCRIPTION

Digest::SHA is written in C for speed.  If your platform lacks a
C compiler, you can install the functionally equivalent (but much
slower) L<Digest::SHA::PurePerl> module.

The programming interface is easy to use: it's the same one found
in CPAN's L<Digest> module.  So, if your applications currently
use L<Digest::MD5> and you'd prefer the stronger security of SHA,
it's a simple matter to convert them.

The interface provides two ways to calculate digests:  all-at-once,
or in stages.  To illustrate, the following short program computes
the SHA-256 digest of "hello world" using each approach:

	use Digest::SHA qw(sha256_hex);

	$data = "hello world";
	@frags = split(//, $data);

	# all-at-once (Functional style)
	$digest1 = sha256_hex($data);

	# in-stages (OOP style)
	$state = Digest::SHA->new(256);
	for (@frags) { $state->add($_) }
	$digest2 = $state->hexdigest;

	print $digest1 eq $digest2 ?
		"whew!\n" : "oops!\n";

To calculate the digest of an n-bit message where I<n> is not a
multiple of 8, use the I<add_bits()> method.  For example, consider
the 446-bit message consisting of the bit-string "110" repeated
148 times, followed by "11".  Here's how to display its SHA-1
digest:

	use Digest::SHA;
	$bits = "110" x 148 . "11";
	$sha = Digest::SHA->new(1)->add_bits($bits);
	print $sha->hexdigest, "\n";

Note that for larger bit-strings, it's more efficient to use the
two-argument version I<add_bits($data, $nbits)>, where I<$data> is
in the customary packed binary format used for Perl strings.

The module also lets you save intermediate SHA states to a string.  The
I<getstate()> method generates portable, human-readable text describing
the current state of computation.  You can subsequently restore that
state with I<putstate()> to resume where the calculation left off.

To see what a state description looks like, just run the following:

	use Digest::SHA;
	print Digest::SHA->new->add("Shaw" x 1962)->getstate;

As an added convenience, the Digest::SHA module offers routines to
calculate keyed hashes using the HMAC-SHA-1/224/256/384/512
algorithms.  These services exist in functional form only, and
mimic the style and behavior of the I<sha()>, I<sha_hex()>, and
I<sha_base64()> functions.

	# Test vector from draft-ietf-ipsec-ciph-sha-256-01.txt

	use Digest::SHA qw(hmac_sha256_hex);
	print hmac_sha256_hex("Hi There", chr(0x0b) x 32), "\n";

=head1 UNICODE AND SIDE EFFECTS

Perl supports Unicode strings as of version 5.6.  Such strings may
contain wide characters, namely, characters whose ordinal values are
greater than 255.  This can cause problems for digest algorithms such
as SHA that are specified to operate on sequences of bytes.

The rule by which Digest::SHA handles a Unicode string is easy
to state, but potentially confusing to grasp: the string is interpreted
as a sequence of byte values, where each byte value is equal to the
ordinal value (viz. code point) of its corresponding Unicode character.
That way, the Unicode string 'abc' has exactly the same digest value as
the ordinary string 'abc'.

Since a wide character does not fit into a byte, the Digest::SHA
routines croak if they encounter one.  Whereas if a Unicode string
contains no wide characters, the module accepts it quite happily.
The following code illustrates the two cases:

	$str1 = pack('U*', (0..255));
	print sha1_hex($str1);		# ok

	$str2 = pack('U*', (0..256));
	print sha1_hex($str2);		# croaks

Be aware that the digest routines silently convert UTF-8 input into its
equivalent byte sequence in the native encoding (cf. utf8::downgrade).
This side effect influences only the way Perl stores the data internally,
but otherwise leaves the actual value of the data intact.

=head1 NIST STATEMENT ON SHA-1

NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a
practical collision attack on SHA-1.  Therefore, NIST encourages the
rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications
requiring strong collision resistance, such as digital signatures.

ref. L<http://csrc.nist.gov/groups/ST/hash/statement.html>

=head1 PADDING OF BASE64 DIGESTS

By convention, CPAN Digest modules do B<not> pad their Base64 output.
Problems can occur when feeding such digests to other software that
expects properly padded Base64 encodings.

For the time being, any necessary padding must be done by the user.
Fortunately, this is a simple operation: if the length of a Base64-encoded
digest isn't a multiple of 4, simply append "=" characters to the end
of the digest until it is:

	while (length($b64_digest) % 4) {
		$b64_digest .= '=';
	}

To illustrate, I<sha256_base64("abc")> is computed to be

	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0

which has a length of 43.  So, the properly padded version is

	ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=

=head1 EXPORT

None by default.

=head1 EXPORTABLE FUNCTIONS

Provided your C compiler supports a 64-bit type (e.g. the I<long
long> of C99, or I<__int64> used by Microsoft C/C++), all of these
functions will be available for use.  Otherwise, you won't be able
to perform the SHA-384 and SHA-512 transforms, both of which require
64-bit operations.

I<Functional style>

=over 4

=item B<sha1($data, ...)>

=item B<sha224($data, ...)>

=item B<sha256($data, ...)>

=item B<sha384($data, ...)>

=item B<sha512($data, ...)>

=item B<sha512224($data, ...)>

=item B<sha512256($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a binary string.

=item B<sha1_hex($data, ...)>

=item B<sha224_hex($data, ...)>

=item B<sha256_hex($data, ...)>

=item B<sha384_hex($data, ...)>

=item B<sha512_hex($data, ...)>

=item B<sha512224_hex($data, ...)>

=item B<sha512256_hex($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.

=item B<sha1_base64($data, ...)>

=item B<sha224_base64($data, ...)>

=item B<sha256_base64($data, ...)>

=item B<sha384_base64($data, ...)>

=item B<sha512_base64($data, ...)>

=item B<sha512224_base64($data, ...)>

=item B<sha512256_base64($data, ...)>

Logically joins the arguments into a single string, and returns
its SHA-1/224/256/384/512 digest encoded as a Base64 string.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

I<OOP style>

=over 4

=item B<new($alg)>

Returns a new Digest::SHA object.  Allowed values for I<$alg> are 1,
224, 256, 384, 512, 512224, or 512256.  It's also possible to use
common string representations of the algorithm (e.g. "sha256",
"SHA-384").  If the argument is missing, SHA-1 will be used by
default.

Invoking I<new> as an instance method will not create a new object;
instead, it will simply reset the object to the initial state
associated with I<$alg>.  If the argument is missing, the object
will continue using the same algorithm that was selected at creation.

=item B<reset($alg)>

This method has exactly the same effect as I<new($alg)>.  In fact,
I<reset> is just an alias for I<new>.

=item B<hashsize>

Returns the number of digest bits for this object.  The values are
160, 224, 256, 384, 512, 224, and 256 for SHA-1, SHA-224, SHA-256,
SHA-384, SHA-512, SHA-512/224 and SHA-512/256, respectively.

=item B<algorithm>

Returns the digest algorithm for this object.  The values are 1,
224, 256, 384, 512, 512224, and 512256 for SHA-1, SHA-224, SHA-256,
SHA-384, SHA-512, SHA-512/224, and SHA-512/256, respectively.

=item B<clone>

Returns a duplicate copy of the object.

=item B<add($data, ...)>

Logically joins the arguments into a single string, and uses it to
update the current digest state.  In other words, the following
statements have the same effect:

	$sha->add("a"); $sha->add("b"); $sha->add("c");
	$sha->add("a")->add("b")->add("c");
	$sha->add("a", "b", "c");
	$sha->add("abc");

The return value is the updated object itself.

=item B<add_bits($data, $nbits)>

=item B<add_bits($bits)>

Updates the current digest state by appending bits to it.  The
return value is the updated object itself.

The first form causes the most-significant I<$nbits> of I<$data>
to be appended to the stream.  The I<$data> argument is in the
customary binary format used for Perl strings.

The second form takes an ASCII string of "0" and "1" characters as
its argument.  It's equivalent to

	$sha->add_bits(pack("B*", $bits), length($bits));

So, the following two statements do the same thing:

	$sha->add_bits("111100001010");
	$sha->add_bits("\xF0\xA0", 12);

=item B<addfile(*FILE)>

Reads from I<FILE> until EOF, and appends that data to the current
state.  The return value is the updated object itself.

=item B<addfile($filename [, $mode])>

Reads the contents of I<$filename>, and appends that data to the current
state.  The return value is the updated object itself.

By default, I<$filename> is simply opened and read; no special modes
or I/O disciplines are used.  To change this, set the optional I<$mode>
argument to one of the following values:

	"b"	read file in binary mode

	"p"	use portable mode

	"0"	use BITS mode

The "p" mode ensures that the digest value of I<$filename> will be the
same when computed on different operating systems.  It accomplishes
this by internally translating all newlines in text files to UNIX format
before calculating the digest.  Binary files are read in raw mode with
no translation whatsoever.

The BITS mode ("0") interprets the contents of I<$filename> as a logical
stream of bits, where each ASCII '0' or '1' character represents a 0 or
1 bit, respectively.  All other characters are ignored.  This provides
a convenient way to calculate the digest values of partial-byte data by
using files, rather than having to write programs using the I<add_bits>
method.

=item B<getstate>

Returns a string containing a portable, human-readable representation
of the current SHA state.

=item B<putstate($str)>

Returns a Digest::SHA object representing the SHA state contained
in I<$str>.  The format of I<$str> matches the format of the output
produced by method I<getstate>.  If called as a class method, a new
object is created; if called as an instance method, the object is reset
to the state contained in I<$str>.

=item B<dump($filename)>

Writes the output of I<getstate> to I<$filename>.  If the argument is
missing, or equal to the empty string, the state information will be
written to STDOUT.

=item B<load($filename)>

Returns a Digest::SHA object that results from calling I<putstate> on
the contents of I<$filename>.  If the argument is missing, or equal to
the empty string, the state information will be read from STDIN.

=item B<digest>

Returns the digest encoded as a binary string.

Note that the I<digest> method is a read-once operation. Once it
has been performed, the Digest::SHA object is automatically reset
in preparation for calculating another digest value.  Call
I<$sha-E<gt>clone-E<gt>digest> if it's necessary to preserve the
original digest state.

=item B<hexdigest>

Returns the digest encoded as a hexadecimal string.

Like I<digest>, this method is a read-once operation.  Call
I<$sha-E<gt>clone-E<gt>hexdigest> if it's necessary to preserve
the original digest state.

This method is inherited if L<Digest::base> is installed on your
system.  Otherwise, a functionally equivalent substitute is used.

=item B<b64digest>

Returns the digest encoded as a Base64 string.

Like I<digest>, this method is a read-once operation.  Call
I<$sha-E<gt>clone-E<gt>b64digest> if it's necessary to preserve
the original digest state.

This method is inherited if L<Digest::base> is installed on your
system.  Otherwise, a functionally equivalent substitute is used.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

I<HMAC-SHA-1/224/256/384/512>

=over 4

=item B<hmac_sha1($data, $key)>

=item B<hmac_sha224($data, $key)>

=item B<hmac_sha256($data, $key)>

=item B<hmac_sha384($data, $key)>

=item B<hmac_sha512($data, $key)>

=item B<hmac_sha512224($data, $key)>

=item B<hmac_sha512256($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a binary string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

=item B<hmac_sha1_hex($data, $key)>

=item B<hmac_sha224_hex($data, $key)>

=item B<hmac_sha256_hex($data, $key)>

=item B<hmac_sha384_hex($data, $key)>

=item B<hmac_sha512_hex($data, $key)>

=item B<hmac_sha512224_hex($data, $key)>

=item B<hmac_sha512256_hex($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a hexadecimal string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

=item B<hmac_sha1_base64($data, $key)>

=item B<hmac_sha224_base64($data, $key)>

=item B<hmac_sha256_base64($data, $key)>

=item B<hmac_sha384_base64($data, $key)>

=item B<hmac_sha512_base64($data, $key)>

=item B<hmac_sha512224_base64($data, $key)>

=item B<hmac_sha512256_base64($data, $key)>

Returns the HMAC-SHA-1/224/256/384/512 digest of I<$data>/I<$key>,
with the result encoded as a Base64 string.  Multiple I<$data>
arguments are allowed, provided that I<$key> is the last argument
in the list.

It's important to note that the resulting string does B<not> contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See L</"PADDING OF BASE64 DIGESTS"> for details.

=back

=head1 SEE ALSO

L<Digest>, L<Digest::SHA::PurePerl>

The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:

L<http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf>

The Keyed-Hash Message Authentication Code (HMAC):

L<http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf>

=head1 AUTHOR

	Mark Shelor	<mshelor@cpan.org>

=head1 ACKNOWLEDGMENTS

The author is particularly grateful to

	Gisle Aas
	Sean Burke
	Chris Carey
	Alexandr Ciornii
	Jim Doble
	Thomas Drugeon
	Julius Duque
	Jeffrey Friedl
	Robert Gilmour
	Brian Gladman
	Adam Kennedy
	Andy Lester
	Alex Muntada
	Steve Peters
	Chris Skiscim
	Martin Thurn
	Gunnar Wolf
	Adam Woodbury

"who by trained skill rescued life from such great billows and such thick
darkness and moored it in so perfect a calm and in so brilliant a light"
- Lucretius

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2003-2014 Mark Shelor

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

L<perlartistic>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   package Digest::MD5;

use strict;
use vars qw($VERSION @ISA @EXPORT_OK);

$VERSION = '2.53';

require Exporter;
*import = \&Exporter::import;
@EXPORT_OK = qw(md5 md5_hex md5_base64);

eval {
    require Digest::base;
    push(@ISA, 'Digest::base');
};
if ($@) {
    my $err = $@;
    *add_bits = sub { die $err };
}


eval {
    require XSLoader;
    XSLoader::load('Digest::MD5', $VERSION);
};
if ($@) {
    my $olderr = $@;
    eval {
	# Try to load the pure perl version
	require Digest::Perl::MD5;

	Digest::Perl::MD5->import(qw(md5 md5_hex md5_base64));
	unshift(@ISA, "Digest::Perl::MD5");  # make OO interface work
    };
    if ($@) {
	# restore the original error
	die $olderr;
    }
}
else {
    *reset = \&new;
}

1;
__END__

=head1 NAME

Digest::MD5 - Perl interface to the MD5 Algorithm

=head1 SYNOPSIS

 # Functional style
 use Digest::MD5 qw(md5 md5_hex md5_base64);

 $digest = md5($data);
 $digest = md5_hex($data);
 $digest = md5_base64($data);

 # OO style
 use Digest::MD5;

 $ctx = Digest::MD5->new;

 $ctx->add($data);
 $ctx->addfile($file_handle);

 $digest = $ctx->digest;
 $digest = $ctx->hexdigest;
 $digest = $ctx->b64digest;

=head1 DESCRIPTION

The C<Digest::MD5> module allows you to use the RSA Data Security
Inc. MD5 Message Digest algorithm from within Perl programs.  The
algorithm takes as input a message of arbitrary length and produces as
output a 128-bit "fingerprint" or "message digest" of the input.

Note that the MD5 algorithm is not as strong as it used to be.  It has
since 2005 been easy to generate different messages that produce the
same MD5 digest.  It still seems hard to generate messages that
produce a given digest, but it is probably wise to move to stronger
algorithms for applications that depend on the digest to uniquely identify
a message.

The C<Digest::MD5> module provide a procedural interface for simple
use, as well as an object oriented interface that can handle messages
of arbitrary length and which can read files directly.

=head1 FUNCTIONS

The following functions are provided by the C<Digest::MD5> module.
None of these functions are exported by default.

=over 4

=item md5($data,...)

This function will concatenate all arguments, calculate the MD5 digest
of this "message", and return it in binary form.  The returned string
will be 16 bytes long.

The result of md5("a", "b", "c") will be exactly the same as the
result of md5("abc").

=item md5_hex($data,...)

Same as md5(), but will return the digest in hexadecimal form. The
length of the returned string will be 32 and it will only contain
characters from this set: '0'..'9' and 'a'..'f'.

=item md5_base64($data,...)

Same as md5(), but will return the digest as a base64 encoded string.
The length of the returned string will be 22 and it will only contain
characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
'/'.

Note that the base64 encoded string returned is not padded to be a
multiple of 4 bytes long.  If you want interoperability with other
base64 encoded md5 digests you might want to append the redundant
string "==" to the result.

=back

=head1 METHODS

The object oriented interface to C<Digest::MD5> is described in this
section.  After a C<Digest::MD5> object has been created, you will add
data to it and finally ask for the digest in a suitable format.  A
single object can be used to calculate multiple digests.

The following methods are provided:

=over 4

=item $md5 = Digest::MD5->new

The constructor returns a new C<Digest::MD5> object which encapsulate
the state of the MD5 message-digest algorithm.

If called as an instance method (i.e. $md5->new) it will just reset the
state the object to the state of a newly created object.  No new
object is created in this case.

=item $md5->reset

This is just an alias for $md5->new.

=item $md5->clone

This a copy of the $md5 object. It is useful when you do not want to
destroy the digests state, but need an intermediate value of the
digest, e.g. when calculating digests iteratively on a continuous data
stream.  Example:

    my $md5 = Digest::MD5->new;
    while (<>) {
	$md5->add($_);
	print "Line $.: ", $md5->clone->hexdigest, "\n";
    }

=item $md5->add($data,...)

The $data provided as argument are appended to the message we
calculate the digest for.  The return value is the $md5 object itself.

All these lines will have the same effect on the state of the $md5
object:

    $md5->add("a"); $md5->add("b"); $md5->add("c");
    $md5->add("a")->add("b")->add("c");
    $md5->add("a", "b", "c");
    $md5->add("abc");

=item $md5->addfile($io_handle)

The $io_handle will be read until EOF and its content appended to the
message we calculate the digest for.  The return value is the $md5
object itself.

The addfile() method will croak() if it fails reading data for some
reason.  If it croaks it is unpredictable what the state of the $md5
object will be in. The addfile() method might have been able to read
the file partially before it failed.  It is probably wise to discard
or reset the $md5 object if this occurs.

In most cases you want to make sure that the $io_handle is in
C<binmode> before you pass it as argument to the addfile() method.

=item $md5->add_bits($data, $nbits)

=item $md5->add_bits($bitstring)

Since the MD5 algorithm is byte oriented you might only add bits as
multiples of 8, so you probably want to just use add() instead.  The
add_bits() method is provided for compatibility with other digest
implementations.  See L<Digest> for description of the arguments
that add_bits() take.

=item $md5->digest

Return the binary digest for the message.  The returned string will be
16 bytes long.

Note that the C<digest> operation is effectively a destructive,
read-once operation. Once it has been performed, the C<Digest::MD5>
object is automatically C<reset> and can be used to calculate another
digest value.  Call $md5->clone->digest if you want to calculate the
digest without resetting the digest state.

=item $md5->hexdigest

Same as $md5->digest, but will return the digest in hexadecimal
form. The length of the returned string will be 32 and it will only
contain characters from this set: '0'..'9' and 'a'..'f'.

=item $md5->b64digest

Same as $md5->digest, but will return the digest as a base64 encoded
string.  The length of the returned string will be 22 and it will only
contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
and '/'.


The base64 encoded string returned is not padded to be a multiple of 4
bytes long.  If you want interoperability with other base64 encoded
md5 digests you might want to append the string "==" to the result.

=back


=head1 EXAMPLES

The simplest way to use this library is to import the md5_hex()
function (or one of its cousins):

    use Digest::MD5 qw(md5_hex);
    print "Digest is ", md5_hex("foobarbaz"), "\n";

The above example would print out the message:

    Digest is 6df23dc03f9b54cc38a0fc1483df6e21

The same checksum can also be calculated in OO style:

    use Digest::MD5;
    
    $md5 = Digest::MD5->new;
    $md5->add('foo', 'bar');
    $md5->add('baz');
    $digest = $md5->hexdigest;
    
    print "Digest is $digest\n";

With OO style, you can break the message arbitrarily.  This means that we
are no longer limited to have space for the whole message in memory, i.e.
we can handle messages of any size.

This is useful when calculating checksum for files:

    use Digest::MD5;

    my $filename = shift || "/etc/passwd";
    open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
    binmode($fh);

    $md5 = Digest::MD5->new;
    while (<$fh>) {
        $md5->add($_);
    }
    close($fh);
    print $md5->b64digest, " $filename\n";

Or we can use the addfile method for more efficient reading of
the file:

    use Digest::MD5;

    my $filename = shift || "/etc/passwd";
    open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
    binmode ($fh);

    print Digest::MD5->new->addfile($fh)->hexdigest, " $filename\n";

Since the MD5 algorithm is only defined for strings of bytes, it can not be
used on strings that contains chars with ordinal number above 255 (Unicode
strings).  The MD5 functions and methods will croak if you try to feed them
such input data:

    use Digest::MD5 qw(md5_hex);

    my $str = "abc\x{300}";
    print md5_hex($str), "\n";  # croaks
    # Wide character in subroutine entry

What you can do is calculate the MD5 checksum of the UTF-8
representation of such strings.  This is achieved by filtering the
string through encode_utf8() function:

    use Digest::MD5 qw(md5_hex);
    use Encode qw(encode_utf8);

    my $str = "abc\x{300}";
    print md5_hex(encode_utf8($str)), "\n";
    # 8c2d46911f3f5a326455f0ed7a8ed3b3

=head1 SEE ALSO

L<Digest>,
L<Digest::MD2>,
L<Digest::SHA>,
L<Digest::HMAC>

L<md5sum(1)>

RFC 1321

http://en.wikipedia.org/wiki/MD5

The paper "How to Break MD5 and Other Hash Functions" by Xiaoyun Wang
and Hongbo Yu.

=head1 COPYRIGHT

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

 Copyright 1998-2003 Gisle Aas.
 Copyright 1995-1996 Neil Winton.
 Copyright 1991-1992 RSA Data Security, Inc.

The MD5 algorithm is defined in RFC 1321. This implementation is
derived from the reference C code in RFC 1321 which is covered by
the following copyright statement:

=over 4

=item

Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.

=back

This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the GNU or Artistic
licenses.

=head1 AUTHORS

The original C<MD5> interface was written by Neil Winton
(C<N.Winton@axion.bt.co.uk>).

The C<Digest::MD5> module is written by Gisle Aas <gisle@ActiveState.com>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'sys/wait.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Hash::Util::FieldHash;

use 5.009004;
use strict;
use warnings;
use Scalar::Util qw( reftype);

our $VERSION = '1.15';

require Exporter;
our @ISA = qw(Exporter);
our %EXPORT_TAGS = (
    'all' => [ qw(
        fieldhash
        fieldhashes
        idhash
        idhashes
        id
        id_2obj
        register
    )],
);
our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

{
    require XSLoader;
    my %ob_reg; # private object registry
    sub _ob_reg { \ %ob_reg }
    XSLoader::load();
}

sub fieldhash (\%) {
    for ( shift ) {
        return unless ref() && reftype( $_) eq 'HASH';
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 0);
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 2) == 2;
        return;
    }
}

sub idhash (\%) {
    for ( shift ) {
        return unless ref() && reftype( $_) eq 'HASH';
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 0);
        return $_ if Hash::Util::FieldHash::_fieldhash( $_, 1) == 1;
        return;
    }
}

sub fieldhashes { map &fieldhash( $_), @_ }
sub idhashes { map &idhash( $_), @_ }

1;
__END__

=head1 NAME

Hash::Util::FieldHash - Support for Inside-Out Classes

=head1 SYNOPSIS

  ### Create fieldhashes
  use Hash::Util qw(fieldhash fieldhashes);

  # Create a single field hash
  fieldhash my %foo;

  # Create three at once...
  fieldhashes \ my(%foo, %bar, %baz);
  # ...or any number
  fieldhashes @hashrefs;

  ### Create an idhash and register it for garbage collection
  use Hash::Util::FieldHash qw(idhash register);
  idhash my %name;
  my $object = \ do { my $o };
  # register the idhash for garbage collection with $object
  register($object, \ %name);
  # the following entry will be deleted when $object goes out of scope
  $name{$object} = 'John Doe';

  ### Register an ordinary hash for garbage collection
  use Hash::Util::FieldHash qw(id register);
  my %name;
  my $object = \ do { my $o };
  # register the hash %name for garbage collection of $object's id
  register $object, \ %name;
  # the following entry will be deleted when $object goes out of scope
  $name{id $object} = 'John Doe';

=head1 FUNCTIONS

C<Hash::Util::FieldHash> offers a number of functions in support of
L<The Inside-out Technique> of class construction.

=over

=item id

    id($obj)

Returns the reference address of a reference $obj.  If $obj is
not a reference, returns $obj.

This function is a stand-in replacement for
L<Scalar::Util::refaddr|Scalar::Util/"$addr = refaddr( $ref )">,
that is, it returns
the reference address of its argument as a numeric value.  The only
difference is that C<refaddr()> returns C<undef> when given a
non-reference while C<id()> returns its argument unchanged.

C<id()> also uses a caching technique that makes it faster when
the id of an object is requested often, but slower if it is needed
only once or twice.

=item id_2obj

    $obj = id_2obj($id)

If C<$id> is the id of a registered object (see L</register>), returns
the object, otherwise an undefined value.  For registered objects this
is the inverse function of C<id()>.

=item register

    register($obj)
    register($obj, @hashrefs)

In the first form, registers an object to work with for the function
C<id_2obj()>.  In the second form, it additionally marks the given
hashrefs down for garbage collection.  This means that when the object
goes out of scope, any entries in the given hashes under the key of
C<id($obj)> will be deleted from the hashes.

It is a fatal error to register a non-reference $obj.  Any non-hashrefs
among the following arguments are silently ignored.

It is I<not> an error to register the same object multiple times with
varying sets of hashrefs.  Any hashrefs that are not registered yet
will be added, others ignored.

Registry also implies thread support.  When a new thread is created,
all references are replaced with new ones, including all objects.
If a hash uses the reference address of an object as a key, that
connection would be broken.  With a registered object, its id will
be updated in all hashes registered with it.

=item idhash

    idhash my %hash

Makes an idhash from the argument, which must be a hash.

An I<idhash> works like a normal hash, except that it stringifies a
I<reference used as a key> differently.  A reference is stringified
as if the C<id()> function had been invoked on it, that is, its
reference address in decimal is used as the key.

=item idhashes

    idhashes \ my(%hash, %gnash, %trash)
    idhashes \ @hashrefs

Creates many idhashes from its hashref arguments.  Returns those
arguments that could be converted or their number in scalar context.

=item fieldhash

    fieldhash %hash;

Creates a single fieldhash.  The argument must be a hash.  Returns
a reference to the given hash if successful, otherwise nothing.

A I<fieldhash> is, in short, an idhash with auto-registry.  When an
object (or, indeed, any reference) is used as a fieldhash key, the
fieldhash is automatically registered for garbage collection with
the object, as if C<register $obj, \ %fieldhash> had been called.

=item fieldhashes

    fieldhashes @hashrefs;

Creates any number of field hashes.  Arguments must be hash references.
Returns the converted hashrefs in list context, their number in scalar
context.

=back

=head1 DESCRIPTION

A word on terminology:  I shall use the term I<field> for a scalar
piece of data that a class associates with an object.  Other terms that
have been used for this concept are "object variable", "(object) property",
"(object) attribute" and more.  Especially "attribute" has some currency
among Perl programmer, but that clashes with the C<attributes> pragma.  The
term "field" also has some currency in this sense and doesn't seem
to conflict with other Perl terminology.

In Perl, an object is a blessed reference.  The standard way of associating
data with an object is to store the data inside the object's body, that is,
the piece of data pointed to by the reference.

In consequence, if two or more classes want to access an object they
I<must> agree on the type of reference and also on the organization of
data within the object body.  Failure to agree on the type results in
immediate death when the wrong method tries to access an object.  Failure
to agree on data organization may lead to one class trampling over the
data of another.

This object model leads to a tight coupling between subclasses.
If one class wants to inherit from another (and both classes access
object data), the classes must agree about implementation details.
Inheritance can only be used among classes that are maintained together,
in a single source or not.

In particular, it is not possible to write general-purpose classes
in this technique, classes that can advertise themselves as "Put me
on your @ISA list and use my methods".  If the other class has different
ideas about how the object body is used, there is trouble.

For reference C<Name_hash> in L</Example 1> shows the standard implementation of
a simple class C<Name> in the well-known hash based way.  It also demonstrates
the predictable failure to construct a common subclass C<NamedFile>
of C<Name> and the class C<IO::File> (whose objects I<must> be globrefs).

Thus, techniques are of interest that store object data I<not> in
the object body but some other place.

=head2 The Inside-out Technique

With I<inside-out> classes, each class declares a (typically lexical)
hash for each field it wants to use.  The reference address of an
object is used as the hash key.  By definition, the reference address
is unique to each object so this guarantees a place for each field that
is private to the class and unique to each object.  See C<Name_id>
in L</Example 1> for a simple example.

In comparison to the standard implementation where the object is a
hash and the fields correspond to hash keys, here the fields correspond
to hashes, and the object determines the hash key.  Thus the hashes
appear to be turned I<inside out>.

The body of an object is never examined by an inside-out class, only
its reference address is used.  This allows for the body of an actual
object to be I<anything at all> while the object methods of the class
still work as designed.  This is a key feature of inside-out classes.

=head2 Problems of Inside-out

Inside-out classes give us freedom of inheritance, but as usual there
is a price.

Most obviously, there is the necessity of retrieving the reference
address of an object for each data access.  It's a minor inconvenience,
but it does clutter the code.

More important (and less obvious) is the necessity of garbage
collection.  When a normal object dies, anything stored in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows nothing about the data stored in field hashes by a class,
but these must be deleted when the object goes out of scope.  Thus
the class must provide a C<DESTROY> method to take care of that.

In the presence of multiple classes it can be non-trivial
to make sure that every relevant destructor is called for
every object.  Perl calls the first one it finds on the
inheritance tree (if any) and that's it.

A related issue is thread-safety.  When a new thread is created,
the Perl interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones.  Thus, if a class
tries to access a field of a cloned object its (cloned) data will
still be stored under the now invalid reference address of the
original in the parent thread.  A general C<CLONE> method must
be provided to re-establish the association.

=head2 Solutions

C<Hash::Util::FieldHash> addresses these issues on several
levels.

The C<id()> function is provided in addition to the
existing C<Scalar::Util::refaddr()>.  Besides its short name
it can be a little faster under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
working of C<id()> also allows the use of the class name
as a I<generic object> as described L<further down|/"The Generic Object">.

The C<id()> function is incorporated in I<id hashes> in the sense
that it is called automatically on every key that is used with
the hash.  No explicit call is necessary.

The problems of garbage collection and thread safety are both
addressed by the function C<register()>.  It registers an object
together with any number of hashes.  Registry means that when the
object dies, an entry in any of the hashes under the reference
address of this object will be deleted.  This guarantees garbage
collection in these hashes.  It also means that on thread
cloning the object's entries in registered hashes will be
replaced with updated entries whose key is the cloned object's
reference address.  Thus the object-data association becomes
thread-safe.

Object registry is best done when the object is initialized
for use with a class.  That way, garbage collection and thread
safety are established for every object and every field that is
initialized.

Finally, I<field hashes> incorporate all these functions in one
package.  Besides automatically calling the C<id()> function
on every object used as a key, the object is registered with
the field hash on first use.  Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.

=head2 More Problems

Another problem that occurs with inside-out classes is serialization.
Since the object data is not in its usual place, standard routines
like C<Storable::freeze()>, C<Storable::thaw()> and 
C<Data::Dumper::Dumper()> can't deal with it on their own.  Both
C<Data::Dumper> and C<Storable> provide the necessary hooks to
make things work, but the functions or methods used by the hooks
must be provided by each inside-out class.

A general solution to the serialization problem would require another
level of registry, one that associates I<classes> and fields.
So far, the functions of C<Hash::Util::FieldHash> are unaware of
any classes, which I consider a feature.  Therefore C<Hash::Util::FieldHash>
doesn't address the serialization problems.

=head2 The Generic Object

Classes based on the C<id()> function (and hence classes based on
C<idhash()> and C<fieldhash()>) show a peculiar behavior in that
the class name can be used like an object.  Specifically, methods
that set or read data associated with an object continue to work as
class methods, just as if the class name were an object, distinct from
all other objects, with its own data.  This object may be called
the I<generic object> of the class.

This works because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the hash key.
Thus, if a method is called as a class method, the field hash is presented
with the class name instead of an object and blithely uses it as a key.
Since the keys of real objects are decimal numbers, there is no
conflict and the slot in the field hash can be used like any other.
The C<id()> function behaves correspondingly with respect to non-reference
arguments.

Two possible uses (besides ignoring the property) come to mind.
A singleton class could be implemented this using the generic object.
If necessary, an C<init()> method could die or ignore calls with
actual objects (references), so only the generic object will ever exist.

Another use of the generic object would be as a template.  It is
a convenient place to store class-specific defaults for various
fields to be used in actual object initialization.

Usually, the feature can be entirely ignored.  Calling I<object
methods> as I<class methods> normally leads to an error and isn't used
routinely anywhere.  It may be a problem that this error isn't
indicated by a class with a generic object.

=head2 How to use Field Hashes

Traditionally, the definition of an inside-out class contains a bare
block inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through C<Scalar::Util::refaddr>.
Further methods may be defined outside this block.  There has to be
a DESTROY method and, for thread support, a CLONE method.

When field hashes are used, the basic structure remains the same.
Each lexical hash will be made a field hash.  The call to C<refaddr>
can be omitted from the accessor methods.  DESTROY and CLONE methods
are not necessary.

If you have an existing inside-out class, simply making all hashes
field hashes with no other change should make no difference.  Through
the calls to C<refaddr> or equivalent, the field hashes never get to
see a reference and work like normal hashes.  Your DESTROY (and
CLONE) methods are still needed.

To make the field hashes kick in, it is easiest to redefine C<refaddr>
as

    sub refaddr { shift }

instead of importing it from C<Scalar::Util>.  It should now be possible
to disable DESTROY and CLONE.  Note that while it isn't disabled,
DESTROY will be called before the garbage collection of field hashes,
so it will be invoked with a functional object and will continue to
function.

It is not desirable to import the functions C<fieldhash> and/or
C<fieldhashes> into every class that is going to use them.  They
are only used once to set up the class.  When the class is up and running,
these functions serve no more purpose.

If there are only a few field hashes to declare, it is simplest to

    use Hash::Util::FieldHash;

early and call the functions qualified:

    Hash::Util::FieldHash::fieldhash my %foo;

Otherwise, import the functions into a convenient package like
C<HUF> or, more general, C<Aux>

    {
        package Aux;
        use Hash::Util::FieldHash ':all';
    }

and call

    Aux::fieldhash my %foo;

as needed.

=head2 Garbage-Collected Hashes

Garbage collection in a field hash means that entries will "spontaneously"
disappear when the object that created them disappears.  That must be
borne in mind, especially when looping over a field hash.  If anything
you do inside the loop could cause an object to go out of scope, a
random key may be deleted from the hash you are looping over.  That
can throw the loop iterator, so it's best to cache a consistent snapshot
of the keys and/or values and loop over that.  You will still have to
check that a cached entry still exists when you get to it.

Garbage collection can be confusing when keys are created in a field hash
from normal scalars as well as references.  Once a reference is I<used> with
a field hash, the entry will be collected, even if it was later overwritten
with a plain scalar key (every positive integer is a candidate).  This
is true even if the original entry was deleted in the meantime.  In fact,
deletion from a field hash, and also a test for existence constitute
I<use> in this sense and create a liability to delete the entry when
the reference goes out of scope.  If you happen to create an entry
with an identical key from a string or integer, that will be collected
instead.  Thus, mixed use of references and plain scalars as field hash
keys is not entirely supported.

=head1 EXAMPLES

The examples show a very simple class that implements a I<name>, consisting
of a first and last name (no middle initial).  The name class has four
methods:

=over

=item * C<init()>

An object method that initializes the first and last name to its
two arguments. If called as a class method, C<init()> creates an
object in the given class and initializes that.

=item * C<first()>

Retrieve the first name

=item * C<last()>

Retrieve the last name

=item * C<name()>

Retrieve the full name, the first and last name joined by a blank.

=back

The examples show this class implemented with different levels of
support by C<Hash::Util::FieldHash>.  All supported combinations
are shown.  The difference between implementations is often quite
small.  The implementations are:

=over

=item * C<Name_hash>

A conventional (not inside-out) implementation where an object is
a hash that stores the field values, without support by
C<Hash::Util::FieldHash>.  This implementation doesn't allow
arbitrary inheritance.

=item * C<Name_id>

Inside-out implementation based on the C<id()> function.  It needs
a C<DESTROY> method.  For thread support a C<CLONE> method (not shown)
would also be needed.  Instead of C<Hash::Util::FieldHash::id()> the
function C<Scalar::Util::refaddr> could be used with very little
functional difference.  This is the basic pattern of an inside-out
class.

=item * C<Name_idhash>

Idhash-based inside-out implementation.  Like C<Name_id> it needs
a C<DESTROY> method and would need C<CLONE> for thread support.

=item * C<Name_id_reg>

Inside-out implementation based on the C<id()> function with explicit
object registry.  No destructor is needed and objects are thread safe.

=item * C<Name_idhash_reg>

Idhash-based inside-out implementation with explicit object registry.
No destructor is needed and objects are thread safe.

=item * C<Name_fieldhash>

FieldHash-based inside-out implementation.  Object registry happens
automatically.  No destructor is needed and objects are thread safe.

=back

These examples are realized in the code below, which could be copied
to a file F<Example.pm>.

=head2 Example 1

    use strict; use warnings;

    {
        package Name_hash;  # standard implementation: the
                            # object is a hash
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless {}, $obj unless ref $obj;
            $obj->{ first} = $first;
            $obj->{ last} = $last;
            $obj;
        }

        sub first { shift()->{ first} }
        sub last { shift()->{ last} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

    }

    {
        package Name_id;
        use Hash::Util::FieldHash qw(id);

        my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }

        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

        sub DESTROY {
            my $id = id shift;
            delete $first{ $id};
            delete $last{ $id};
        }

    }

    {
        package Name_idhash;
        use Hash::Util::FieldHash;

        Hash::Util::FieldHash::idhashes( \ my (%first, %last) );

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }

        sub DESTROY {
            my $n = shift;
            delete $first{ $n};
            delete $last{ $n};
        }

    }

    {
        package Name_id_reg;
        use Hash::Util::FieldHash qw(id register);

        my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }

        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    {
        package Name_idhash_reg;
        use Hash::Util::FieldHash qw(register);

        Hash::Util::FieldHash::idhashes \ my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    {
        package Name_fieldhash;
        use Hash::Util::FieldHash;

        Hash::Util::FieldHash::fieldhashes \ my (%first, %last);

        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }

        sub first { $first{ shift()} }
        sub last { $last{ shift()} }

        sub name {
            my $n = shift;
            join ' ' => $n->first, $n->last;
        }
    }

    1;

To exercise the various implementations the script L<below|/"Example 2"> can
be used.

It sets up a class C<Name> that is a mirror of one of the implementation
classes C<Name_hash>, C<Name_id>, ..., C<Name_fieldhash>.  That determines
which implementation is run.

The script first verifies the function of the C<Name> class.

In the second step, the free inheritability of the implementation
(or lack thereof) is demonstrated.  For this purpose it constructs
a class called C<NamedFile> which is a common subclass of C<Name> and
the standard class C<IO::File>.  This puts inheritability to the test
because objects of C<IO::File> I<must> be globrefs.  Objects of C<NamedFile>
should behave like a file opened for reading and also support the C<name()>
method.  This class juncture works with exception of the C<Name_hash>
implementation, where object initialization fails because of the
incompatibility of object bodies.

=head2 Example 2

    use strict; use warnings; $| = 1;

    use Example;

    {
        package Name;
        use parent 'Name_id';  # define here which implementation to run
    }


    # Verify that the base package works
    my $n = Name->init(qw(Albert Einstein));
    print $n->name, "\n";
    print "\n";

    # Create a named file handle (See definition below)
    my $nf = NamedFile->init(qw(/tmp/x Filomena File));
    # use as a file handle...
    for ( 1 .. 3 ) {
        my $l = <$nf>;
        print "line $_: $l";
    }
    # ...and as a Name object
    print "...brought to you by ", $nf->name, "\n";
    exit;


    # Definition of NamedFile
    package NamedFile;
    use parent 'Name';
    use parent 'IO::File';

    sub init {
        my $obj = shift;
        my ($file, $first, $last) = @_;
        $obj = $obj->IO::File::new() unless ref $obj;
        $obj->open($file) or die "Can't read '$file': $!";
        $obj->Name::init($first, $last);
    }
    __END__


=head1 GUTS

To make C<Hash::Util::FieldHash> work, there were two changes to
F<perl> itself.  C<PERL_MAGIC_uvar> was made available for hashes,
and weak references now call uvar C<get> magic after a weakref has been
cleared.  The first feature is used to make field hashes intercept
their keys upon access.  The second one triggers garbage collection.

=head2 The C<PERL_MAGIC_uvar> interface for hashes

C<PERL_MAGIC_uvar> I<get> magic is called from C<hv_fetch_common> and
C<hv_delete_common> through the function C<hv_magic_uvar_xkey>, which
defines the interface.  The call happens for hashes with "uvar" magic
if the C<ufuncs> structure has equal values in the C<uf_val> and C<uf_set>
fields.  Hashes are unaffected if (and as long as) these fields
hold different values.

Upon the call, the C<mg_obj> field will hold the hash key to be accessed.
Upon return, the C<SV*> value in C<mg_obj> will be used in place of the
original key in the hash access.  The integer index value in the first
parameter will be the C<action> value from C<hv_fetch_common>, or -1
if the call is from C<hv_delete_common>.

This is a template for a function suitable for the C<uf_val> field in
a C<ufuncs> structure for this call.  The C<uf_set> and C<uf_index>
fields are irrelevant.

    IV watch_key(pTHX_ IV action, SV* field) {
        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
        SV* keysv = mg->mg_obj;
        /* Do whatever you need to.  If you decide to
           supply a different key newkey, return it like this
        */
        sv_2mortal(newkey);
        mg->mg_obj = newkey;
        return 0;
    }

=head2 Weakrefs call uvar magic

When a weak reference is stored in an C<SV> that has "uvar" magic, C<set>
magic is called after the reference has gone stale.  This hook can be
used to trigger further garbage-collection activities associated with
the referenced object.

=head2 How field hashes work

The three features of key hashes, I<key replacement>, I<thread support>,
and I<garbage collection> are supported by a data structure called
the I<object registry>.  This is a private hash where every object
is stored.  An "object" in this sense is any reference (blessed or
unblessed) that has been used as a field hash key.

The object registry keeps track of references that have been used as
field hash keys.  The keys are generated from the reference address
like in a field hash (though the registry isn't a field hash).  Each
value is a weak copy of the original reference, stored in an C<SV> that
is itself magical (C<PERL_MAGIC_uvar> again).  The magical structure
holds a list (another hash, really) of field hashes that the reference
has been used with.  When the weakref becomes stale, the magic is
activated and uses the list to delete the reference from all field
hashes it has been used with.  After that, the entry is removed from
the object registry itself.  Implicitly, that frees the magic structure
and the storage it has been using.

Whenever a reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary.  The field hash is
then added to the list of fields this reference has used.

The object registry is also used to repair a field hash after thread
cloning.  Here, the entire object registry is processed.  For every
reference found there, the field hashes it has used are visited and
the entry is updated.

=head2 Internal function Hash::Util::FieldHash::_fieldhash

    # test if %hash is a field hash
    my $result = _fieldhash \ %hash, 0;

    # make %hash a field hash
    my $result = _fieldhash \ %hash, 1;

C<_fieldhash> is the internal function used to create field hashes.
It takes two arguments, a hashref and a mode.  If the mode is boolean
false, the hash is not changed but tested if it is a field hash.  If
the hash isn't a field hash the return value is boolean false.  If it
is, the return value indicates the mode of field hash.  When called with
a boolean true mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.  C<_fieldhash>
does not erase the given hash.

Currently there is only one type of field hash, and only the boolean
value of the mode makes a difference, but that may change.

=head1 AUTHOR

Anno Siegel (ANNO) wrote the xs code and the changes in perl proper
Jerry Hedden (JDHEDDEN) made it faster

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2006-2007 by (Anno Siegel)

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #
# $Id: Encode.pm,v 2.60 2014/04/29 16:26:49 dankogai Exp dankogai $
#
package Encode;
use strict;
use warnings;
our $VERSION = sprintf "%d.%02d", q$Revision: 2.60_01 $ =~ /(\d+)/g;
use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
use XSLoader ();
XSLoader::load( __PACKAGE__, $VERSION );

use Exporter 5.57 'import';

# Public, encouraged API is exported by default

our @EXPORT = qw(
  decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
  encodings  find_encoding clone_encoding
);
our @FB_FLAGS = qw(
  DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
  PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
);
our @FB_CONSTS = qw(
  FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
  FB_PERLQQ FB_HTMLCREF FB_XMLCREF
);
our @EXPORT_OK = (
    qw(
      _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
      is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
      ),
    @FB_FLAGS, @FB_CONSTS,
);

our %EXPORT_TAGS = (
    all          => [ @EXPORT,    @EXPORT_OK ],
    default      => [ @EXPORT ],
    fallbacks    => [ @FB_CONSTS ],
    fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
);

# Documentation moved after __END__ for speed - NI-S

our $ON_EBCDIC = ( ord("A") == 193 );

use Encode::Alias;

# Make a %Encoding package variable to allow a certain amount of cheating
our %Encoding;
our %ExtModule;
require Encode::Config;
#  See
#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
#  to find why sig handlers inside eval{} are disabled.
eval {
    local $SIG{__DIE__};
    local $SIG{__WARN__};
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    require Encode::ConfigLocal;
};

sub encodings {
    my %enc;
    my $arg  = $_[1] || '';
    if ( $arg eq ":all" ) {
        %enc = ( %Encoding, %ExtModule );
    }
    else {
        %enc = %Encoding;
        for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
            DEBUG and warn $mod;
            for my $enc ( keys %ExtModule ) {
                $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
            }
        }
    }
    return sort { lc $a cmp lc $b }
      grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
}

sub perlio_ok {
    my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
    $obj->can("perlio_ok") and return $obj->perlio_ok();
    return 0;    # safety net
}

sub define_encoding {
    my $obj  = shift;
    my $name = shift;
    $Encoding{$name} = $obj;
    my $lc = lc($name);
    define_alias( $lc => $obj ) unless $lc eq $name;
    while (@_) {
        my $alias = shift;
        define_alias( $alias, $obj );
    }
    return $obj;
}

sub getEncoding {
    my ( $class, $name, $skip_external ) = @_;

    $name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796

    ref($name) && $name->can('renew') and return $name;
    exists $Encoding{$name} and return $Encoding{$name};
    my $lc = lc $name;
    exists $Encoding{$lc} and return $Encoding{$lc};

    my $oc = $class->find_alias($name);
    defined($oc) and return $oc;
    $lc ne $name and $oc = $class->find_alias($lc);
    defined($oc) and return $oc;

    unless ($skip_external) {
        if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
            $mod =~ s,::,/,g;
            $mod .= '.pm';
            eval { require $mod; };
            exists $Encoding{$name} and return $Encoding{$name};
        }
    }
    return;
}

sub find_encoding($;$) {
    my ( $name, $skip_external ) = @_;
    return __PACKAGE__->getEncoding( $name, $skip_external );
}

sub resolve_alias($) {
    my $obj = find_encoding(shift);
    defined $obj and return $obj->name;
    return;
}

sub clone_encoding($) {
    my $obj = find_encoding(shift);
    ref $obj or return;
    eval { require Storable };
    $@ and return;
    return Storable::dclone($obj);
}

sub encode($$;$) {
    my ( $name, $string, $check ) = @_;
    return undef unless defined $string;
    $string .= '';    # stringify;
    $check ||= 0;
    unless ( defined $name ) {
        require Carp;
        Carp::croak("Encoding name should not be undef");
    }
    my $enc = find_encoding($name);
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
    }
    my $octets = $enc->encode( $string, $check );
    $_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
    return $octets;
}
*str2bytes = \&encode;

sub decode($$;$) {
    my ( $name, $octets, $check ) = @_;
    return undef unless defined $octets;
    $octets .= '';
    $check ||= 0;
    my $enc = find_encoding($name);
    unless ( defined $enc ) {
        require Carp;
        Carp::croak("Unknown encoding '$name'");
    }
    my $string = $enc->decode( $octets, $check );
    $_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
    return $string;
}
*bytes2str = \&decode;

sub from_to($$$;$) {
    my ( $string, $from, $to, $check ) = @_;
    return undef unless defined $string;
    $check ||= 0;
    my $f = find_encoding($from);
    unless ( defined $f ) {
        require Carp;
        Carp::croak("Unknown encoding '$from'");
    }
    my $t = find_encoding($to);
    unless ( defined $t ) {
        require Carp;
        Carp::croak("Unknown encoding '$to'");
    }
    my $uni = $f->decode($string);
    $_[0] = $string = $t->encode( $uni, $check );
    return undef if ( $check && length($uni) );
    return defined( $_[0] ) ? length($string) : undef;
}

sub encode_utf8($) {
    my ($str) = @_;
    utf8::encode($str);
    return $str;
}

my $utf8enc;

sub decode_utf8($;$) {
    my ( $octets, $check ) = @_;
    return undef unless defined $octets;
    $octets .= '';
    $check   ||= 0;
    $utf8enc ||= find_encoding('utf8');
    my $string = $utf8enc->decode( $octets, $check );
    $_[0] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
    return $string;
}

# sub decode_utf8($;$) {
#     my ( $str, $check ) = @_;
#     return $str if is_utf8($str);
#     if ($check) {
#         return decode( "utf8", $str, $check );
#     }
#     else {
#         return decode( "utf8", $str );
#         return $str;
#     }
# }

predefine_encodings(1);

#
# This is to restore %Encoding if really needed;
#

sub predefine_encodings {
    require Encode::Encoding;
    no warnings 'redefine';
    my $use_xs = shift;
    if ($ON_EBCDIC) {

        # was in Encode::UTF_EBCDIC
        package Encode::UTF_EBCDIC;
        push @Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( undef, $str, $chk ) = @_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        *encode = sub {
            my ( undef, $str, $chk ) = @_;
            my $res = '';
            for ( my $i = 0 ; $i < length($str) ; $i++ ) {
                $res .=
                  chr(
                    utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                  );
            }
            $_[1] = '' if $chk;
            return $res;
        };
        $Encode::Encoding{Unicode} =
          bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
    }
    else {

        package Encode::Internal;
        push @Encode::Internal::ISA, 'Encode::Encoding';
        *decode = sub {
            my ( undef, $str, $chk ) = @_;
            utf8::upgrade($str);
            $_[1] = '' if $chk;
            return $str;
        };
        *encode = \&decode;
        $Encode::Encoding{Unicode} =
          bless { Name => "Internal" } => "Encode::Internal";
    }

    {

        # was in Encode::utf8
        package Encode::utf8;
        push @Encode::utf8::ISA, 'Encode::Encoding';

        #
        if ($use_xs) {
            Encode::DEBUG and warn __PACKAGE__, " XS on";
            *decode = \&decode_xs;
            *encode = \&encode_xs;
        }
        else {
            Encode::DEBUG and warn __PACKAGE__, " XS off";
            *decode = sub {
                my ( undef, $octets, $chk ) = @_;
                my $str = Encode::decode_utf8($octets);
                if ( defined $str ) {
                    $_[1] = '' if $chk;
                    return $str;
                }
                return undef;
            };
            *encode = sub {
                my ( undef, $string, $chk ) = @_;
                my $octets = Encode::encode_utf8($string);
                $_[1] = '' if $chk;
                return $octets;
            };
        }
        *cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
                               # currently ignores $chk
            my ( undef, undef, undef, $pos, $trm ) = @_;
            my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
            use bytes;
            if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
                $$rdst .=
                  substr( $$rsrc, $pos, $npos - $pos + length($trm) );
                $$rpos = $npos + length($trm);
                return 1;
            }
            $$rdst .= substr( $$rsrc, $pos );
            $$rpos = length($$rsrc);
            return '';
        };
        $Encode::Encoding{utf8} =
          bless { Name => "utf8" } => "Encode::utf8";
        $Encode::Encoding{"utf-8-strict"} =
          bless { Name => "utf-8-strict", strict_utf8 => 1 } 
            => "Encode::utf8";
    }
}

1;

__END__

=head1 NAME

Encode - character encodings in Perl

=head1 SYNOPSIS

    use Encode qw(decode encode);
    $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
    $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);

=head2 Table of Contents

Encode consists of a collection of modules whose details are too extensive
to fit in one document.  This one itself explains the top-level APIs
and general topics at a glance.  For other topics and more details,
see the documentation for these modules:

=over 2

=item L<Encode::Alias> - Alias definitions to encodings

=item L<Encode::Encoding> - Encode Implementation Base Class

=item L<Encode::Supported> - List of Supported Encodings

=item L<Encode::CN> - Simplified Chinese Encodings

=item L<Encode::JP> - Japanese Encodings

=item L<Encode::KR> - Korean Encodings

=item L<Encode::TW> - Traditional Chinese Encodings

=back

=head1 DESCRIPTION

The C<Encode> module provides the interface between Perl strings
and the rest of the system.  Perl strings are sequences of
I<characters>.

The repertoire of characters that Perl can represent is a superset of those
defined by the Unicode Consortium. On most platforms the ordinal
values of a character as returned by C<ord(I<S>)> is the I<Unicode
codepoint> for that character. The exceptions are platforms where
the legacy encoding is some variant of EBCDIC rather than a superset
of ASCII; see L<perlebcdic>.

During recent history, data is moved around a computer in 8-bit chunks,
often called "bytes" but also known as "octets" in standards documents.
Perl is widely used to manipulate data of many types: not only strings of
characters representing human or computer languages, but also "binary"
data, being the machine's representation of numbers, pixels in an image, or
just about anything.

When Perl is processing "binary data", the programmer wants Perl to
process "sequences of bytes". This is not a problem for Perl: because a
byte has 256 possible values, it easily fits in Perl's much larger
"logical character".

This document mostly explains the I<how>. L<perlunitut> and L<perlunifaq>
explain the I<why>.

=head2 TERMINOLOGY

=head3 character

A character in the range 0 .. 2**32-1 (or more);
what Perl's strings are made of.

=head3 byte

A character in the range 0..255;
a special case of a Perl character.

=head3 octet

8 bits of data, with ordinal values 0..255;
term for bytes passed to or from a non-Perl context, such as a disk file,
standard I/O stream, database, command-line argument, environment variable,
socket etc.

=head1 THE PERL ENCODING API

=head2 Basic methods

=head3 encode

  $octets  = encode(ENCODING, STRING[, CHECK])

Encodes the scalar value I<STRING> from Perl's internal form into
I<ENCODING> and returns a sequence of octets.  I<ENCODING> can be either a
canonical name or an alias.  For encoding names and aliases, see
L</"Defining Aliases">.  For CHECK, see L</"Handling Malformed Data">.

For example, to convert a string from Perl's internal format into
ISO-8859-1, also known as Latin1:

  $octets = encode("iso-8859-1", $string);

B<CAVEAT>: When you run C<$octets = encode("utf8", $string)>, then
$octets I<might not be equal to> $string.  Though both contain the
same data, the UTF8 flag for $octets is I<always> off.  When you
encode anything, the UTF8 flag on the result is always off, even when it
contains a completely valid utf8 string. See L</"The UTF8 flag"> below.

If the $string is C<undef>, then C<undef> is returned.

=head3 decode

  $string = decode(ENCODING, OCTETS[, CHECK])

This function returns the string that results from decoding the scalar
value I<OCTETS>, assumed to be a sequence of octets in I<ENCODING>, into
Perl's internal form.  The returns the resulting string.  As with encode(),
I<ENCODING> can be either a canonical name or an alias. For encoding names
and aliases, see L</"Defining Aliases">; for I<CHECK>, see L</"Handling
Malformed Data">.

For example, to convert ISO-8859-1 data into a string in Perl's
internal format:

  $string = decode("iso-8859-1", $octets);

B<CAVEAT>: When you run C<$string = decode("utf8", $octets)>, then $string
I<might not be equal to> $octets.  Though both contain the same data, the
UTF8 flag for $string is on.  See L</"The UTF8 flag">
below.

If the $string is C<undef>, then C<undef> is returned.

=head3 find_encoding

  [$obj =] find_encoding(ENCODING)

Returns the I<encoding object> corresponding to I<ENCODING>.  Returns
C<undef> if no matching I<ENCODING> is find.  The returned object is
what does the actual encoding or decoding.

  $utf8 = decode($name, $bytes);

is in fact

    $utf8 = do {
        $obj = find_encoding($name);
        croak qq(encoding "$name" not found) unless ref $obj;
        $obj->decode($bytes);
    };

with more error checking.

You can therefore save time by reusing this object as follows;

    my $enc = find_encoding("iso-8859-1");
    while(<>) {
        my $utf8 = $enc->decode($_);
        ... # now do something with $utf8;
    }

Besides L</decode> and L</encode>, other methods are
available as well.  For instance, C<name()> returns the canonical
name of the encoding object.

  find_encoding("latin1")->name; # iso-8859-1

See L<Encode::Encoding> for details.

=head3 from_to

  [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])

Converts I<in-place> data between two encodings. The data in $octets
must be encoded as octets and I<not> as characters in Perl's internal
format. For example, to convert ISO-8859-1 data into Microsoft's CP1250
encoding:

  from_to($octets, "iso-8859-1", "cp1250");

and to convert it back:

  from_to($octets, "cp1250", "iso-8859-1");

Because the conversion happens in place, the data to be
converted cannot be a string constant: it must be a scalar variable.

C<from_to()> returns the length of the converted string in octets on success,
and C<undef> on error.

B<CAVEAT>: The following operations may look the same, but are not:

  from_to($data, "iso-8859-1", "utf8"); #1
  $data = decode("iso-8859-1", $data);  #2

Both #1 and #2 make $data consist of a completely valid UTF-8 string,
but only #2 turns the UTF8 flag on.  #1 is equivalent to:

  $data = encode("utf8", decode("iso-8859-1", $data));

See L</"The UTF8 flag"> below.

Also note that:

  from_to($octets, $from, $to, $check);

is equivalent t:o

  $octets = encode($to, decode($from, $octets), $check);

Yes, it does I<not> respect the $check during decoding.  It is
deliberately done that way.  If you need minute control, use C<decode>
followed by C<encode> as follows:

  $octets = encode($to, decode($from, $octets, $check_from), $check_to);

=head3 encode_utf8

  $octets = encode_utf8($string);

Equivalent to C<$octets = encode("utf8", $string)>.  The characters in
$string are encoded in Perl's internal format, and the result is returned
as a sequence of octets.  Because all possible characters in Perl have a
(loose, not strict) UTF-8 representation, this function cannot fail.

=head3 decode_utf8

  $string = decode_utf8($octets [, CHECK]);

Equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
The sequence of octets represented by $octets is decoded
from UTF-8 into a sequence of logical characters.
Because not all sequences of octets are valid UTF-8,
it is quite possible for this function to fail.
For CHECK, see L</"Handling Malformed Data">.

=head2 Listing available encodings

  use Encode;
  @list = Encode->encodings();

Returns a list of canonical names of available encodings that have already
been loaded.  To get a list of all available encodings including those that
have not yet been loaded, say:

  @all_encodings = Encode->encodings(":all");

Or you can give the name of a specific module:

  @with_jp = Encode->encodings("Encode::JP");

When "C<::>" is not in the name, "C<Encode::>" is assumed.

  @ebcdic = Encode->encodings("EBCDIC");

To find out in detail which encodings are supported by this package,
see L<Encode::Supported>.

=head2 Defining Aliases

To add a new alias to a given encoding, use:

  use Encode;
  use Encode::Alias;
  define_alias(NEWNAME => ENCODING);

After that, I<NEWNAME> can be used as an alias for I<ENCODING>.
I<ENCODING> may be either the name of an encoding or an
I<encoding object>.

Before you do that, first make sure the alias is nonexistent using
C<resolve_alias()>, which returns the canonical name thereof.
For example:

  Encode::resolve_alias("latin1") eq "iso-8859-1" # true
  Encode::resolve_alias("iso-8859-12")   # false; nonexistent
  Encode::resolve_alias($name) eq $name  # true if $name is canonical

C<resolve_alias()> does not need C<use Encode::Alias>; it can be
imported via C<use Encode qw(resolve_alias)>.

See L<Encode::Alias> for details.

=head2 Finding IANA Character Set Registry names

The canonical name of a given encoding does not necessarily agree with
IANA Character Set Registry, commonly seen as C<< Content-Type:
text/plain; charset=I<WHATEVER> >>.  For most cases, the canonical name
works, but sometimes it does not, most notably with "utf-8-strict".

As of C<Encode> version 2.21, a new method C<mime_name()> is therefore added.

  use Encode;
  my $enc = find_encoding("UTF-8");
  warn $enc->name;      # utf-8-strict
  warn $enc->mime_name; # UTF-8

See also:  L<Encode::Encoding>

=head1 Encoding via PerlIO

If your perl supports C<PerlIO> (which is the default), you can use a
C<PerlIO> layer to decode and encode directly via a filehandle.  The
following two examples are fully identical in functionality:

  ### Version 1 via PerlIO
    open(INPUT,  "< :encoding(shiftjis)", $infile)
        || die "Can't open < $infile for reading: $!";
    open(OUTPUT, "> :encoding(euc-jp)",  $outfile)
        || die "Can't open > $output for writing: $!";
    while (<INPUT>) {   # auto decodes $_
        print OUTPUT;   # auto encodes $_
    }
    close(INPUT)   || die "can't close $infile: $!";
    close(OUTPUT)  || die "can't close $outfile: $!";

  ### Version 2 via from_to()
    open(INPUT,  "< :raw", $infile)
        || die "Can't open < $infile for reading: $!";
    open(OUTPUT, "> :raw",  $outfile)
        || die "Can't open > $output for writing: $!";

    while (<INPUT>) {
        from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
        print OUTPUT;   # emit raw (but properly encoded) data
    }
    close(INPUT)   || die "can't close $infile: $!";
    close(OUTPUT)  || die "can't close $outfile: $!";

In the first version above, you let the appropriate encoding layer
handle the conversion.  In the second, you explicitly translate
from one encoding to the other.

Unfortunately, it may be that encodings are C<PerlIO>-savvy.  You can check
to see whether your encoding is supported by C<PerlIO> by invoking the
C<perlio_ok> method on it:

  Encode::perlio_ok("hz");             # false
  find_encoding("euc-cn")->perlio_ok;  # true wherever PerlIO is available

  use Encode qw(perlio_ok);            # imported upon request
  perlio_ok("euc-jp")

Fortunately, all encodings that come with C<Encode> core are C<PerlIO>-savvy
except for C<hz> and C<ISO-2022-kr>.  For the gory details, see
L<Encode::Encoding> and L<Encode::PerlIO>.

=head1 Handling Malformed Data

The optional I<CHECK> argument tells C<Encode> what to do when
encountering malformed data.  Without I<CHECK>, C<Encode::FB_DEFAULT>
(== 0) is assumed.

As of version 2.12, C<Encode> supports coderef values for C<CHECK>;
see below.

B<NOTE:> Not all encodings support this feature.
Some encodings ignore the I<CHECK> argument.  For example,
L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.

=head2 List of I<CHECK> values

=head3 FB_DEFAULT

  I<CHECK> = Encode::FB_DEFAULT ( == 0)

If I<CHECK> is 0, encoding and decoding replace any malformed character
with a I<substitution character>.  When you encode, I<SUBCHAR> is used.
When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
used.  If the data is supposed to be UTF-8, an optional lexical warning of
warning category C<"utf8"> is given.

=head3 FB_CROAK

  I<CHECK> = Encode::FB_CROAK ( == 1)

If I<CHECK> is 1, methods immediately die with an error
message.  Therefore, when I<CHECK> is 1, you should trap
exceptions with C<eval{}>, unless you really want to let it C<die>.

=head3 FB_QUIET

  I<CHECK> = Encode::FB_QUIET

If I<CHECK> is set to C<Encode::FB_QUIET>, encoding and decoding immediately
return the portion of the data that has been processed so far when an
error occurs. The data argument is overwritten with everything
after that point; that is, the unprocessed portion of the data.  This is
handy when you have to call C<decode> repeatedly in the case where your
source data may contain partial multi-byte character sequences,
(that is, you are reading with a fixed-width buffer). Here's some sample
code to do exactly that:

    my($buffer, $string) = ("", "");
    while (read($fh, $buffer, 256, length($buffer))) {
        $string .= decode($encoding, $buffer, Encode::FB_QUIET);
        # $buffer now contains the unprocessed partial character
    }

=head3 FB_WARN

  I<CHECK> = Encode::FB_WARN

This is the same as C<FB_QUIET> above, except that instead of being silent
on errors, it issues a warning.  This is handy for when you are debugging.

=head3 FB_PERLQQ FB_HTMLCREF FB_XMLCREF

=over 2

=item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)

=item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)

=item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)

=back

For encodings that are implemented by the C<Encode::XS> module, C<CHECK> C<==>
C<Encode::FB_PERLQQ> puts C<encode> and C<decode> into C<perlqq> fallback mode.

When you decode, C<\xI<HH>> is inserted for a malformed character, where
I<HH> is the hex representation of the octet that could not be decoded to
utf8.  When you encode, C<\x{I<HHHH>}> will be inserted, where I<HHHH> is
the Unicode code point (in any number of hex digits) of the character that
cannot be found in the character repertoire of the encoding.

The HTML/XML character reference modes are about the same. In place of
C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number, and
XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.

In C<Encode> 2.10 or later, C<LEAVE_SRC> is also implied.

=head3 The bitmask

These modes are all actually set via a bitmask.  Here is how the C<FB_I<XXX>>
constants are laid out.  You can import the C<FB_I<XXX>> constants via
C<use Encode qw(:fallbacks)>, and you can import the generic bitmask
constants via C<use Encode qw(:fallback_all)>.

                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
 DIE_ON_ERR    0x0001             X
 WARN_ON_ERR   0x0002                               X
 RETURN_ON_ERR 0x0004                      X        X
 LEAVE_SRC     0x0008                                        X
 PERLQQ        0x0100                                        X
 HTMLCREF      0x0200
 XMLCREF       0x0400

=head3 LEAVE_SRC

  Encode::LEAVE_SRC

If the C<Encode::LEAVE_SRC> bit is I<not> set but I<CHECK> is set, then the
source string to encode() or decode() will be overwritten in place.
If you're not interested in this, then bitwise-OR it with the bitmask.

=head2 coderef for CHECK

As of C<Encode> 2.12, C<CHECK> can also be a code reference which takes the
ordinal value of the unmapped character as an argument and returns
octets that represent the fallback character.  For instance:

  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });

Acts like C<FB_PERLQQ> but U+I<XXXX> is used instead of C<\x{I<XXXX>}>.

Even the fallback for C<decode> must return octets, which are
then decoded with the character encoding that C<decode> accepts. So for
example if you wish to decode octests as UTF-8, and use ISO-8859-15 as
a fallback for bytes that are not valid UTF-8, you could write

    $str = decode 'UTF-8', $octets, sub {
        my $tmp = chr shift;
        from_to $tmp, 'ISO-8859-15', 'UTF-8';
        return $tmp;
    };

=head1 Defining Encodings

To define a new encoding, use:

    use Encode qw(define_encoding);
    define_encoding($object, CANONICAL_NAME [, alias...]);

I<CANONICAL_NAME> will be associated with I<$object>.  The object
should provide the interface described in L<Encode::Encoding>.
If more than two arguments are provided, additional
arguments are considered aliases for I<$object>.

See L<Encode::Encoding> for details.

=head1 The UTF8 flag

Before the introduction of Unicode support in Perl, The C<eq> operator
just compared the strings represented by two scalars. Beginning with
Perl 5.8, C<eq> compares two strings with simultaneous consideration of
I<the UTF8 flag>. To explain why we made it so, I quote from page 402 of
I<Programming Perl, 3rd ed.>

=over 2

=item Goal #1:

Old byte-oriented programs should not spontaneously break on the old
byte-oriented data they used to work on.

=item Goal #2:

Old byte-oriented programs should magically start working on the new
character-oriented data when appropriate.

=item Goal #3:

Programs should run just as fast in the new character-oriented mode
as in the old byte-oriented mode.

=item Goal #4:

Perl should remain one language, rather than forking into a
byte-oriented Perl and a character-oriented Perl.

=back

When I<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0 had been
born yet, many features documented in the book remained unimplemented for a
long time.  Perl 5.8 corrected much of this, and the introduction of the
UTF8 flag is one of them.  You can think of there being two fundamentally
different kinds of strings and string-operations in Perl: one a
byte-oriented mode  for when the internal UTF8 flag is off, and the other a
character-oriented mode for when the internal UTF8 flag is on.

Here is how C<Encode> handles the UTF8 flag.

=over 2

=item *

When you I<encode>, the resulting UTF8 flag is always B<off>.

=item *

When you I<decode>, the resulting UTF8 flag is B<on>--I<unless> you can
unambiguously represent data.  Here is what we mean by "unambiguously".
After C<$utf8 = decode("foo", $octet)>,

  When $octet is...   The UTF8 flag in $utf8 is
  ---------------------------------------------
  In ASCII only (or EBCDIC only)            OFF
  In ISO-8859-1                              ON
  In any other Encoding                      ON
  ---------------------------------------------

As you see, there is one exception: in ASCII.  That way you can assume
Goal #1.  And with C<Encode>, Goal #2 is assumed but you still have to be
careful in the cases mentioned in the B<CAVEAT> paragraphs above.

This UTF8 flag is not visible in Perl scripts, exactly for the same reason
you cannot (or rather, you I<don't have to>) see whether a scalar contains
a string, an integer, or a floating-point number.   But you can still peek
and poke these if you will.  See the next section.

=back

=head2 Messing with Perl's Internals

The following API uses parts of Perl's internals in the current
implementation.  As such, they are efficient but may change in a future
release.

=head3 is_utf8

  is_utf8(STRING [, CHECK])

[INTERNAL] Tests whether the UTF8 flag is turned on in the I<STRING>.
If I<CHECK> is true, also checks whether I<STRING> contains well-formed
UTF-8.  Returns true if successful, false otherwise.

As of Perl 5.8.1, L<utf8> also has the C<utf8::is_utf8> function.

=head3 _utf8_on

  _utf8_on(STRING)

[INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<on>.  The I<STRING>
is I<not> checked for containing only well-formed UTF-8.  Do not use this
unless you I<know with absolute certainty> that the STRING holds only
well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please
don't treat the return value as indicating success or failure), or C<undef>
if I<STRING> is not a string.

B<NOTE>: For security reasons, this function does not work on tainted values.

=head3 _utf8_off

  _utf8_off(STRING)

[INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<off>.  Do not use
frivolously.  Returns the previous state of the UTF8 flag, or C<undef> if
I<STRING> is not a string.  Do not treat the return value as indicative of
success or failure, because that isn't what it means: it is only the
previous setting.

B<NOTE>: For security reasons, this function does not work on tainted values.

=head1 UTF-8 vs. utf8 vs. UTF8

  ....We now view strings not as sequences of bytes, but as sequences
  of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
  computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.

That has historically been Perl's notion of UTF-8, as that is how UTF-8 was
first conceived by Ken Thompson when he invented it. However, thanks to
later revisions to the applicable standards, official UTF-8 is now rather
stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
to cover only 21 bits instead of 32 or 64 bits) and some sequences
are not allowed, like those used in surrogate pairs, the 31 non-character
code points 0xFDD0 .. 0xFDEF, the last two code points in I<any> plane
(0xI<XX>_FFFE and 0xI<XX>_FFFF), all non-shortest encodings, etc.

The former default in which Perl would always use a loose interpretation of
UTF-8 has now been overruled:

  From: Larry Wall <larry@wall.org>
  Date: December 04, 2004 11:51:58 JST
  To: perl-unicode@perl.org
  Subject: Re: Make Encode.pm support the real UTF-8
  Message-Id: <20041204025158.GA28754@wall.org>

  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
  : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
  : but "UTF-8" is the name of the standard and should give the
  : corresponding behaviour.

  For what it's worth, that's how I've always kept them straight in my
  head.

  Also for what it's worth, Perl 6 will mostly default to strict but
  make it easy to switch back to lax.

  Larry

Got that?  As of Perl 5.8.7, B<"UTF-8"> means UTF-8 in its current
sense, which is conservative and strict and security-conscious, whereas
B<"utf8"> means UTF-8 in its former sense, which was liberal and loose and
lax.  C<Encode> version 2.10 or later thus groks this subtle but critically
important distinction between C<"UTF-8"> and C<"utf8">.

  encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
  encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks

In the C<Encode> module, C<"UTF-8"> is actually a canonical name for
C<"utf-8-strict">.  That hyphen between the C<"UTF"> and the C<"8"> is
critical; without it, C<Encode> goes "liberal" and (perhaps overly-)permissive:

  find_encoding("UTF-8")->name # is 'utf-8-strict'
  find_encoding("utf-8")->name # ditto. names are case insensitive
  find_encoding("utf_8")->name # ditto. "_" are treated as "-"
  find_encoding("UTF8")->name  # is 'utf8'.

Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates
whether a string is internally encoded as "utf8", also without a hyphen.

=head1 SEE ALSO

L<Encode::Encoding>,
L<Encode::Supported>,
L<Encode::PerlIO>,
L<encoding>,
L<perlebcdic>,
L<perlfunc/open>,
L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
L<utf8>,
the Perl Unicode Mailing List L<http://lists.perl.org/list/perl-unicode.html>

=head1 MAINTAINER

This project was originated by the late Nick Ing-Simmons and later
maintained by Dan Kogai I<< <dankogai@cpan.org> >>.  See AUTHORS
for a full list of people involved.  For any questions, send mail to
I<< <perl-unicode@perl.org> >> so that we can all share.

While Dan Kogai retains the copyright as a maintainer, credit
should go to all those involved.  See AUTHORS for a list of those
who submitted code to the project.

=head1 COPYRIGHT

Copyright 2002-2013 Dan Kogai I<< <dankogai@cpan.org> >>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_TIME_H)) {
    if((! defined (&__need_time_t)  && !defined (&__need_clock_t)  && ! defined (&__need_timespec))) {
	eval 'sub _TIME_H () {1;}' unless defined(&_TIME_H);
	require 'features.ph';
    }
    if(defined(&_TIME_H)) {
	eval 'sub __need_size_t () {1;}' unless defined(&__need_size_t);
	eval 'sub __need_NULL () {1;}' unless defined(&__need_NULL);
	require 'stddef.ph';
	require 'bits/time.ph';
	if(!defined (&__STRICT_ANSI__)  && !defined (&__USE_XOPEN2K)) {
	    unless(defined(&CLK_TCK)) {
		eval 'sub CLK_TCK () { &CLOCKS_PER_SEC;}' unless defined(&CLK_TCK);
	    }
	}
    }
    if(!defined (&__clock_t_defined)  && (defined (&_TIME_H) || defined (&__need_clock_t))) {
	eval 'sub __clock_t_defined () {1;}' unless defined(&__clock_t_defined);
	require 'bits/types.ph';
	if(defined (&__USE_XOPEN) || defined (&__USE_POSIX) || defined (&__USE_MISC)) {
	}
    }
    undef(&__need_clock_t) if defined(&__need_clock_t);
    if(!defined (&__time_t_defined)  && (defined (&_TIME_H) || defined (&__need_time_t))) {
	eval 'sub __time_t_defined () {1;}' unless defined(&__time_t_defined);
	require 'bits/types.ph';
	if(defined (&__USE_POSIX) || defined (&__USE_MISC) || defined (&__USE_SVID)) {
	}
    }
    undef(&__need_time_t) if defined(&__need_time_t);
    if(!defined (&__clockid_t_defined)  && ((defined (&_TIME_H)  && defined (&__USE_POSIX199309)) || defined (&__need_clockid_t))) {
	eval 'sub __clockid_t_defined () {1;}' unless defined(&__clockid_t_defined);
	require 'bits/types.ph';
    }
    undef(&__clockid_time_t) if defined(&__clockid_time_t);
    if(!defined (&__timer_t_defined)  && ((defined (&_TIME_H)  && defined (&__USE_POSIX199309)) || defined (&__need_timer_t))) {
	eval 'sub __timer_t_defined () {1;}' unless defined(&__timer_t_defined);
	require 'bits/types.ph';
    }
    undef(&__need_timer_t) if defined(&__need_timer_t);
    if((!defined (&__timespec_defined)  && ((defined (&_TIME_H)  && (defined (&__USE_POSIX199309) || defined (&__USE_MISC) || defined (&__USE_ISOC11))) || defined (&__need_timespec)))) {
	eval 'sub __timespec_defined () {1;}' unless defined(&__timespec_defined);
	require 'bits/types.ph';
    }
    undef(&__need_timespec) if defined(&__need_timespec);
    if(defined(&_TIME_H)) {
	if(defined(&__USE_BSD)) {
	} else {
	}
	if(defined (&__USE_XOPEN) || defined (&__USE_POSIX) || defined (&__USE_MISC)) {
	}
	if(defined(&__USE_POSIX199309)) {
	}
	if(defined(&__USE_XOPEN2K)) {
	    unless(defined(&__pid_t_defined)) {
		eval 'sub __pid_t_defined () {1;}' unless defined(&__pid_t_defined);
	    }
	}
	if(defined(&__USE_ISOC11)) {
	    eval 'sub TIME_UTC () {1;}' unless defined(&TIME_UTC);
	}
	if(defined(&__USE_XOPEN)) {
	}
	if(defined(&__USE_XOPEN2K8)) {
	    require 'xlocale.ph';
	}
	if(defined(&__USE_GNU)) {
	}
	if(defined (&__USE_POSIX) || defined (&__USE_MISC)) {
	}
	if(defined (&__USE_POSIX) || defined (&__USE_MISC)) {
	}
	if(defined(&__USE_POSIX)) {
	}
	if(defined (&__USE_SVID) || defined (&__USE_XOPEN)) {
	}
	if(defined(&__USE_SVID)) {
	}
	eval 'sub __isleap {
	    my($year) = @_;
    	    eval q((($year) % 4== 0 && (($year) % 100!= 0|| ($year) % 400== 0)));
	}' unless defined(&__isleap);
	if(defined(&__USE_MISC)) {
	}
	if(defined(&__USE_POSIX199309)) {
	    if(defined(&__USE_XOPEN2K)) {
	    }
	}
	if(defined(&__USE_ISOC11)) {
	}
	if(defined(&__USE_XOPEN_EXTENDED)) {
	}
	if(defined(&__USE_GNU)) {
	}
    }
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package Sys::Hostname;

use strict;

use Carp;

require Exporter;

our @ISA     = qw/ Exporter /;
our @EXPORT  = qw/ hostname /;

our $VERSION;

our $host;

BEGIN {
    $VERSION = '1.18';
    {
	local $SIG{__DIE__};
	eval {
	    require XSLoader;
	    XSLoader::load();
	};
	warn $@ if $@;
    }
}


sub hostname {

  # method 1 - we already know it
  return $host if defined $host;

  # method 1' - try to ask the system
  $host = ghname() if defined &ghname;
  return $host if defined $host;

  if ($^O eq 'VMS') {

    # method 2 - no sockets ==> return DECnet node name
    eval { local $SIG{__DIE__}; $host = (gethostbyname('me'))[0] };
    if ($@) { return $host = $ENV{'SYS$NODE'}; }

    # method 3 - has someone else done the job already?  It's common for the
    #    TCP/IP stack to advertise the hostname via a logical name.  (Are
    #    there any other logicals which TCP/IP stacks use for the host name?)
    $host = $ENV{'ARPANET_HOST_NAME'}  || $ENV{'INTERNET_HOST_NAME'} ||
            $ENV{'MULTINET_HOST_NAME'} || $ENV{'UCX$INET_HOST'}      ||
            $ENV{'TCPWARE_DOMAINNAME'} || $ENV{'NEWS_ADDRESS'};
    return $host if $host;

    # method 4 - does hostname happen to work?
    my($rslt) = `hostname`;
    if ($rslt !~ /IVVERB/) { ($host) = $rslt =~ /^(\S+)/; }
    return $host if $host;

    # rats!
    $host = '';
    croak "Cannot get host name of local machine";  

  }
  elsif ($^O eq 'MSWin32') {
    ($host) = gethostbyname('localhost');
    chomp($host = `hostname 2> NUL`) unless defined $host;
    return $host;
  }
  else {  # Unix
    # is anyone going to make it here?

    local $ENV{PATH} = '/usr/bin:/bin:/usr/sbin:/sbin'; # Paranoia.

    # method 2 - syscall is preferred since it avoids tainting problems
    # XXX: is it such a good idea to return hostname untainted?
    eval {
	local $SIG{__DIE__};
	require "syscall.ph";
	$host = "\0" x 65; ## preload scalar
	syscall(&SYS_gethostname, $host, 65) == 0;
    }

    # method 2a - syscall using systeminfo instead of gethostname
    #           -- needed on systems like Solaris
    || eval {
	local $SIG{__DIE__};
	require "sys/syscall.ph";
	require "sys/systeminfo.ph";
	$host = "\0" x 65; ## preload scalar
	syscall(&SYS_systeminfo, &SI_HOSTNAME, $host, 65) != -1;
    }

    # method 3 - trusty old hostname command
    || eval {
	local $SIG{__DIE__};
	local $SIG{CHLD};
	$host = `(hostname) 2>/dev/null`; # BSDish
    }

    # method 4 - use POSIX::uname(), which strictly can't be expected to be
    # correct
    || eval {
	local $SIG{__DIE__};
	require POSIX;
	$host = (POSIX::uname())[1];
    }

    # method 5 - sysV uname command (may truncate)
    || eval {
	local $SIG{__DIE__};
	$host = `uname -n 2>/dev/null`; ## sysVish
    }

    # bummer
    || croak "Cannot get host name of local machine";  

    # remove garbage 
    $host =~ tr/\0\r\n//d;
    $host;
  }
}

1;

__END__

=head1 NAME

Sys::Hostname - Try every conceivable way to get hostname

=head1 SYNOPSIS

    use Sys::Hostname;
    $host = hostname;

=head1 DESCRIPTION

Attempts several methods of getting the system hostname and
then caches the result.  It tries the first available of the C
library's gethostname(), C<`$Config{aphostname}`>, uname(2),
C<syscall(SYS_gethostname)>, C<`hostname`>, C<`uname -n`>,
and the file F</com/host>.  If all that fails it C<croak>s.

All NULs, returns, and newlines are removed from the result.

=head1 AUTHOR

David Sundstrom E<lt>F<sunds@asictest.sc.ti.com>E<gt>

Texas Instruments

XS code added by Greg Bacon E<lt>F<gbacon@cs.uah.edu>E<gt>

=cut

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             package Sys::Syslog;
use strict;
use warnings;
use warnings::register;
use Carp;
use Exporter        qw< import >;
use File::Basename;
use POSIX           qw< strftime setlocale LC_TIME >;
use Socket          qw< :all >;
require 5.005;


{   no strict 'vars';
    $VERSION = '0.33';

    %EXPORT_TAGS = (
        standard => [qw(openlog syslog closelog setlogmask)],
        extended => [qw(setlogsock)],
        macros => [
            # levels
            qw(
                LOG_ALERT LOG_CRIT LOG_DEBUG LOG_EMERG LOG_ERR 
                LOG_INFO LOG_NOTICE LOG_WARNING
            ), 

            # standard facilities
            qw(
                LOG_AUTH LOG_AUTHPRIV LOG_CRON LOG_DAEMON LOG_FTP LOG_KERN
                LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4
                LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_LPR LOG_MAIL LOG_NEWS
                LOG_SYSLOG LOG_USER LOG_UUCP
            ),
            # Mac OS X specific facilities
            qw( LOG_INSTALL LOG_LAUNCHD LOG_NETINFO LOG_RAS LOG_REMOTEAUTH ),
            # modern BSD specific facilities
            qw( LOG_CONSOLE LOG_NTP LOG_SECURITY ),
            # IRIX specific facilities
            qw( LOG_AUDIT LOG_LFMT ),

            # options
            qw(
                LOG_CONS LOG_PID LOG_NDELAY LOG_NOWAIT LOG_ODELAY LOG_PERROR 
            ), 

            # others macros
            qw(
                LOG_FACMASK LOG_NFACILITIES LOG_PRIMASK 
                LOG_MASK LOG_UPTO
            ), 
        ],
    );

    @EXPORT = (
        @{$EXPORT_TAGS{standard}}, 
    );

    @EXPORT_OK = (
        @{$EXPORT_TAGS{extended}}, 
        @{$EXPORT_TAGS{macros}}, 
    );

    eval {
        require XSLoader;
        XSLoader::load('Sys::Syslog', $VERSION);
        1
    } or do {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        bootstrap Sys::Syslog $VERSION;
    };
}


# 
# Public variables
# 
use vars qw($host);             # host to send syslog messages to (see notes at end)

#
# Prototypes
#
sub silent_eval (&);

# 
# Global variables
# 
use vars qw($facility);
my $connected       = 0;        # flag to indicate if we're connected or not
my $syslog_send;                # coderef of the function used to send messages
my $syslog_path     = undef;    # syslog path for "stream" and "unix" mechanisms
my $syslog_xobj     = undef;    # if defined, holds the external object used to send messages
my $transmit_ok     = 0;        # flag to indicate if the last message was transmitted
my $sock_port       = undef;    # socket port
my $sock_timeout    = 0;        # socket timeout, see below
my $current_proto   = undef;    # current mechanism used to transmit messages
my $ident           = '';       # identifiant prepended to each message
$facility           = '';       # current facility
my $maskpri         = LOG_UPTO(&LOG_DEBUG);     # current log mask

my %options = (
    ndelay  => 0, 
    noeol   => 0,
    nofatal => 0, 
    nonul   => 0,
    nowait  => 0, 
    perror  => 0, 
    pid     => 0, 
);

# Default is now to first use the native mechanism, so Perl programs 
# behave like other normal Unix programs, then try other mechanisms.
my @connectMethods = qw(native tcp udp unix pipe stream console);
if ($^O eq "freebsd" or $^O eq "linux") {
    @connectMethods = grep { $_ ne 'udp' } @connectMethods;
}

# And on Win32 systems, we try to use the native mechanism for this 
# platform, the events logger, available through Win32::EventLog.
EVENTLOG: {
    my $is_Win32 = $^O =~ /Win32/i;

    if (can_load("Sys::Syslog::Win32", $is_Win32)) {
        unshift @connectMethods, 'eventlog';
    }
}

my @defaultMethods = @connectMethods;
my @fallbackMethods = ();

# The timeout in connection_ok() was pushed up to 0.25 sec in 
# Sys::Syslog v0.19 in order to address a heisenbug on MacOSX:
# http://london.pm.org/pipermail/london.pm/Week-of-Mon-20061211/005961.html
# 
# However, this also had the effect of slowing this test for 
# all other operating systems, which apparently impacted some 
# users (cf. CPAN-RT #34753). So, in order to make everybody 
# happy, the timeout is now zero by default on all systems 
# except on OSX where it is set to 250 msec, and can be set 
# with the infamous setlogsock() function.
#
# Update 2011-08: this issue is also been seen on multiprocessor
# Debian GNU/kFreeBSD systems. See http://bugs.debian.org/627821
# and https://rt.cpan.org/Ticket/Display.html?id=69997
# Also, lowering the delay to 1 ms, which should be enough.

$sock_timeout = 0.001 if $^O =~ /darwin|gnukfreebsd/;


# Perl 5.6.0's warnings.pm doesn't have warnings::warnif()
if (not defined &warnings::warnif) {
    *warnings::warnif = sub {
        goto &warnings::warn if warnings::enabled(__PACKAGE__)
    }
}

# coderef for a nicer handling of errors
my $err_sub = $options{nofatal} ? \&warnings::warnif : \&croak;


sub AUTOLOAD {
    # This AUTOLOAD is used to 'autoload' constants from the constant()
    # XS function.
    no strict 'vars';
    my $constname;
    ($constname = $AUTOLOAD) =~ s/.*:://;
    croak "Sys::Syslog::constant() not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    croak $error if $error;
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
}


sub openlog {
    ($ident, my $logopt, $facility) = @_;

    # default values
    $ident    ||= basename($0) || getlogin() || getpwuid($<) || 'syslog';
    $logopt   ||= '';
    $facility ||= LOG_USER();

    for my $opt (split /\b/, $logopt) {
        $options{$opt} = 1 if exists $options{$opt}
    }

    $err_sub = delete $options{nofatal} ? \&warnings::warnif : \&croak;
    return 1 unless $options{ndelay};
    connect_log();
} 

sub closelog {
    disconnect_log() if $connected;
    $options{$_} = 0 for keys %options;
    $facility = $ident = "";
    $connected = 0;
    return 1
} 

sub setlogmask {
    my $oldmask = $maskpri;
    $maskpri = shift unless $_[0] == 0;
    $oldmask;
}


my %mechanism = (
    console => {
        check   => sub { 1 },
    },
    eventlog => {
        check   => sub { return can_load("Win32::EventLog") },
        err_msg => "no Win32 API available",
    },
    inet => {
        check   => sub { 1 },
    },
    native => {
        check   => sub { 1 },
    },
    pipe => {
        check   => sub {
            ($syslog_path) = grep { defined && length && -p && -w _ }
                                $syslog_path, &_PATH_LOG, "/dev/log";
            return $syslog_path ? 1 : 0
        },
        err_msg => "path not available",
    },
    stream => {
        check   => sub {
            if (not defined $syslog_path) {
                my @try = qw(/dev/log /dev/conslog);
                unshift @try, &_PATH_LOG  if length &_PATH_LOG;
                ($syslog_path) = grep { -w } @try;
            }
            return defined $syslog_path && -w $syslog_path
        },
        err_msg => "could not find any writable device",
    },
    tcp => {
        check   => sub {
            return 1 if defined $sock_port;

            if (getservbyname('syslog', 'tcp') || getservbyname('syslogng', 'tcp')) {
                $host = $syslog_path;
                return 1
            }
            else {
                return
            }
        },
        err_msg => "TCP service unavailable",
    },
    udp => {
        check   => sub {
            return 1 if defined $sock_port;

            if (getservbyname('syslog', 'udp')) {
                $host = $syslog_path;
                return 1
            }
            else {
                return
            }
        },
        err_msg => "UDP service unavailable",
    },
    unix => {
        check   => sub {
            my @try = ($syslog_path, &_PATH_LOG);
            ($syslog_path) = grep { defined && length && -w } @try;
            return defined $syslog_path && -w $syslog_path
        },
        err_msg => "path not available",
    },
);
 
sub setlogsock {
    my %opt;

    # handle arguments
    # - old API: setlogsock($sock_type, $sock_path, $sock_timeout)
    # - new API: setlogsock(\%options)
    croak "setlogsock(): Invalid number of arguments"
        unless @_ >= 1 and @_ <= 3;

    if (my $ref = ref $_[0]) {
        if ($ref eq "HASH") {
            %opt = %{ $_[0] };
            croak "setlogsock(): No argument given" unless keys %opt;
        }
        elsif ($ref eq "ARRAY") {
            @opt{qw< type path timeout >} = @_;
        }
        else {
            croak "setlogsock(): Unexpected \L$ref\E reference"
        }
    }
    else {
        @opt{qw< type path timeout >} = @_;
    }

    # check socket type, remove invalid ones
    my $diag_invalid_type = "setlogsock(): Invalid type%s; must be one of "
                          . join ", ", map { "'$_'" } sort keys %mechanism;
    croak sprintf $diag_invalid_type, "" unless defined $opt{type};
    my @sock_types = ref $opt{type} eq "ARRAY" ? @{$opt{type}} : ($opt{type});
    my @tmp;

    for my $sock_type (@sock_types) {
        carp sprintf $diag_invalid_type, " '$sock_type'" and next
            unless exists $mechanism{$sock_type};
        push @tmp, "tcp", "udp" and next  if $sock_type eq "inet";
        push @tmp, $sock_type;
    }

    @sock_types = @tmp;

    # set global options
    $syslog_path  = $opt{path}    if defined $opt{path};
    $host         = $opt{host}    if defined $opt{host};
    $sock_timeout = $opt{timeout} if defined $opt{timeout};
    $sock_port    = $opt{port}    if defined $opt{port};

    disconnect_log() if $connected;
    $transmit_ok = 0;
    @fallbackMethods = ();
    @connectMethods = ();
    my $found = 0;

    # check each given mechanism and test if it can be used on the current system
    for my $sock_type (@sock_types) {
        if ( $mechanism{$sock_type}{check}->() ) {
            push @connectMethods, $sock_type;
            $found = 1;
        }
        else {
            warnings::warnif("setlogsock(): type='$sock_type': "
                           . $mechanism{$sock_type}{err_msg});
        }
    }

    # if no mechanism worked from the given ones, use the default ones
    @connectMethods = @defaultMethods unless @connectMethods;

    return $found;
}

sub syslog {
    my ($priority, $mask, @args) = @_;
    my ($message, $buf);
    my (@words, $num, $numpri, $numfac, $sum);
    my $failed = undef;
    my $fail_time = undef;
    my $error = $!;

    # if $ident is undefined, it means openlog() wasn't previously called
    # so do it now in order to have sensible defaults
    openlog() unless $ident;

    local $facility = $facility;    # may need to change temporarily.

    croak "syslog: expecting argument \$priority" unless defined $priority;
    croak "syslog: expecting argument \$format"   unless defined $mask;

    if ($priority =~ /^\d+$/) {
        $numpri = LOG_PRI($priority);
        $numfac = LOG_FAC($priority) << 3;
    }
    elsif ($priority =~ /^\w+/) {
        # Allow "level" or "level|facility".
        @words = split /\W+/, $priority, 2;

        undef $numpri;
        undef $numfac;

        for my $word (@words) {
            next if length $word == 0;

            # Translate word to number.
            $num = xlate($word);

            if ($num < 0) {
                croak "syslog: invalid level/facility: $word"
            }
            elsif ($num <= LOG_PRIMASK() and $word ne "kern") {
                croak "syslog: too many levels given: $word"
                    if defined $numpri;
                $numpri = $num;
            }
            else {
                croak "syslog: too many facilities given: $word"
                    if defined $numfac;
                $facility = $word if $word =~ /^[A-Za-z]/;
                $numfac = $num;
            }
        }
    }
    else {
        croak "syslog: invalid level/facility: $priority"
    }

    croak "syslog: level must be given" unless defined $numpri;

    # don't log if priority is below mask level
    return 0 unless LOG_MASK($numpri) & $maskpri;

    if (not defined $numfac) {  # Facility not specified in this call.
	$facility = 'user' unless $facility;
	$numfac = xlate($facility);
    }

    connect_log() unless $connected;

    if ($mask =~ /%m/) {
        # escape percent signs for sprintf()
        $error =~ s/%/%%/g if @args;
        # replace %m with $error, if preceded by an even number of percent signs
        $mask =~ s/(?<!%)((?:%%)*)%m/$1$error/g;
    }

    $mask .= "\n" unless $mask =~ /\n$/;
    $message = @args ? sprintf($mask, @args) : $mask;

    if ($current_proto eq 'native') {
        $buf = $message;
    }
    elsif ($current_proto eq 'eventlog') {
        $buf = $message;
    }
    else {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};

        $sum = $numpri + $numfac;
        my $oldlocale = setlocale(LC_TIME);
        setlocale(LC_TIME, 'C');
        my $timestamp = strftime "%b %d %H:%M:%S", localtime;
        setlocale(LC_TIME, $oldlocale);

        # construct the stream that will be transmitted
        $buf = "<$sum>$timestamp $whoami: $message";

        # add (or not) a newline
        $buf .= "\n" if !$options{noeol} and rindex($buf, "\n") == -1;

        # add (or not) a NUL character
        $buf .= "\0" if !$options{nonul};
    }

    # handle PERROR option
    # "native" mechanism already handles it by itself
    if ($options{perror} and $current_proto ne 'native') {
        my $whoami = $ident;
        $whoami .= "[$$]" if $options{pid};
        print STDERR "$whoami: $message\n";
    }

    # it's possible that we'll get an error from sending
    # (e.g. if method is UDP and there is no UDP listener,
    # then we'll get ECONNREFUSED on the send). So what we
    # want to do at this point is to fallback onto a different
    # connection method.
    while (scalar @fallbackMethods || $syslog_send) {
	if ($failed && (time - $fail_time) > 60) {
	    # it's been a while... maybe things have been fixed
	    @fallbackMethods = ();
	    disconnect_log();
	    $transmit_ok = 0; # make it look like a fresh attempt
	    connect_log();
        }

	if ($connected && !connection_ok()) {
	    # Something was OK, but has now broken. Remember coz we'll
	    # want to go back to what used to be OK.
	    $failed = $current_proto unless $failed;
	    $fail_time = time;
	    disconnect_log();
	}

	connect_log() unless $connected;
	$failed = undef if ($current_proto && $failed && $current_proto eq $failed);

	if ($syslog_send) {
            if ($syslog_send->($buf, $numpri, $numfac)) {
		$transmit_ok++;
		return 1;
	    }
	    # typically doesn't happen, since errors are rare from write().
	    disconnect_log();
	}
    }
    # could not send, could not fallback onto a working
    # connection method. Lose.
    return 0;
}

sub _syslog_send_console {
    my ($buf) = @_;

    # The console print is a method which could block
    # so we do it in a child process and always return success
    # to the caller.
    if (my $pid = fork) {

	if ($options{nowait}) {
	    return 1;
	} else {
	    if (waitpid($pid, 0) >= 0) {
	    	return ($? >> 8);
	    } else {
		# it's possible that the caller has other
		# plans for SIGCHLD, so let's not interfere
		return 1;
	    }
	}
    } else {
        if (open(CONS, ">/dev/console")) {
	    my $ret = print CONS $buf . "\r";  # XXX: should this be \x0A ?
	    POSIX::_exit($ret) if defined $pid;
	    close CONS;
	}

	POSIX::_exit(0) if defined $pid;
    }
}

sub _syslog_send_stream {
    my ($buf) = @_;
    # XXX: this only works if the OS stream implementation makes a write 
    # look like a putmsg() with simple header. For instance it works on 
    # Solaris 8 but not Solaris 7.
    # To be correct, it should use a STREAMS API, but perl doesn't have one.
    return syswrite(SYSLOG, $buf, length($buf));
}

sub _syslog_send_pipe {
    my ($buf) = @_;
    return print SYSLOG $buf;
}

sub _syslog_send_socket {
    my ($buf) = @_;
    return syswrite(SYSLOG, $buf, length($buf));
    #return send(SYSLOG, $buf, 0);
}

sub _syslog_send_native {
    my ($buf, $numpri, $numfac) = @_;
    syslog_xs($numpri|$numfac, $buf);
    return 1;
}


# xlate()
# -----
# private function to translate names to numeric values
# 
sub xlate {
    my ($name) = @_;

    return $name+0 if $name =~ /^\s*\d+\s*$/;
    $name = uc $name;
    $name = "LOG_$name" unless $name =~ /^LOG_/;

    # ExtUtils::Constant 0.20 introduced a new way to implement
    # constants, called ProxySubs.  When it was used to generate
    # the C code, the constant() function no longer returns the 
    # correct value.  Therefore, we first try a direct call to 
    # constant(), and if the value is an error we try to call the 
    # constant by its full name. 
    my $value = constant($name);

    if (index($value, "not a valid") >= 0) {
        $name = "Sys::Syslog::$name";
        $value = eval { no strict "refs"; &$name };
        $value = $@ unless defined $value;
    }

    $value = -1 if index($value, "not a valid") >= 0;

    return defined $value ? $value : -1;
}


# connect_log()
# -----------
# This function acts as a kind of front-end: it tries to connect to 
# a syslog service using the selected methods, trying each one in the 
# selected order. 
# 
sub connect_log {
    @fallbackMethods = @connectMethods unless scalar @fallbackMethods;

    if ($transmit_ok && $current_proto) {
        # Retry what we were on, because it has worked in the past.
	unshift(@fallbackMethods, $current_proto);
    }

    $connected = 0;
    my @errs = ();
    my $proto = undef;

    while ($proto = shift @fallbackMethods) {
	no strict 'refs';
	my $fn = "connect_$proto";
	$connected = &$fn(\@errs) if defined &$fn;
	last if $connected;
    }

    $transmit_ok = 0;
    if ($connected) {
	$current_proto = $proto;
        my ($old) = select(SYSLOG); $| = 1; select($old);
    } else {
	@fallbackMethods = ();
        $err_sub->(join "\n\t- ", "no connection to syslog available", @errs);
        return undef;
    }
}

sub connect_tcp {
    my ($errs) = @_;

    my $proto = getprotobyname('tcp');
    if (!defined $proto) {
	push @$errs, "getprotobyname failed for tcp";
	return 0;
    }

    my $port = $sock_port || getservbyname('syslog', 'tcp');
    $port = getservbyname('syslogng', 'tcp') unless defined $port;
    if (!defined $port) {
	push @$errs, "getservbyname failed for syslog/tcp and syslogng/tcp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($port, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_STREAM, $proto)) {
	push @$errs, "tcp socket: $!";
	return 0;
    }

    setsockopt(SYSLOG, SOL_SOCKET, SO_KEEPALIVE, 1);
    if (silent_eval { IPPROTO_TCP() }) {
        # These constants don't exist in 5.005. They were added in 1999
        setsockopt(SYSLOG, IPPROTO_TCP(), TCP_NODELAY(), 1);
    }
    if (!connect(SYSLOG, $addr)) {
	push @$errs, "tcp connect: $!";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_udp {
    my ($errs) = @_;

    my $proto = getprotobyname('udp');
    if (!defined $proto) {
	push @$errs, "getprotobyname failed for udp";
	return 0;
    }

    my $port = $sock_port || getservbyname('syslog', 'udp');
    if (!defined $port) {
	push @$errs, "getservbyname failed for syslog/udp";
	return 0;
    }

    my $addr;
    if (defined $host) {
        $addr = inet_aton($host);
        if (!$addr) {
	    push @$errs, "can't lookup $host";
	    return 0;
	}
    } else {
        $addr = INADDR_LOOPBACK;
    }
    $addr = sockaddr_in($port, $addr);

    if (!socket(SYSLOG, AF_INET, SOCK_DGRAM, $proto)) {
	push @$errs, "udp socket: $!";
	return 0;
    }
    if (!connect(SYSLOG, $addr)) {
	push @$errs, "udp connect: $!";
	return 0;
    }

    # We want to check that the UDP connect worked. However the only
    # way to do that is to send a message and see if an ICMP is returned
    _syslog_send_socket("");
    if (!connection_ok()) {
	push @$errs, "udp connect: nobody listening";
	return 0;
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_stream {
    my ($errs) = @_;
    # might want syslog_path to be variable based on syslog.h (if only
    # it were in there!)
    $syslog_path = '/dev/conslog' unless defined $syslog_path; 

    if (!-w $syslog_path) {
	push @$errs, "stream $syslog_path is not writable";
	return 0;
    }

    require Fcntl;

    if (!sysopen(SYSLOG, $syslog_path, Fcntl::O_WRONLY(), 0400)) {
	push @$errs, "stream can't open $syslog_path: $!";
	return 0;
    }

    $syslog_send = \&_syslog_send_stream;

    return 1;
}

sub connect_pipe {
    my ($errs) = @_;

    $syslog_path ||= &_PATH_LOG || "/dev/log";

    if (not -w $syslog_path) {
        push @$errs, "$syslog_path is not writable";
        return 0;
    }

    if (not open(SYSLOG, ">$syslog_path")) {
        push @$errs, "can't write to $syslog_path: $!";
        return 0;
    }

    $syslog_send = \&_syslog_send_pipe;

    return 1;
}

sub connect_unix {
    my ($errs) = @_;

    $syslog_path ||= _PATH_LOG() if length _PATH_LOG();

    if (not defined $syslog_path) {
        push @$errs, "_PATH_LOG not available in syslog.h and no user-supplied socket path";
	return 0;
    }

    if (not (-S $syslog_path or -c _)) {
        push @$errs, "$syslog_path is not a socket";
	return 0;
    }

    my $addr = sockaddr_un($syslog_path);
    if (!$addr) {
	push @$errs, "can't locate $syslog_path";
	return 0;
    }
    if (!socket(SYSLOG, AF_UNIX, SOCK_STREAM, 0)) {
        push @$errs, "unix stream socket: $!";
	return 0;
    }

    if (!connect(SYSLOG, $addr)) {
        if (!socket(SYSLOG, AF_UNIX, SOCK_DGRAM, 0)) {
	    push @$errs, "unix dgram socket: $!";
	    return 0;
	}
        if (!connect(SYSLOG, $addr)) {
	    push @$errs, "unix dgram connect: $!";
	    return 0;
	}
    }

    $syslog_send = \&_syslog_send_socket;

    return 1;
}

sub connect_native {
    my ($errs) = @_;
    my $logopt = 0;

    # reconstruct the numeric equivalent of the options
    for my $opt (keys %options) {
        $logopt += xlate($opt) if $options{$opt}
    }

    openlog_xs($ident, $logopt, xlate($facility));
    $syslog_send = \&_syslog_send_native;

    return 1;
}

sub connect_eventlog {
    my ($errs) = @_;

    $syslog_xobj = Sys::Syslog::Win32::_install();
    $syslog_send = \&Sys::Syslog::Win32::_syslog_send;

    return 1;
}

sub connect_console {
    my ($errs) = @_;
    if (!-w '/dev/console') {
	push @$errs, "console is not writable";
	return 0;
    }
    $syslog_send = \&_syslog_send_console;
    return 1;
}

# To test if the connection is still good, we need to check if any
# errors are present on the connection. The errors will not be raised
# by a write. Instead, sockets are made readable and the next read
# would cause the error to be returned. Unfortunately the syslog 
# 'protocol' never provides anything for us to read. But with 
# judicious use of select(), we can see if it would be readable...
sub connection_ok {
    return 1 if defined $current_proto and (
        $current_proto eq 'native' or $current_proto eq 'console'
        or $current_proto eq 'eventlog'
    );

    my $rin = '';
    vec($rin, fileno(SYSLOG), 1) = 1;
    my $ret = select $rin, undef, $rin, $sock_timeout;
    return ($ret ? 0 : 1);
}

sub disconnect_log {
    $connected = 0;
    $syslog_send = undef;

    if (defined $current_proto and $current_proto eq 'native') {
        closelog_xs();
        unshift @fallbackMethods, $current_proto;
        $current_proto = undef;
        return 1;
    }
    elsif (defined $current_proto and $current_proto eq 'eventlog') {
        $syslog_xobj->Close();
        unshift @fallbackMethods, $current_proto;
        $current_proto = undef;
        return 1;
    }

    return close SYSLOG;
}


#
# Wrappers around eval() that makes sure that nobody, and I say NOBODY, 
# ever knows that I wanted to test if something was here or not. 
# It is needed because some applications are trying to be too smart,
# do it wrong, and it ends up in EPIC FAIL. 
# Yes I'm speaking of YOU, SpamAssassin.
#
sub silent_eval (&) {
    local($SIG{__DIE__}, $SIG{__WARN__}, $@);
    return eval { $_[0]->() }
}

sub can_load {
    my ($module, $verbose) = @_;
    local($SIG{__DIE__}, $SIG{__WARN__}, $@);
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    my $loaded = eval "use $module; 1";
    warn $@ if not $loaded and $verbose;
    return $loaded
}


"Eighth Rule: read the documentation."

__END__

=head1 NAME

Sys::Syslog - Perl interface to the UNIX syslog(3) calls

=head1 VERSION

This is the documentation of version 0.33

=head1 SYNOPSIS

    use Sys::Syslog;                        # all except setlogsock()
    use Sys::Syslog qw(:standard :macros);  # standard functions & macros

    openlog($ident, $logopt, $facility);    # don't forget this
    syslog($priority, $format, @args);
    $oldmask = setlogmask($mask_priority);
    closelog();


=head1 DESCRIPTION

C<Sys::Syslog> is an interface to the UNIX C<syslog(3)> program.
Call C<syslog()> with a string priority and a list of C<printf()> args
just like C<syslog(3)>.


=head1 EXPORTS

C<Sys::Syslog> exports the following C<Exporter> tags: 

=over 4

=item *

C<:standard> exports the standard C<syslog(3)> functions: 

    openlog closelog setlogmask syslog

=item *

C<:extended> exports the Perl specific functions for C<syslog(3)>: 

    setlogsock

=item *

C<:macros> exports the symbols corresponding to most of your C<syslog(3)> 
macros and the C<LOG_UPTO()> and C<LOG_MASK()> functions. 
See L<"CONSTANTS"> for the supported constants and their meaning. 

=back

By default, C<Sys::Syslog> exports the symbols from the C<:standard> tag. 


=head1 FUNCTIONS

=over 4

=item B<openlog($ident, $logopt, $facility)>

Opens the syslog.
C<$ident> is prepended to every message.  C<$logopt> contains zero or
more of the options detailed below.  C<$facility> specifies the part 
of the system to report about, for example C<LOG_USER> or C<LOG_LOCAL0>:
see L<"Facilities"> for a list of well-known facilities, and your 
C<syslog(3)> documentation for the facilities available in your system. 
Check L<"SEE ALSO"> for useful links. Facility can be given as a string 
or a numeric macro. 

This function will croak if it can't connect to the syslog daemon.

Note that C<openlog()> now takes three arguments, just like C<openlog(3)>.

B<You should use C<openlog()> before calling C<syslog()>.>

B<Options>

=over 4

=item *

C<cons> - This option is ignored, since the failover mechanism will drop 
down to the console automatically if all other media fail.

=item *

C<ndelay> - Open the connection immediately (normally, the connection is
opened when the first message is logged).

=item *

C<noeol> - When set to true, no end of line character (C<\n>) will be
appended to the message. This can be useful for some buggy syslog daemons.

=item *

C<nofatal> - When set to true, C<openlog()> and C<syslog()> will only 
emit warnings instead of dying if the connection to the syslog can't 
be established. 

=item *

C<nonul> - When set to true, no C<NUL> character (C<\0>) will be
appended to the message. This can be useful for some buggy syslog daemons.

=item *

C<nowait> - Don't wait for child processes that may have been created 
while logging the message.  (The GNU C library does not create a child
process, so this option has no effect on Linux.)

=item *

C<perror> - Write the message to standard error output as well to the
system log (added in C<Sys::Syslog> 0.22).

=item *

C<pid> - Include PID with each message.

=back

B<Examples>

Open the syslog with options C<ndelay> and C<pid>, and with facility C<LOCAL0>: 

    openlog($name, "ndelay,pid", "local0");

Same thing, but this time using the macro corresponding to C<LOCAL0>: 

    openlog($name, "ndelay,pid", LOG_LOCAL0);


=item B<syslog($priority, $message)>

=item B<syslog($priority, $format, @args)>

If C<$priority> permits, logs C<$message> or C<sprintf($format, @args)>
with the addition that C<%m> in $message or C<$format> is replaced with
C<"$!"> (the latest error message). 

C<$priority> can specify a level, or a level and a facility.  Levels and 
facilities can be given as strings or as macros.  When using the C<eventlog>
mechanism, priorities C<DEBUG> and C<INFO> are mapped to event type 
C<informational>, C<NOTICE> and C<WARNING> to C<warning> and C<ERR> to 
C<EMERG> to C<error>.

If you didn't use C<openlog()> before using C<syslog()>, C<syslog()> will 
try to guess the C<$ident> by extracting the shortest prefix of 
C<$format> that ends in a C<":">.

B<Examples>

    # informational level
    syslog("info", $message);
    syslog(LOG_INFO, $message);

    # information level, Local0 facility
    syslog("info|local0", $message);
    syslog(LOG_INFO|LOG_LOCAL0, $message);

=over 4

=item B<Note>

C<Sys::Syslog> version v0.07 and older passed the C<$message> as the 
formatting string to C<sprintf()> even when no formatting arguments
were provided.  If the code calling C<syslog()> might execute with 
older versions of this module, make sure to call the function as
C<syslog($priority, "%s", $message)> instead of C<syslog($priority,
$message)>.  This protects against hostile formatting sequences that
might show up if $message contains tainted data.

=back


=item B<setlogmask($mask_priority)>

Sets the log mask for the current process to C<$mask_priority> and 
returns the old mask.  If the mask argument is 0, the current log mask 
is not modified.  See L<"Levels"> for the list of available levels. 
You can use the C<LOG_UPTO()> function to allow all levels up to a 
given priority (but it only accept the numeric macros as arguments).

B<Examples>

Only log errors: 

    setlogmask( LOG_MASK(LOG_ERR) );

Log everything except informational messages: 

    setlogmask( ~(LOG_MASK(LOG_INFO)) );

Log critical messages, errors and warnings: 

    setlogmask( LOG_MASK(LOG_CRIT)
              | LOG_MASK(LOG_ERR)
              | LOG_MASK(LOG_WARNING) );

Log all messages up to debug: 

    setlogmask( LOG_UPTO(LOG_DEBUG) );


=item B<setlogsock()>

Sets the socket type and options to be used for the next call to C<openlog()>
or C<syslog()>.  Returns true on success, C<undef> on failure.

Being Perl-specific, this function has evolved along time.  It can currently
be called as follow:

=over

=item *

C<setlogsock($sock_type)>

=item *

C<setlogsock($sock_type, $stream_location)> (added in Perl 5.004_02)

=item *

C<setlogsock($sock_type, $stream_location, $sock_timeout)> (added in
C<Sys::Syslog> 0.25)

=item *

C<setlogsock(\%options)> (added in C<Sys::Syslog> 0.28)

=back

The available options are:

=over

=item *

C<type> - equivalent to C<$sock_type>, selects the socket type (or
"mechanism").  An array reference can be passed to specify several
mechanisms to try, in the given order.

=item *

C<path> - equivalent to C<$stream_location>, sets the stream location.
Defaults to standard Unix location, or C<_PATH_LOG>.

=item *

C<timeout> - equivalent to C<$sock_timeout>, sets the socket timeout
in seconds.  Defaults to 0 on all systems except S<Mac OS X> where it
is set to 0.25 sec.

=item *

C<host> - sets the hostname to send the messages to.  Defaults to 
the local host.

=item *

C<port> - sets the TCP or UDP port to connect to.  Defaults to the
first standard syslog port available on the system.

=back


The available mechanisms are: 

=over

=item *

C<"native"> - use the native C functions from your C<syslog(3)> library
(added in C<Sys::Syslog> 0.15).

=item *

C<"eventlog"> - send messages to the Win32 events logger (Win32 only; 
added in C<Sys::Syslog> 0.19).

=item *

C<"tcp"> - connect to a TCP socket, on the C<syslog/tcp> or C<syslogng/tcp> 
service.  See also the C<host>, C<port> and C<timeout> options.

=item *

C<"udp"> - connect to a UDP socket, on the C<syslog/udp> service.
See also the C<host>, C<port> and C<timeout> options.

=item *

C<"inet"> - connect to an INET socket, either TCP or UDP, tried in that 
order.  See also the C<host>, C<port> and C<timeout> options.

=item *

C<"unix"> - connect to a UNIX domain socket (in some systems a character 
special device).  The name of that socket is given by the C<path> option
or, if omitted, the value returned by the C<_PATH_LOG> macro (if your
system defines it), F</dev/log> or F</dev/conslog>, whichever is writable.

=item *

C<"stream"> - connect to the stream indicated by the C<path> option, or,
if omitted, the value returned by the C<_PATH_LOG> macro (if your system
defines it), F</dev/log> or F</dev/conslog>, whichever is writable.  For
example Solaris and IRIX system may prefer C<"stream"> instead of C<"unix">. 

=item *

C<"pipe"> - connect to the named pipe indicated by the C<path> option,
or, if omitted, to the value returned by the C<_PATH_LOG> macro (if your
system defines it), or F</dev/log> (added in C<Sys::Syslog> 0.21).
HP-UX is a system which uses such a named pipe.

=item *

C<"console"> - send messages directly to the console, as for the C<"cons"> 
option of C<openlog()>.

=back

The default is to try C<native>, C<tcp>, C<udp>, C<unix>, C<pipe>, C<stream>, 
C<console>.
Under systems with the Win32 API, C<eventlog> will be added as the first 
mechanism to try if C<Win32::EventLog> is available.

Giving an invalid value for C<$sock_type> will C<croak>.

B<Examples>

Select the UDP socket mechanism:

    setlogsock("udp");

Send messages using the TCP socket mechanism on a custom port:

    setlogsock({ type => "tcp", port => 2486 });

Send messages to a remote host using the TCP socket mechanism:

    setlogsock({ type => "tcp", host => $loghost });

Try the native, UDP socket then UNIX domain socket mechanisms: 

    setlogsock(["native", "udp", "unix"]);

=over

=item B<Note>

Now that the "native" mechanism is supported by C<Sys::Syslog> and selected 
by default, the use of the C<setlogsock()> function is discouraged because 
other mechanisms are less portable across operating systems.  Authors of 
modules and programs that use this function, especially its cargo-cult form 
C<setlogsock("unix")>, are advised to remove any occurrence of it unless they 
specifically want to use a given mechanism (like TCP or UDP to connect to 
a remote host).

=back

=item B<closelog()>

Closes the log file and returns true on success.

=back


=head1 THE RULES OF SYS::SYSLOG

I<The First Rule of Sys::Syslog is:>
You do not call C<setlogsock>.

I<The Second Rule of Sys::Syslog is:>
You B<do not> call C<setlogsock>.

I<The Third Rule of Sys::Syslog is:>
The program crashes, C<die>s, calls C<closelog>, the log is over.

I<The Fourth Rule of Sys::Syslog is:>
One facility, one priority.

I<The Fifth Rule of Sys::Syslog is:>
One log at a time.

I<The Sixth Rule of Sys::Syslog is:>
No C<syslog> before C<openlog>.

I<The Seventh Rule of Sys::Syslog is:>
Logs will go on as long as they have to. 

I<The Eighth, and Final Rule of Sys::Syslog is:>
If this is your first use of Sys::Syslog, you must read the doc.


=head1 EXAMPLES

An example:

    openlog($program, 'cons,pid', 'user');
    syslog('info', '%s', 'this is another test');
    syslog('mail|warning', 'this is a better test: %d', time);
    closelog();

    syslog('debug', 'this is the last test');

Another example:

    openlog("$program $$", 'ndelay', 'user');
    syslog('notice', 'fooprogram: this is really done');

Example of use of C<%m>:

    $! = 55;
    syslog('info', 'problem was %m');   # %m == $! in syslog(3)

Log to UDP port on C<$remotehost> instead of logging locally:

    setlogsock("udp", $remotehost);
    openlog($program, 'ndelay', 'user');
    syslog('info', 'something happened over here');


=head1 CONSTANTS

=head2 Facilities

=over 4

=item *

C<LOG_AUDIT> - audit daemon (IRIX); falls back to C<LOG_AUTH>

=item *

C<LOG_AUTH> - security/authorization messages

=item *

C<LOG_AUTHPRIV> - security/authorization messages (private)

=item *

C<LOG_CONSOLE> - C</dev/console> output (FreeBSD); falls back to C<LOG_USER>

=item *

C<LOG_CRON> - clock daemons (B<cron> and B<at>)

=item *

C<LOG_DAEMON> - system daemons without separate facility value

=item *

C<LOG_FTP> - FTP daemon

=item *

C<LOG_KERN> - kernel messages

=item *

C<LOG_INSTALL> - installer subsystem (Mac OS X); falls back to C<LOG_USER>

=item *

C<LOG_LAUNCHD> - launchd - general bootstrap daemon (Mac OS X);
falls back to C<LOG_DAEMON>

=item *

C<LOG_LFMT> - logalert facility; falls back to C<LOG_USER>

=item *

C<LOG_LOCAL0> through C<LOG_LOCAL7> - reserved for local use

=item *

C<LOG_LPR> - line printer subsystem

=item *

C<LOG_MAIL> - mail subsystem

=item *

C<LOG_NETINFO> - NetInfo subsystem (Mac OS X); falls back to C<LOG_DAEMON>

=item *

C<LOG_NEWS> - USENET news subsystem

=item *

C<LOG_NTP> - NTP subsystem (FreeBSD, NetBSD); falls back to C<LOG_DAEMON>

=item *

C<LOG_RAS> - Remote Access Service (VPN / PPP) (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_REMOTEAUTH> - remote authentication/authorization (Mac OS X);
falls back to C<LOG_AUTH>

=item *

C<LOG_SECURITY> - security subsystems (firewalling, etc.) (FreeBSD);
falls back to C<LOG_AUTH>

=item *

C<LOG_SYSLOG> - messages generated internally by B<syslogd>

=item *

C<LOG_USER> (default) - generic user-level messages

=item *

C<LOG_UUCP> - UUCP subsystem

=back


=head2 Levels

=over 4

=item *

C<LOG_EMERG> - system is unusable

=item *

C<LOG_ALERT> - action must be taken immediately

=item *

C<LOG_CRIT> - critical conditions

=item *

C<LOG_ERR> - error conditions

=item *

C<LOG_WARNING> - warning conditions

=item *

C<LOG_NOTICE> - normal, but significant, condition

=item *

C<LOG_INFO> - informational message

=item *

C<LOG_DEBUG> - debug-level message

=back


=head1 DIAGNOSTICS

=over

=item C<Invalid argument passed to setlogsock>

B<(F)> You gave C<setlogsock()> an invalid value for C<$sock_type>. 

=item C<eventlog passed to setlogsock, but no Win32 API available>

B<(W)> You asked C<setlogsock()> to use the Win32 event logger but the 
operating system running the program isn't Win32 or does not provides Win32
compatible facilities.

=item C<no connection to syslog available>

B<(F)> C<syslog()> failed to connect to the specified socket.

=item C<stream passed to setlogsock, but %s is not writable>

B<(W)> You asked C<setlogsock()> to use a stream socket, but the given 
path is not writable. 

=item C<stream passed to setlogsock, but could not find any device>

B<(W)> You asked C<setlogsock()> to use a stream socket, but didn't 
provide a path, and C<Sys::Syslog> was unable to find an appropriate one.

=item C<tcp passed to setlogsock, but tcp service unavailable>

B<(W)> You asked C<setlogsock()> to use a TCP socket, but the service 
is not available on the system. 

=item C<syslog: expecting argument %s>

B<(F)> You forgot to give C<syslog()> the indicated argument.

=item C<syslog: invalid level/facility: %s>

B<(F)> You specified an invalid level or facility.

=item C<syslog: too many levels given: %s>

B<(F)> You specified too many levels. 

=item C<syslog: too many facilities given: %s>

B<(F)> You specified too many facilities. 

=item C<syslog: level must be given>

B<(F)> You forgot to specify a level.

=item C<udp passed to setlogsock, but udp service unavailable>

B<(W)> You asked C<setlogsock()> to use a UDP socket, but the service 
is not available on the system. 

=item C<unix passed to setlogsock, but path not available>

B<(W)> You asked C<setlogsock()> to use a UNIX socket, but C<Sys::Syslog> 
was unable to find an appropriate an appropriate device.

=back


=head1 HISTORY

C<Sys::Syslog> is a core module, part of the standard Perl distribution
since 1990.  At this time, modules as we know them didn't exist, the
Perl library was a collection of F<.pl> files, and the one for sending
syslog messages with was simply F<lib/syslog.pl>, included with Perl 3.0.
It was converted as a module with Perl 5.0, but had a version number
only starting with Perl 5.6.  Here is a small table with the matching
Perl and C<Sys::Syslog> versions.

    Sys::Syslog     Perl
    -----------     ----
       undef        5.0.0 ~ 5.5.4
       0.01         5.6.*
       0.03         5.8.0
       0.04         5.8.1, 5.8.2, 5.8.3
       0.05         5.8.4, 5.8.5, 5.8.6
       0.06         5.8.7
       0.13         5.8.8
       0.22         5.10.0
       0.27         5.8.9, 5.10.1 ~ 5.14.2
       0.29         5.16.0, 5.16.1


=head1 SEE ALSO

=head2 Other modules

L<Log::Log4perl> - Perl implementation of the Log4j API

L<Log::Dispatch> - Dispatches messages to one or more outputs

L<Log::Report> - Report a problem, with exceptions and language support

=head2 Manual Pages

L<syslog(3)>

SUSv3 issue 6, IEEE Std 1003.1, 2004 edition, 
L<http://www.opengroup.org/onlinepubs/000095399/basedefs/syslog.h.html>

GNU C Library documentation on syslog, 
L<http://www.gnu.org/software/libc/manual/html_node/Syslog.html>

Solaris 10 documentation on syslog, 
L<http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view>

Mac OS X documentation on syslog,
L<http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html>

IRIX 6.5 documentation on syslog,
L<http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man&fname=3c+syslog>

AIX 5L 5.3 documentation on syslog, 
L<http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm>

HP-UX 11i documentation on syslog, 
L<http://docs.hp.com/en/B2355-60130/syslog.3C.html>

Tru64 5.1 documentation on syslog, 
L<http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM>

Stratus VOS 15.1, 
L<http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&file=ch5r502-01bi.html>

=head2 RFCs

I<RFC 3164 - The BSD syslog Protocol>, L<http://www.faqs.org/rfcs/rfc3164.html>
-- Please note that this is an informational RFC, and therefore does not 
specify a standard of any kind.

I<RFC 3195 - Reliable Delivery for syslog>, L<http://www.faqs.org/rfcs/rfc3195.html>

=head2 Articles

I<Syslogging with Perl>, L<http://lexington.pm.org/meetings/022001.html>

=head2 Event Log

Windows Event Log,
L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp>


=head1 AUTHORS & ACKNOWLEDGEMENTS

Tom Christiansen E<lt>F<tchrist (at) perl.com>E<gt> and Larry Wall
E<lt>F<larry (at) wall.org>E<gt>.

UNIX domain sockets added by Sean Robinson
E<lt>F<robinson_s (at) sc.maricopa.edu>E<gt> with support from Tim Bunce 
E<lt>F<Tim.Bunce (at) ig.co.uk>E<gt> and the C<perl5-porters> mailing list.

Dependency on F<syslog.ph> replaced with XS code by Tom Hughes
E<lt>F<tom (at) compton.nu>E<gt>.

Code for C<constant()>s regenerated by Nicholas Clark E<lt>F<nick (at) ccl4.org>E<gt>.

Failover to different communication modes by Nick Williams
E<lt>F<Nick.Williams (at) morganstanley.com>E<gt>.

Extracted from core distribution for publishing on the CPAN by 
SE<eacute>bastien Aperghis-Tramoni E<lt>sebastien (at) aperghis.netE<gt>.

XS code for using native C functions borrowed from C<L<Unix::Syslog>>, 
written by Marcus Harnisch E<lt>F<marcus.harnisch (at) gmx.net>E<gt>.

Yves Orton suggested and helped for making C<Sys::Syslog> use the native 
event logger under Win32 systems.

Jerry D. Hedden and Reini Urban provided greatly appreciated help to 
debug and polish C<Sys::Syslog> under Cygwin.


=head1 BUGS

Please report any bugs or feature requests to
C<bug-sys-syslog (at) rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/Public/Dist/Display.html?Name=Sys-Syslog>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.


=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Sys::Syslog

You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Sys-Syslog>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Sys-Syslog>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/Dist/Display.html?Queue=Sys-Syslog>

=item * Search CPAN

L<http://search.cpan.org/dist/Sys-Syslog/>

=item * MetaCPAN

L<https://metacpan.org/module/Sys::Syslog>

=item * Perl Documentation

L<http://perldoc.perl.org/Sys/Syslog.html>

=back


=head1 COPYRIGHT

Copyright (C) 1990-2012 by Larry Wall and others.


=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

=begin comment

Notes for the future maintainer (even if it's still me..)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Using Google Code Search, I search who on Earth was relying on $host being 
public. It found 5 hits: 

* First was inside Indigo Star Perl2exe documentation. Just an old version 
of Sys::Syslog. 


* One real hit was inside DalWeathDB, a weather related program. It simply 
does a 

    $Sys::Syslog::host = '127.0.0.1';

- L<http://www.gallistel.net/nparker/weather/code/>


* Two hits were in TPC, a fax server thingy. It does a 

    $Sys::Syslog::host = $TPC::LOGHOST;

but also has this strange piece of code:

    # work around perl5.003 bug
    sub Sys::Syslog::hostname {}

I don't know what bug the author referred to.

- L<http://www.tpc.int/>
- L<ftp://ftp-usa.tpc.int/pub/tpc/server/UNIX/>


* Last hit was in Filefix, which seems to be a FIDOnet mail program (!).
This one does not use $host, but has the following piece of code:

    sub Sys::Syslog::hostname
    {
        use Sys::Hostname;
        return hostname;
    }

I guess this was a more elaborate form of the previous bit, maybe because 
of a bug in Sys::Syslog back then?

- L<ftp://ftp.kiae.su/pub/unix/fido/>


Links
-----
Linux Fast-STREAMS
- L<http://www.openss7.org/streams.html>

II12021: SYSLOGD HOWTO TCPIPINFO (z/OS, OS/390, MVS)
- L<http://www-1.ibm.com/support/docview.wss?uid=isg1II12021>

Getting the most out of the Event Viewer
- L<http://www.codeproject.com/dotnet/evtvwr.asp?print=true>

Log events to the Windows NT Event Log with JNI
- L<http://www.javaworld.com/javaworld/jw-09-2001/jw-0928-ntmessages.html>

=end comment

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # This file was created by h2ph version 4
no warnings qw(portable);
unless (defined &_FILE_OFFSET_BITS) { sub _FILE_OFFSET_BITS() { 64 } }

unless (defined &_GNU_SOURCE) { sub _GNU_SOURCE() { 1 } }

unless (defined &_LARGEFILE64_SOURCE) { sub _LARGEFILE64_SOURCE() { 1 } }

unless (defined &_LARGEFILE_SOURCE) { sub _LARGEFILE_SOURCE() { 1 } }

unless (defined &_POSIX_C_SOURCE) { sub _POSIX_C_SOURCE() { 200809 } }

unless (defined &_POSIX_SOURCE) { sub _POSIX_SOURCE() { 1 } }

unless (defined &_REENTRANT) { sub _REENTRANT() { 1 } }

unless (defined &_STDC_PREDEF_H) { sub _STDC_PREDEF_H() { 1 } }

unless (defined &_XOPEN_SOURCE) { sub _XOPEN_SOURCE() { 700 } }

unless (defined &_XOPEN_SOURCE_EXTENDED) { sub _XOPEN_SOURCE_EXTENDED() { 1 } }

unless (defined &__ACCUM_EPSILON__) { sub __ACCUM_EPSILON__() { "0x1P\-15K" } }

unless (defined &__ACCUM_FBIT__) { sub __ACCUM_FBIT__() { 15 } }

unless (defined &__ACCUM_IBIT__) { sub __ACCUM_IBIT__() { 16 } }

unless (defined &__ACCUM_MAX__) { sub __ACCUM_MAX__() { "0X7FFFFFFFP\-15K" } }

unless (defined &__ACCUM_MIN__) { sub __ACCUM_MIN__() { "\-0X1P15K\-0X1P15K" } }

unless (defined &__APCS_32__) { sub __APCS_32__() { 1 } }

unless (defined &__ARMEL__) { sub __ARMEL__() { 1 } }

unless (defined &__ARM_32BIT_STATE) { sub __ARM_32BIT_STATE() { 1 } }

unless (defined &__ARM_ARCH) { sub __ARM_ARCH() { 6 } }

unless (defined &__ARM_ARCH_6__) { sub __ARM_ARCH_6__() { 1 } }

unless (defined &__ARM_ARCH_ISA_ARM) { sub __ARM_ARCH_ISA_ARM() { 1 } }

unless (defined &__ARM_ARCH_ISA_THUMB) { sub __ARM_ARCH_ISA_THUMB() { 1 } }

unless (defined &__ARM_EABI__) { sub __ARM_EABI__() { 1 } }

unless (defined &__ARM_FEATURE_CLZ) { sub __ARM_FEATURE_CLZ() { 1 } }

unless (defined &__ARM_FEATURE_DSP) { sub __ARM_FEATURE_DSP() { 1 } }

unless (defined &__ARM_FEATURE_LDREX) { sub __ARM_FEATURE_LDREX() { 4 } }

unless (defined &__ARM_FEATURE_QBIT) { sub __ARM_FEATURE_QBIT() { 1 } }

unless (defined &__ARM_FEATURE_SAT) { sub __ARM_FEATURE_SAT() { 1 } }

unless (defined &__ARM_FEATURE_SIMD32) { sub __ARM_FEATURE_SIMD32() { 1 } }

unless (defined &__ARM_FEATURE_UNALIGNED) { sub __ARM_FEATURE_UNALIGNED() { 1 } }

unless (defined &__ARM_FP) { sub __ARM_FP() { 12 } }

unless (defined &__ARM_NEON_FP) { sub __ARM_NEON_FP() { 4 } }

unless (defined &__ARM_PCS_VFP) { sub __ARM_PCS_VFP() { 1 } }

unless (defined &__ARM_SIZEOF_MINIMAL_ENUM) { sub __ARM_SIZEOF_MINIMAL_ENUM() { 4 } }

unless (defined &__ARM_SIZEOF_WCHAR_T) { sub __ARM_SIZEOF_WCHAR_T() { 32 } }

unless (defined &__ATOMIC_ACQUIRE) { sub __ATOMIC_ACQUIRE() { 2 } }

unless (defined &__ATOMIC_ACQ_REL) { sub __ATOMIC_ACQ_REL() { 4 } }

unless (defined &__ATOMIC_CONSUME) { sub __ATOMIC_CONSUME() { 1 } }

unless (defined &__ATOMIC_RELAXED) { sub __ATOMIC_RELAXED() { 0 } }

unless (defined &__ATOMIC_RELEASE) { sub __ATOMIC_RELEASE() { 3 } }

unless (defined &__ATOMIC_SEQ_CST) { sub __ATOMIC_SEQ_CST() { 5 } }

unless (defined &__BIGGEST_ALIGNMENT__) { sub __BIGGEST_ALIGNMENT__() { 8 } }

unless (defined &__BYTE_ORDER__) { sub __BYTE_ORDER__() { 1234 } }

unless (defined &__CHAR16_TYPE__) { sub __CHAR16_TYPE__() { "short\\\ unsigned\\\ int" } }

unless (defined &__CHAR32_TYPE__) { sub __CHAR32_TYPE__() { "unsigned\\\ int" } }

unless (defined &__CHAR_BIT__) { sub __CHAR_BIT__() { 8 } }

unless (defined &__CHAR_UNSIGNED__) { sub __CHAR_UNSIGNED__() { 1 } }

unless (defined &__DA_FBIT__) { sub __DA_FBIT__() { 31 } }

unless (defined &__DA_IBIT__) { sub __DA_IBIT__() { 32 } }

unless (defined &__DBL_DECIMAL_DIG__) { sub __DBL_DECIMAL_DIG__() { 17 } }

unless (defined &__DBL_DENORM_MIN__) { sub __DBL_DENORM_MIN__() { "\(double\)4\.9406564584124654e\-324L" } }

unless (defined &__DBL_DIG__) { sub __DBL_DIG__() { 15 } }

unless (defined &__DBL_EPSILON__) { sub __DBL_EPSILON__() { "\(double\)2\.2204460492503131e\-16L" } }

unless (defined &__DBL_HAS_DENORM__) { sub __DBL_HAS_DENORM__() { 1 } }

unless (defined &__DBL_HAS_INFINITY__) { sub __DBL_HAS_INFINITY__() { 1 } }

unless (defined &__DBL_HAS_QUIET_NAN__) { sub __DBL_HAS_QUIET_NAN__() { 1 } }

unless (defined &__DBL_MANT_DIG__) { sub __DBL_MANT_DIG__() { 53 } }

unless (defined &__DBL_MAX_10_EXP__) { sub __DBL_MAX_10_EXP__() { 308 } }

unless (defined &__DBL_MAX_EXP__) { sub __DBL_MAX_EXP__() { 1024 } }

unless (defined &__DBL_MAX__) { sub __DBL_MAX__() { "\(double\)1\.7976931348623157e\+308L" } }

unless (defined &__DBL_MIN_10_EXP__) { sub __DBL_MIN_10_EXP__() { -307 } }

unless (defined &__DBL_MIN_EXP__) { sub __DBL_MIN_EXP__() { -1021 } }

unless (defined &__DBL_MIN__) { sub __DBL_MIN__() { "\(double\)2\.2250738585072014e\-308L" } }

unless (defined &__DEC128_EPSILON__) { sub __DEC128_EPSILON__() { "1E\-33DL" } }

unless (defined &__DEC128_MANT_DIG__) { sub __DEC128_MANT_DIG__() { 34 } }

unless (defined &__DEC128_MAX_EXP__) { sub __DEC128_MAX_EXP__() { 6145 } }

unless (defined &__DEC128_MAX__) { sub __DEC128_MAX__() { "9\.999999999999999999999999999999999E6144DL" } }

unless (defined &__DEC128_MIN_EXP__) { sub __DEC128_MIN_EXP__() { -6142 } }

unless (defined &__DEC128_MIN__) { sub __DEC128_MIN__() { "1E\-6143DL" } }

unless (defined &__DEC128_SUBNORMAL_MIN__) { sub __DEC128_SUBNORMAL_MIN__() { "0\.000000000000000000000000000000001E\-6143DL" } }

unless (defined &__DEC32_EPSILON__) { sub __DEC32_EPSILON__() { "1E\-6DF" } }

unless (defined &__DEC32_MANT_DIG__) { sub __DEC32_MANT_DIG__() { 7 } }

unless (defined &__DEC32_MAX_EXP__) { sub __DEC32_MAX_EXP__() { 97 } }

unless (defined &__DEC32_MAX__) { sub __DEC32_MAX__() { "9\.999999E96DF" } }

unless (defined &__DEC32_MIN_EXP__) { sub __DEC32_MIN_EXP__() { -94 } }

unless (defined &__DEC32_MIN__) { sub __DEC32_MIN__() { "1E\-95DF" } }

unless (defined &__DEC32_SUBNORMAL_MIN__) { sub __DEC32_SUBNORMAL_MIN__() { "0\.000001E\-95DF" } }

unless (defined &__DEC64_EPSILON__) { sub __DEC64_EPSILON__() { "1E\-15DD" } }

unless (defined &__DEC64_MANT_DIG__) { sub __DEC64_MANT_DIG__() { 16 } }

unless (defined &__DEC64_MAX_EXP__) { sub __DEC64_MAX_EXP__() { 385 } }

unless (defined &__DEC64_MAX__) { sub __DEC64_MAX__() { "9\.999999999999999E384DD" } }

unless (defined &__DEC64_MIN_EXP__) { sub __DEC64_MIN_EXP__() { -382 } }

unless (defined &__DEC64_MIN__) { sub __DEC64_MIN__() { "1E\-383DD" } }

unless (defined &__DEC64_SUBNORMAL_MIN__) { sub __DEC64_SUBNORMAL_MIN__() { "0\.000000000000001E\-383DD" } }

unless (defined &__DECIMAL_DIG__) { sub __DECIMAL_DIG__() { 17 } }

unless (defined &__DEC_EVAL_METHOD__) { sub __DEC_EVAL_METHOD__() { 2 } }

unless (defined &__DQ_FBIT__) { sub __DQ_FBIT__() { 63 } }

unless (defined &__DQ_IBIT__) { sub __DQ_IBIT__() { 0 } }

unless (defined &__ELF__) { sub __ELF__() { 1 } }

unless (defined &__FINITE_MATH_ONLY__) { sub __FINITE_MATH_ONLY__() { 0 } }

unless (defined &__FLOAT_WORD_ORDER__) { sub __FLOAT_WORD_ORDER__() { 1234 } }

unless (defined &__FLT_DECIMAL_DIG__) { sub __FLT_DECIMAL_DIG__() { 9 } }

unless (defined &__FLT_DENORM_MIN__) { sub __FLT_DENORM_MIN__() { 1.4012984643248171e-45 } }

unless (defined &__FLT_DIG__) { sub __FLT_DIG__() { 6 } }

unless (defined &__FLT_EPSILON__) { sub __FLT_EPSILON__() { 1.1920928955078125e-7 } }

unless (defined &__FLT_EVAL_METHOD__) { sub __FLT_EVAL_METHOD__() { 0 } }

unless (defined &__FLT_HAS_DENORM__) { sub __FLT_HAS_DENORM__() { 1 } }

unless (defined &__FLT_HAS_INFINITY__) { sub __FLT_HAS_INFINITY__() { 1 } }

unless (defined &__FLT_HAS_QUIET_NAN__) { sub __FLT_HAS_QUIET_NAN__() { 1 } }

unless (defined &__FLT_MANT_DIG__) { sub __FLT_MANT_DIG__() { 24 } }

unless (defined &__FLT_MAX_10_EXP__) { sub __FLT_MAX_10_EXP__() { 38 } }

unless (defined &__FLT_MAX_EXP__) { sub __FLT_MAX_EXP__() { 128 } }

unless (defined &__FLT_MAX__) { sub __FLT_MAX__() { 3.4028234663852886e+38 } }

unless (defined &__FLT_MIN_10_EXP__) { sub __FLT_MIN_10_EXP__() { -37 } }

unless (defined &__FLT_MIN_EXP__) { sub __FLT_MIN_EXP__() { -125 } }

unless (defined &__FLT_MIN__) { sub __FLT_MIN__() { 1.1754943508222875e-38 } }

unless (defined &__FLT_RADIX__) { sub __FLT_RADIX__() { 2 } }

unless (defined &__FRACT_EPSILON__) { sub __FRACT_EPSILON__() { "0x1P\-15R" } }

unless (defined &__FRACT_FBIT__) { sub __FRACT_FBIT__() { 15 } }

unless (defined &__FRACT_IBIT__) { sub __FRACT_IBIT__() { 0 } }

unless (defined &__FRACT_MAX__) { sub __FRACT_MAX__() { "0X7FFFP\-15R" } }

unless (defined &__FRACT_MIN__) { sub __FRACT_MIN__() { "\-0\.5R\-0\.5R" } }

unless (defined &__GCC_ATOMIC_BOOL_LOCK_FREE) { sub __GCC_ATOMIC_BOOL_LOCK_FREE() { 1 } }

unless (defined &__GCC_ATOMIC_CHAR16_T_LOCK_FREE) { sub __GCC_ATOMIC_CHAR16_T_LOCK_FREE() { 1 } }

unless (defined &__GCC_ATOMIC_CHAR32_T_LOCK_FREE) { sub __GCC_ATOMIC_CHAR32_T_LOCK_FREE() { 2 } }

unless (defined &__GCC_ATOMIC_CHAR_LOCK_FREE) { sub __GCC_ATOMIC_CHAR_LOCK_FREE() { 1 } }

unless (defined &__GCC_ATOMIC_INT_LOCK_FREE) { sub __GCC_ATOMIC_INT_LOCK_FREE() { 2 } }

unless (defined &__GCC_ATOMIC_LLONG_LOCK_FREE) { sub __GCC_ATOMIC_LLONG_LOCK_FREE() { 1 } }

unless (defined &__GCC_ATOMIC_LONG_LOCK_FREE) { sub __GCC_ATOMIC_LONG_LOCK_FREE() { 2 } }

unless (defined &__GCC_ATOMIC_POINTER_LOCK_FREE) { sub __GCC_ATOMIC_POINTER_LOCK_FREE() { 2 } }

unless (defined &__GCC_ATOMIC_SHORT_LOCK_FREE) { sub __GCC_ATOMIC_SHORT_LOCK_FREE() { 1 } }

unless (defined &__GCC_ATOMIC_TEST_AND_SET_TRUEVAL) { sub __GCC_ATOMIC_TEST_AND_SET_TRUEVAL() { 1 } }

unless (defined &__GCC_ATOMIC_WCHAR_T_LOCK_FREE) { sub __GCC_ATOMIC_WCHAR_T_LOCK_FREE() { 2 } }

unless (defined &__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4) { sub __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4() { 1 } }

unless (defined &__GCC_IEC_559) { sub __GCC_IEC_559() { 2 } }

unless (defined &__GCC_IEC_559_COMPLEX) { sub __GCC_IEC_559_COMPLEX() { 2 } }

unless (defined &__GLIBC_MINOR__) { sub __GLIBC_MINOR__() { 19 } }

unless (defined &__GLIBC__) { sub __GLIBC__() { 2 } }

unless (defined &__GNUC_GNU_INLINE__) { sub __GNUC_GNU_INLINE__() { 1 } }

unless (defined &__GNUC_MINOR__) { sub __GNUC_MINOR__() { 9 } }

unless (defined &__GNUC_PATCHLEVEL__) { sub __GNUC_PATCHLEVEL__() { 2 } }

unless (defined &__GNUC__) { sub __GNUC__() { 4 } }

unless (defined &__GNU_LIBRARY__) { sub __GNU_LIBRARY__() { 6 } }

unless (defined &__GXX_ABI_VERSION) { sub __GXX_ABI_VERSION() { 1002 } }

unless (defined &__GXX_TYPEINFO_EQUALITY_INLINE) { sub __GXX_TYPEINFO_EQUALITY_INLINE() { 0 } }

unless (defined &__HA_FBIT__) { sub __HA_FBIT__() { 7 } }

unless (defined &__HA_IBIT__) { sub __HA_IBIT__() { 8 } }

unless (defined &__HQ_FBIT__) { sub __HQ_FBIT__() { 15 } }

unless (defined &__HQ_IBIT__) { sub __HQ_IBIT__() { 0 } }

unless (defined &__INT16_C) { sub __INT16_C() { &__INT16_C } }

unless (defined &__INT16_MAX__) { sub __INT16_MAX__() { 32767 } }

unless (defined &__INT16_TYPE__) { sub __INT16_TYPE__() { "short\\\ int" } }

unless (defined &__INT32_C) { sub __INT32_C() { &__INT32_C } }

unless (defined &__INT32_MAX__) { sub __INT32_MAX__() { 2147483647 } }

unless (defined &__INT32_TYPE__) { sub __INT32_TYPE__() { "int" } }

unless (defined &__INT64_C) { sub __INT64_C() { &__INT64_C } }

unless (defined &__INT64_MAX__) { sub __INT64_MAX__() { 9223372036854775807 } }

unless (defined &__INT64_TYPE__) { sub __INT64_TYPE__() { "long\\\ long\\\ int" } }

unless (defined &__INT8_C) { sub __INT8_C() { &__INT8_C } }

unless (defined &__INT8_MAX__) { sub __INT8_MAX__() { 127 } }

unless (defined &__INT8_TYPE__) { sub __INT8_TYPE__() { "signed\\\ char" } }

unless (defined &__INTMAX_C) { sub __INTMAX_C() { &__INTMAX_C } }

unless (defined &__INTMAX_MAX__) { sub __INTMAX_MAX__() { 9223372036854775807 } }

unless (defined &__INTMAX_TYPE__) { sub __INTMAX_TYPE__() { "long\\\ long\\\ int" } }

unless (defined &__INTPTR_MAX__) { sub __INTPTR_MAX__() { 2147483647 } }

unless (defined &__INTPTR_TYPE__) { sub __INTPTR_TYPE__() { "int" } }

unless (defined &__INT_FAST16_MAX__) { sub __INT_FAST16_MAX__() { 2147483647 } }

unless (defined &__INT_FAST16_TYPE__) { sub __INT_FAST16_TYPE__() { "int" } }

unless (defined &__INT_FAST32_MAX__) { sub __INT_FAST32_MAX__() { 2147483647 } }

unless (defined &__INT_FAST32_TYPE__) { sub __INT_FAST32_TYPE__() { "int" } }

unless (defined &__INT_FAST64_MAX__) { sub __INT_FAST64_MAX__() { 9223372036854775807 } }

unless (defined &__INT_FAST64_TYPE__) { sub __INT_FAST64_TYPE__() { "long\\\ long\\\ int" } }

unless (defined &__INT_FAST8_MAX__) { sub __INT_FAST8_MAX__() { 127 } }

unless (defined &__INT_FAST8_TYPE__) { sub __INT_FAST8_TYPE__() { "signed\\\ char" } }

unless (defined &__INT_LEAST16_MAX__) { sub __INT_LEAST16_MAX__() { 32767 } }

unless (defined &__INT_LEAST16_TYPE__) { sub __INT_LEAST16_TYPE__() { "short\\\ int" } }

unless (defined &__INT_LEAST32_MAX__) { sub __INT_LEAST32_MAX__() { 2147483647 } }

unless (defined &__INT_LEAST32_TYPE__) { sub __INT_LEAST32_TYPE__() { "int" } }

unless (defined &__INT_LEAST64_MAX__) { sub __INT_LEAST64_MAX__() { 9223372036854775807 } }

unless (defined &__INT_LEAST64_TYPE__) { sub __INT_LEAST64_TYPE__() { "long\\\ long\\\ int" } }

unless (defined &__INT_LEAST8_MAX__) { sub __INT_LEAST8_MAX__() { 127 } }

unless (defined &__INT_LEAST8_TYPE__) { sub __INT_LEAST8_TYPE__() { "signed\\\ char" } }

unless (defined &__INT_MAX__) { sub __INT_MAX__() { 2147483647 } }

unless (defined &__LACCUM_EPSILON__) { sub __LACCUM_EPSILON__() { "0x1P\-31LK" } }

unless (defined &__LACCUM_FBIT__) { sub __LACCUM_FBIT__() { 31 } }

unless (defined &__LACCUM_IBIT__) { sub __LACCUM_IBIT__() { 32 } }

unless (defined &__LACCUM_MAX__) { sub __LACCUM_MAX__() { "0X7FFFFFFFFFFFFFFFP\-31LK" } }

unless (defined &__LACCUM_MIN__) { sub __LACCUM_MIN__() { "\-0X1P31LK\-0X1P31LK" } }

unless (defined &__LDBL_DENORM_MIN__) { sub __LDBL_DENORM_MIN__() { 4.9406564584124654e-324 } }

unless (defined &__LDBL_DIG__) { sub __LDBL_DIG__() { 15 } }

unless (defined &__LDBL_EPSILON__) { sub __LDBL_EPSILON__() { 2.2204460492503131e-16 } }

unless (defined &__LDBL_HAS_DENORM__) { sub __LDBL_HAS_DENORM__() { 1 } }

unless (defined &__LDBL_HAS_INFINITY__) { sub __LDBL_HAS_INFINITY__() { 1 } }

unless (defined &__LDBL_HAS_QUIET_NAN__) { sub __LDBL_HAS_QUIET_NAN__() { 1 } }

unless (defined &__LDBL_MANT_DIG__) { sub __LDBL_MANT_DIG__() { 53 } }

unless (defined &__LDBL_MAX_10_EXP__) { sub __LDBL_MAX_10_EXP__() { 308 } }

unless (defined &__LDBL_MAX_EXP__) { sub __LDBL_MAX_EXP__() { 1024 } }

unless (defined &__LDBL_MAX__) { sub __LDBL_MAX__() { 1.7976931348623157e+308 } }

unless (defined &__LDBL_MIN_10_EXP__) { sub __LDBL_MIN_10_EXP__() { -307 } }

unless (defined &__LDBL_MIN_EXP__) { sub __LDBL_MIN_EXP__() { -1021 } }

unless (defined &__LDBL_MIN__) { sub __LDBL_MIN__() { 2.2250738585072014e-308 } }

unless (defined &__LFRACT_EPSILON__) { sub __LFRACT_EPSILON__() { "0x1P\-31LR" } }

unless (defined &__LFRACT_FBIT__) { sub __LFRACT_FBIT__() { 31 } }

unless (defined &__LFRACT_IBIT__) { sub __LFRACT_IBIT__() { 0 } }

unless (defined &__LFRACT_MAX__) { sub __LFRACT_MAX__() { "0X7FFFFFFFP\-31LR" } }

unless (defined &__LFRACT_MIN__) { sub __LFRACT_MIN__() { "\-0\.5LR\-0\.5LR" } }

unless (defined &__LLACCUM_EPSILON__) { sub __LLACCUM_EPSILON__() { "0x1P\-31LLK" } }

unless (defined &__LLACCUM_FBIT__) { sub __LLACCUM_FBIT__() { 31 } }

unless (defined &__LLACCUM_IBIT__) { sub __LLACCUM_IBIT__() { 32 } }

unless (defined &__LLACCUM_MAX__) { sub __LLACCUM_MAX__() { "0X7FFFFFFFFFFFFFFFP\-31LLK" } }

unless (defined &__LLACCUM_MIN__) { sub __LLACCUM_MIN__() { "\-0X1P31LLK\-0X1P31LLK" } }

unless (defined &__LLFRACT_EPSILON__) { sub __LLFRACT_EPSILON__() { "0x1P\-63LLR" } }

unless (defined &__LLFRACT_FBIT__) { sub __LLFRACT_FBIT__() { 63 } }

unless (defined &__LLFRACT_IBIT__) { sub __LLFRACT_IBIT__() { 0 } }

unless (defined &__LLFRACT_MAX__) { sub __LLFRACT_MAX__() { "0X7FFFFFFFFFFFFFFFP\-63LLR" } }

unless (defined &__LLFRACT_MIN__) { sub __LLFRACT_MIN__() { "\-0\.5LLR\-0\.5LLR" } }

unless (defined &__LONG_LONG_MAX__) { sub __LONG_LONG_MAX__() { 9223372036854775807 } }

unless (defined &__LONG_MAX__) { sub __LONG_MAX__() { 2147483647 } }

unless (defined &__ORDER_BIG_ENDIAN__) { sub __ORDER_BIG_ENDIAN__() { 4321 } }

unless (defined &__ORDER_LITTLE_ENDIAN__) { sub __ORDER_LITTLE_ENDIAN__() { 1234 } }

unless (defined &__ORDER_PDP_ENDIAN__) { sub __ORDER_PDP_ENDIAN__() { 3412 } }

unless (defined &__PRAGMA_REDEFINE_EXTNAME) { sub __PRAGMA_REDEFINE_EXTNAME() { 1 } }

unless (defined &__PTRDIFF_MAX__) { sub __PTRDIFF_MAX__() { 2147483647 } }

unless (defined &__PTRDIFF_TYPE__) { sub __PTRDIFF_TYPE__() { "int" } }

unless (defined &__QQ_FBIT__) { sub __QQ_FBIT__() { 7 } }

unless (defined &__QQ_IBIT__) { sub __QQ_IBIT__() { 0 } }

unless (defined &__SACCUM_EPSILON__) { sub __SACCUM_EPSILON__() { "0x1P\-7HK" } }

unless (defined &__SACCUM_FBIT__) { sub __SACCUM_FBIT__() { 7 } }

unless (defined &__SACCUM_IBIT__) { sub __SACCUM_IBIT__() { 8 } }

unless (defined &__SACCUM_MAX__) { sub __SACCUM_MAX__() { "0X7FFFP\-7HK" } }

unless (defined &__SACCUM_MIN__) { sub __SACCUM_MIN__() { "\-0X1P7HK\-0X1P7HK" } }

unless (defined &__SA_FBIT__) { sub __SA_FBIT__() { 15 } }

unless (defined &__SA_IBIT__) { sub __SA_IBIT__() { 16 } }

unless (defined &__SCHAR_MAX__) { sub __SCHAR_MAX__() { 127 } }

unless (defined &__SFRACT_EPSILON__) { sub __SFRACT_EPSILON__() { "0x1P\-7HR" } }

unless (defined &__SFRACT_FBIT__) { sub __SFRACT_FBIT__() { 7 } }

unless (defined &__SFRACT_IBIT__) { sub __SFRACT_IBIT__() { 0 } }

unless (defined &__SFRACT_MAX__) { sub __SFRACT_MAX__() { "0X7FP\-7HR" } }

unless (defined &__SFRACT_MIN__) { sub __SFRACT_MIN__() { "\-0\.5HR\-0\.5HR" } }

unless (defined &__SHRT_MAX__) { sub __SHRT_MAX__() { 32767 } }

unless (defined &__SIG_ATOMIC_MAX__) { sub __SIG_ATOMIC_MAX__() { 2147483647 } }

unless (defined &__SIG_ATOMIC_MIN__) { sub __SIG_ATOMIC_MIN__() { "\-2147483647\\\ \-\\\ 1" } }

unless (defined &__SIG_ATOMIC_TYPE__) { sub __SIG_ATOMIC_TYPE__() { "int" } }

unless (defined &__SIZEOF_DOUBLE__) { sub __SIZEOF_DOUBLE__() { 8 } }

unless (defined &__SIZEOF_FLOAT__) { sub __SIZEOF_FLOAT__() { 4 } }

unless (defined &__SIZEOF_INT__) { sub __SIZEOF_INT__() { 4 } }

unless (defined &__SIZEOF_LONG_DOUBLE__) { sub __SIZEOF_LONG_DOUBLE__() { 8 } }

unless (defined &__SIZEOF_LONG_LONG__) { sub __SIZEOF_LONG_LONG__() { 8 } }

unless (defined &__SIZEOF_LONG__) { sub __SIZEOF_LONG__() { 4 } }

unless (defined &__SIZEOF_POINTER__) { sub __SIZEOF_POINTER__() { 4 } }

unless (defined &__SIZEOF_PTRDIFF_T__) { sub __SIZEOF_PTRDIFF_T__() { 4 } }

unless (defined &__SIZEOF_SHORT__) { sub __SIZEOF_SHORT__() { 2 } }

unless (defined &__SIZEOF_SIZE_T__) { sub __SIZEOF_SIZE_T__() { 4 } }

unless (defined &__SIZEOF_WCHAR_T__) { sub __SIZEOF_WCHAR_T__() { 4 } }

unless (defined &__SIZEOF_WINT_T__) { sub __SIZEOF_WINT_T__() { 4 } }

unless (defined &__SIZE_MAX__) { sub __SIZE_MAX__() { 4294967295 } }

unless (defined &__SIZE_TYPE__) { sub __SIZE_TYPE__() { "unsigned\\\ int" } }

unless (defined &__SQ_FBIT__) { sub __SQ_FBIT__() { 31 } }

unless (defined &__SQ_IBIT__) { sub __SQ_IBIT__() { 0 } }

unless (defined &__STDC_HOSTED__) { sub __STDC_HOSTED__() { 1 } }

unless (defined &__STDC_IEC_559_COMPLEX__) { sub __STDC_IEC_559_COMPLEX__() { 1 } }

unless (defined &__STDC_IEC_559__) { sub __STDC_IEC_559__() { 1 } }

unless (defined &__STDC_ISO_10646__) { sub __STDC_ISO_10646__() { 201103 } }

unless (defined &__STDC_NO_THREADS__) { sub __STDC_NO_THREADS__() { 1 } }

unless (defined &__STDC__) { sub __STDC__() { 1 } }

unless (defined &__TA_FBIT__) { sub __TA_FBIT__() { 63 } }

unless (defined &__TA_IBIT__) { sub __TA_IBIT__() { 64 } }

unless (defined &__THUMB_INTERWORK__) { sub __THUMB_INTERWORK__() { 1 } }

unless (defined &__TQ_FBIT__) { sub __TQ_FBIT__() { 127 } }

unless (defined &__TQ_IBIT__) { sub __TQ_IBIT__() { 0 } }

unless (defined &__UACCUM_EPSILON__) { sub __UACCUM_EPSILON__() { "0x1P\-16UK" } }

unless (defined &__UACCUM_FBIT__) { sub __UACCUM_FBIT__() { 16 } }

unless (defined &__UACCUM_IBIT__) { sub __UACCUM_IBIT__() { 16 } }

unless (defined &__UACCUM_MAX__) { sub __UACCUM_MAX__() { "0XFFFFFFFFP\-16UK" } }

unless (defined &__UACCUM_MIN__) { sub __UACCUM_MIN__() { "0\.0UK" } }

unless (defined &__UDA_FBIT__) { sub __UDA_FBIT__() { 32 } }

unless (defined &__UDA_IBIT__) { sub __UDA_IBIT__() { 32 } }

unless (defined &__UDQ_FBIT__) { sub __UDQ_FBIT__() { 64 } }

unless (defined &__UDQ_IBIT__) { sub __UDQ_IBIT__() { 0 } }

unless (defined &__UFRACT_EPSILON__) { sub __UFRACT_EPSILON__() { "0x1P\-16UR" } }

unless (defined &__UFRACT_FBIT__) { sub __UFRACT_FBIT__() { 16 } }

unless (defined &__UFRACT_IBIT__) { sub __UFRACT_IBIT__() { 0 } }

unless (defined &__UFRACT_MAX__) { sub __UFRACT_MAX__() { "0XFFFFP\-16UR" } }

unless (defined &__UFRACT_MIN__) { sub __UFRACT_MIN__() { "0\.0UR" } }

unless (defined &__UHA_FBIT__) { sub __UHA_FBIT__() { 8 } }

unless (defined &__UHA_IBIT__) { sub __UHA_IBIT__() { 8 } }

unless (defined &__UHQ_FBIT__) { sub __UHQ_FBIT__() { 16 } }

unless (defined &__UHQ_IBIT__) { sub __UHQ_IBIT__() { 0 } }

unless (defined &__UINT16_C) { sub __UINT16_C() { &__UINT16_C } }

unless (defined &__UINT16_MAX__) { sub __UINT16_MAX__() { 65535 } }

unless (defined &__UINT16_TYPE__) { sub __UINT16_TYPE__() { "short\\\ unsigned\\\ int" } }

unless (defined &__UINT32_C) { sub __UINT32_C() { &__UINT32_C } }

unless (defined &__UINT32_MAX__) { sub __UINT32_MAX__() { 4294967295 } }

unless (defined &__UINT32_TYPE__) { sub __UINT32_TYPE__() { "unsigned\\\ int" } }

unless (defined &__UINT64_C) { sub __UINT64_C() { &__UINT64_C } }

unless (defined &__UINT64_MAX__) { sub __UINT64_MAX__() { 18446744073709551615 } }

unless (defined &__UINT64_TYPE__) { sub __UINT64_TYPE__() { "long\\\ long\\\ unsigned\\\ int" } }

unless (defined &__UINT8_C) { sub __UINT8_C() { &__UINT8_C } }

unless (defined &__UINT8_MAX__) { sub __UINT8_MAX__() { 255 } }

unless (defined &__UINT8_TYPE__) { sub __UINT8_TYPE__() { "unsigned\\\ char" } }

unless (defined &__UINTMAX_C) { sub __UINTMAX_C() { &__UINTMAX_C } }

unless (defined &__UINTMAX_MAX__) { sub __UINTMAX_MAX__() { 18446744073709551615 } }

unless (defined &__UINTMAX_TYPE__) { sub __UINTMAX_TYPE__() { "long\\\ long\\\ unsigned\\\ int" } }

unless (defined &__UINTPTR_MAX__) { sub __UINTPTR_MAX__() { 4294967295 } }

unless (defined &__UINTPTR_TYPE__) { sub __UINTPTR_TYPE__() { "unsigned\\\ int" } }

unless (defined &__UINT_FAST16_MAX__) { sub __UINT_FAST16_MAX__() { 4294967295 } }

unless (defined &__UINT_FAST16_TYPE__) { sub __UINT_FAST16_TYPE__() { "unsigned\\\ int" } }

unless (defined &__UINT_FAST32_MAX__) { sub __UINT_FAST32_MAX__() { 4294967295 } }

unless (defined &__UINT_FAST32_TYPE__) { sub __UINT_FAST32_TYPE__() { "unsigned\\\ int" } }

unless (defined &__UINT_FAST64_MAX__) { sub __UINT_FAST64_MAX__() { 18446744073709551615 } }

unless (defined &__UINT_FAST64_TYPE__) { sub __UINT_FAST64_TYPE__() { "long\\\ long\\\ unsigned\\\ int" } }

unless (defined &__UINT_FAST8_MAX__) { sub __UINT_FAST8_MAX__() { 255 } }

unless (defined &__UINT_FAST8_TYPE__) { sub __UINT_FAST8_TYPE__() { "unsigned\\\ char" } }

unless (defined &__UINT_LEAST16_MAX__) { sub __UINT_LEAST16_MAX__() { 65535 } }

unless (defined &__UINT_LEAST16_TYPE__) { sub __UINT_LEAST16_TYPE__() { "short\\\ unsigned\\\ int" } }

unless (defined &__UINT_LEAST32_MAX__) { sub __UINT_LEAST32_MAX__() { 4294967295 } }

unless (defined &__UINT_LEAST32_TYPE__) { sub __UINT_LEAST32_TYPE__() { "unsigned\\\ int" } }

unless (defined &__UINT_LEAST64_MAX__) { sub __UINT_LEAST64_MAX__() { 18446744073709551615 } }

unless (defined &__UINT_LEAST64_TYPE__) { sub __UINT_LEAST64_TYPE__() { "long\\\ long\\\ unsigned\\\ int" } }

unless (defined &__UINT_LEAST8_MAX__) { sub __UINT_LEAST8_MAX__() { 255 } }

unless (defined &__UINT_LEAST8_TYPE__) { sub __UINT_LEAST8_TYPE__() { "unsigned\\\ char" } }

unless (defined &__ULACCUM_EPSILON__) { sub __ULACCUM_EPSILON__() { "0x1P\-32ULK" } }

unless (defined &__ULACCUM_FBIT__) { sub __ULACCUM_FBIT__() { 32 } }

unless (defined &__ULACCUM_IBIT__) { sub __ULACCUM_IBIT__() { 32 } }

unless (defined &__ULACCUM_MAX__) { sub __ULACCUM_MAX__() { "0XFFFFFFFFFFFFFFFFP\-32ULK" } }

unless (defined &__ULACCUM_MIN__) { sub __ULACCUM_MIN__() { "0\.0ULK" } }

unless (defined &__ULFRACT_EPSILON__) { sub __ULFRACT_EPSILON__() { "0x1P\-32ULR" } }

unless (defined &__ULFRACT_FBIT__) { sub __ULFRACT_FBIT__() { 32 } }

unless (defined &__ULFRACT_IBIT__) { sub __ULFRACT_IBIT__() { 0 } }

unless (defined &__ULFRACT_MAX__) { sub __ULFRACT_MAX__() { "0XFFFFFFFFP\-32ULR" } }

unless (defined &__ULFRACT_MIN__) { sub __ULFRACT_MIN__() { "0\.0ULR" } }

unless (defined &__ULLACCUM_EPSILON__) { sub __ULLACCUM_EPSILON__() { "0x1P\-32ULLK" } }

unless (defined &__ULLACCUM_FBIT__) { sub __ULLACCUM_FBIT__() { 32 } }

unless (defined &__ULLACCUM_IBIT__) { sub __ULLACCUM_IBIT__() { 32 } }

unless (defined &__ULLACCUM_MAX__) { sub __ULLACCUM_MAX__() { "0XFFFFFFFFFFFFFFFFP\-32ULLK" } }

unless (defined &__ULLACCUM_MIN__) { sub __ULLACCUM_MIN__() { "0\.0ULLK" } }

unless (defined &__ULLFRACT_EPSILON__) { sub __ULLFRACT_EPSILON__() { "0x1P\-64ULLR" } }

unless (defined &__ULLFRACT_FBIT__) { sub __ULLFRACT_FBIT__() { 64 } }

unless (defined &__ULLFRACT_IBIT__) { sub __ULLFRACT_IBIT__() { 0 } }

unless (defined &__ULLFRACT_MAX__) { sub __ULLFRACT_MAX__() { "0XFFFFFFFFFFFFFFFFP\-64ULLR" } }

unless (defined &__ULLFRACT_MIN__) { sub __ULLFRACT_MIN__() { "0\.0ULLR" } }

unless (defined &__UQQ_FBIT__) { sub __UQQ_FBIT__() { 8 } }

unless (defined &__UQQ_IBIT__) { sub __UQQ_IBIT__() { 0 } }

unless (defined &__USACCUM_EPSILON__) { sub __USACCUM_EPSILON__() { "0x1P\-8UHK" } }

unless (defined &__USACCUM_FBIT__) { sub __USACCUM_FBIT__() { 8 } }

unless (defined &__USACCUM_IBIT__) { sub __USACCUM_IBIT__() { 8 } }

unless (defined &__USACCUM_MAX__) { sub __USACCUM_MAX__() { "0XFFFFP\-8UHK" } }

unless (defined &__USACCUM_MIN__) { sub __USACCUM_MIN__() { "0\.0UHK" } }

unless (defined &__USA_FBIT__) { sub __USA_FBIT__() { 16 } }

unless (defined &__USA_IBIT__) { sub __USA_IBIT__() { 16 } }

unless (defined &__USE_BSD) { sub __USE_BSD() { 1 } }

unless (defined &__USE_FILE_OFFSET64) { sub __USE_FILE_OFFSET64() { 1 } }

unless (defined &__USE_GNU) { sub __USE_GNU() { 1 } }

unless (defined &__USE_LARGEFILE) { sub __USE_LARGEFILE() { 1 } }

unless (defined &__USE_LARGEFILE64) { sub __USE_LARGEFILE64() { 1 } }

unless (defined &__USE_MISC) { sub __USE_MISC() { 1 } }

unless (defined &__USE_POSIX) { sub __USE_POSIX() { 1 } }

unless (defined &__USE_POSIX199309) { sub __USE_POSIX199309() { 1 } }

unless (defined &__USE_POSIX199506) { sub __USE_POSIX199506() { 1 } }

unless (defined &__USE_POSIX2) { sub __USE_POSIX2() { 1 } }

unless (defined &__USE_REENTRANT) { sub __USE_REENTRANT() { 1 } }

unless (defined &__USE_SVID) { sub __USE_SVID() { 1 } }

unless (defined &__USE_UNIX98) { sub __USE_UNIX98() { 1 } }

unless (defined &__USE_XOPEN) { sub __USE_XOPEN() { 1 } }

unless (defined &__USE_XOPEN_EXTENDED) { sub __USE_XOPEN_EXTENDED() { 1 } }

unless (defined &__USFRACT_EPSILON__) { sub __USFRACT_EPSILON__() { "0x1P\-8UHR" } }

unless (defined &__USFRACT_FBIT__) { sub __USFRACT_FBIT__() { 8 } }

unless (defined &__USFRACT_IBIT__) { sub __USFRACT_IBIT__() { 0 } }

unless (defined &__USFRACT_MAX__) { sub __USFRACT_MAX__() { "0XFFP\-8UHR" } }

unless (defined &__USFRACT_MIN__) { sub __USFRACT_MIN__() { "0\.0UHR" } }

unless (defined &__USQ_FBIT__) { sub __USQ_FBIT__() { 32 } }

unless (defined &__USQ_IBIT__) { sub __USQ_IBIT__() { 0 } }

unless (defined &__UTA_FBIT__) { sub __UTA_FBIT__() { 64 } }

unless (defined &__UTA_IBIT__) { sub __UTA_IBIT__() { 64 } }

unless (defined &__UTQ_FBIT__) { sub __UTQ_FBIT__() { 128 } }

unless (defined &__UTQ_IBIT__) { sub __UTQ_IBIT__() { 0 } }

unless (defined &__VERSION__) { sub __VERSION__() { "\"4\.9\.2\"" } }

unless (defined &__VFP_FP__) { sub __VFP_FP__() { 1 } }

unless (defined &__WCHAR_MAX__) { sub __WCHAR_MAX__() { 4294967295 } }

unless (defined &__WCHAR_MIN__) { sub __WCHAR_MIN__() { 0 } }

unless (defined &__WCHAR_TYPE__) { sub __WCHAR_TYPE__() { "unsigned\\\ int" } }

unless (defined &__WINT_MAX__) { sub __WINT_MAX__() { 4294967295 } }

unless (defined &__WINT_MIN__) { sub __WINT_MIN__() { 0 } }

unless (defined &__WINT_TYPE__) { sub __WINT_TYPE__() { "unsigned\\\ int" } }

unless (defined &__arm__) { sub __arm__() { 1 } }

unless (defined &__gnu_linux__) { sub __gnu_linux__() { 1 } }

unless (defined &__has_include) { sub __has_include() { &__has_include } }

unless (defined &__has_include_next) { sub __has_include_next() { &__has_include_next } }

unless (defined &__linux) { sub __linux() { 1 } }

unless (defined &__linux__) { sub __linux__() { 1 } }

unless (defined &__unix) { sub __unix() { 1 } }

unless (defined &__unix__) { sub __unix__() { 1 } }

unless (defined &linux) { sub linux() { 1 } }

unless (defined &unix) { sub unix() { 1 } }


1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 package threads;

use 5.008;

use strict;
use warnings;

our $VERSION = '1.93';
my $XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

# Verify this Perl supports threads
require Config;
if (! $Config::Config{useithreads}) {
    die("This Perl not built to support threads\n");
}

# Complain if 'threads' is loaded after 'threads::shared'
if ($threads::shared::threads_shared) {
    warn <<'_MSG_';
Warning, threads::shared has already been loaded.  To
enable shared variables, 'use threads' must be called
before threads::shared or any module that uses it.
_MSG_
}

# Declare that we have been loaded
$threads::threads = 1;

# Load the XS code
require XSLoader;
XSLoader::load('threads', $XS_VERSION);


### Export ###

sub import
{
    my $class = shift;   # Not used

    # Exported subroutines
    my @EXPORT = qw(async);

    # Handle args
    while (my $sym = shift) {
        if ($sym =~ /^(?:stack|exit)/i) {
            if (defined(my $arg = shift)) {
                if ($sym =~ /^stack/i) {
                    threads->set_stack_size($arg);
                } else {
                    $threads::thread_exit_only = $arg =~ /^thread/i;
                }
            } else {
                require Carp;
                Carp::croak("threads: Missing argument for option: $sym");
            }

        } elsif ($sym =~ /^str/i) {
            import overload ('""' => \&tid);

        } elsif ($sym =~ /^(?::all|yield)$/) {
            push(@EXPORT, qw(yield));

        } else {
            require Carp;
            Carp::croak("threads: Unknown import option: $sym");
        }
    }

    # Export subroutine names
    my $caller = caller();
    foreach my $sym (@EXPORT) {
        no strict 'refs';
        *{$caller.'::'.$sym} = \&{$sym};
    }

    # Set stack size via environment variable
    if (exists($ENV{'PERL5_ITHREADS_STACK_SIZE'})) {
        threads->set_stack_size($ENV{'PERL5_ITHREADS_STACK_SIZE'});
    }
}


### Methods, etc. ###

# Exit from a thread (only)
sub exit
{
    my ($class, $status) = @_;
    if (! defined($status)) {
        $status = 0;
    }

    # Class method only
    if (ref($class)) {
        require Carp;
        Carp::croak('Usage: threads->exit(status)');
    }

    $class->set_thread_exit_only(1);
    CORE::exit($status);
}

# 'Constant' args for threads->list()
sub threads::all      { }
sub threads::running  { 1 }
sub threads::joinable { 0 }

# 'new' is an alias for 'create'
*new = \&create;

# 'async' is a function alias for the 'threads->create()' method
sub async (&;@)
{
    unshift(@_, 'threads');
    # Use "goto" trick to avoid pad problems from 5.8.1 (fixed in 5.8.2)
    goto &create;
}

# Thread object equality checking
use overload (
    '==' => \&equal,
    '!=' => sub { ! equal(@_) },
    'fallback' => 1
);

1;

__END__

=head1 NAME

threads - Perl interpreter-based threads

=head1 VERSION

This document describes threads version 1.92

=head1 WARNING

The "interpreter-based threads" provided by Perl are not the fast, lightweight
system for multitasking that one might expect or hope for.  Threads are
implemented in a way that make them easy to misuse.  Few people know how to
use them correctly or will be able to provide help.

The use of interpreter-based threads in perl is officially
L<discouraged|perlpolicy/discouraged>.

=head1 SYNOPSIS

    use threads ('yield',
                 'stack_size' => 64*4096,
                 'exit' => 'threads_only',
                 'stringify');

    sub start_thread {
        my @args = @_;
        print('Thread started: ', join(' ', @args), "\n");
    }
    my $thr = threads->create('start_thread', 'argument');
    $thr->join();

    threads->create(sub { print("I am a thread\n"); })->join();

    my $thr2 = async { foreach (@files) { ... } };
    $thr2->join();
    if (my $err = $thr2->error()) {
        warn("Thread error: $err\n");
    }

    # Invoke thread in list context (implicit) so it can return a list
    my ($thr) = threads->create(sub { return (qw/a b c/); });
    # or specify list context explicitly
    my $thr = threads->create({'context' => 'list'},
                              sub { return (qw/a b c/); });
    my @results = $thr->join();

    $thr->detach();

    # Get a thread's object
    $thr = threads->self();
    $thr = threads->object($tid);

    # Get a thread's ID
    $tid = threads->tid();
    $tid = $thr->tid();
    $tid = "$thr";

    # Give other threads a chance to run
    threads->yield();
    yield();

    # Lists of non-detached threads
    my @threads = threads->list();
    my $thread_count = threads->list();

    my @running = threads->list(threads::running);
    my @joinable = threads->list(threads::joinable);

    # Test thread objects
    if ($thr1 == $thr2) {
        ...
    }

    # Manage thread stack size
    $stack_size = threads->get_stack_size();
    $old_size = threads->set_stack_size(32*4096);

    # Create a thread with a specific context and stack size
    my $thr = threads->create({ 'context'    => 'list',
                                'stack_size' => 32*4096,
                                'exit'       => 'thread_only' },
                              \&foo);

    # Get thread's context
    my $wantarray = $thr->wantarray();

    # Check thread's state
    if ($thr->is_running()) {
        sleep(1);
    }
    if ($thr->is_joinable()) {
        $thr->join();
    }

    # Send a signal to a thread
    $thr->kill('SIGUSR1');

    # Exit a thread
    threads->exit();

=head1 DESCRIPTION

Since Perl 5.8, thread programming has been available using a model called
I<interpreter threads> which provides a new Perl interpreter for each
thread, and, by default, results in no data or state information being shared
between threads.

(Prior to Perl 5.8, I<5005threads> was available through the C<Thread.pm> API.
This threading model has been deprecated, and was removed as of Perl 5.10.0.)

As just mentioned, all variables are, by default, thread local.  To use shared
variables, you need to also load L<threads::shared>:

    use threads;
    use threads::shared;

When loading L<threads::shared>, you must C<use threads> before you
C<use threads::shared>.  (C<threads> will emit a warning if you do it the
other way around.)

It is strongly recommended that you enable threads via C<use threads> as early
as possible in your script.

If needed, scripts can be written so as to run on both threaded and
non-threaded Perls:

    my $can_use_threads = eval 'use threads; 1';
    if ($can_use_threads) {
        # Do processing using threads
        ...
    } else {
        # Do it without using threads
        ...
    }

=over

=item $thr = threads->create(FUNCTION, ARGS)

This will create a new thread that will begin execution with the specified
entry point function, and give it the I<ARGS> list as parameters.  It will
return the corresponding threads object, or C<undef> if thread creation failed.

I<FUNCTION> may either be the name of a function, an anonymous subroutine, or
a code ref.

    my $thr = threads->create('func_name', ...);
        # or
    my $thr = threads->create(sub { ... }, ...);
        # or
    my $thr = threads->create(\&func, ...);

The C<-E<gt>new()> method is an alias for C<-E<gt>create()>.

=item $thr->join()

This will wait for the corresponding thread to complete its execution.  When
the thread finishes, C<-E<gt>join()> will return the return value(s) of the
entry point function.

The context (void, scalar or list) for the return value(s) for C<-E<gt>join()>
is determined at the time of thread creation.

    # Create thread in list context (implicit)
    my ($thr1) = threads->create(sub {
                                    my @results = qw(a b c);
                                    return (@results);
                                 });
    #   or (explicit)
    my $thr1 = threads->create({'context' => 'list'},
                               sub {
                                    my @results = qw(a b c);
                                    return (@results);
                               });
    # Retrieve list results from thread
    my @res1 = $thr1->join();

    # Create thread in scalar context (implicit)
    my $thr2 = threads->create(sub {
                                    my $result = 42;
                                    return ($result);
                                 });
    # Retrieve scalar result from thread
    my $res2 = $thr2->join();

    # Create a thread in void context (explicit)
    my $thr3 = threads->create({'void' => 1},
                               sub { print("Hello, world\n"); });
    # Join the thread in void context (i.e., no return value)
    $thr3->join();

See L</"THREAD CONTEXT"> for more details.

If the program exits without all threads having either been joined or
detached, then a warning will be issued.

Calling C<-E<gt>join()> or C<-E<gt>detach()> on an already joined thread will
cause an error to be thrown.

=item $thr->detach()

Makes the thread unjoinable, and causes any eventual return value to be
discarded.  When the program exits, any detached threads that are still
running are silently terminated.

If the program exits without all threads having either been joined or
detached, then a warning will be issued.

Calling C<-E<gt>join()> or C<-E<gt>detach()> on an already detached thread
will cause an error to be thrown.

=item threads->detach()

Class method that allows a thread to detach itself.

=item threads->self()

Class method that allows a thread to obtain its own I<threads> object.

=item $thr->tid()

Returns the ID of the thread.  Thread IDs are unique integers with the main
thread in a program being 0, and incrementing by 1 for every thread created.

=item threads->tid()

Class method that allows a thread to obtain its own ID.

=item "$thr"

If you add the C<stringify> import option to your C<use threads> declaration,
then using a threads object in a string or a string context (e.g., as a hash
key) will cause its ID to be used as the value:

    use threads qw(stringify);

    my $thr = threads->create(...);
    print("Thread $thr started...\n");  # Prints out: Thread 1 started...

=item threads->object($tid)

This will return the I<threads> object for the I<active> thread associated
with the specified thread ID.  If C<$tid> is the value for the current thread,
then this call works the same as C<-E<gt>self()>.  Otherwise, returns C<undef>
if there is no thread associated with the TID, if the thread is joined or
detached, if no TID is specified or if the specified TID is undef.

=item threads->yield()

This is a suggestion to the OS to let this thread yield CPU time to other
threads.  What actually happens is highly dependent upon the underlying
thread implementation.

You may do C<use threads qw(yield)>, and then just use C<yield()> in your
code.

=item threads->list()

=item threads->list(threads::all)

=item threads->list(threads::running)

=item threads->list(threads::joinable)

With no arguments (or using C<threads::all>) and in a list context, returns a
list of all non-joined, non-detached I<threads> objects.  In a scalar context,
returns a count of the same.

With a I<true> argument (using C<threads::running>), returns a list of all
non-joined, non-detached I<threads> objects that are still running.

With a I<false> argument (using C<threads::joinable>), returns a list of all
non-joined, non-detached I<threads> objects that have finished running (i.e.,
for which C<-E<gt>join()> will not I<block>).

=item $thr1->equal($thr2)

Tests if two threads objects are the same thread or not.  This is overloaded
to the more natural forms:

    if ($thr1 == $thr2) {
        print("Threads are the same\n");
    }
    # or
    if ($thr1 != $thr2) {
        print("Threads differ\n");
    }

(Thread comparison is based on thread IDs.)

=item async BLOCK;

C<async> creates a thread to execute the block immediately following
it.  This block is treated as an anonymous subroutine, and so must have a
semicolon after the closing brace.  Like C<threads-E<gt>create()>, C<async>
returns a I<threads> object.

=item $thr->error()

Threads are executed in an C<eval> context.  This method will return C<undef>
if the thread terminates I<normally>.  Otherwise, it returns the value of
C<$@> associated with the thread's execution status in its C<eval> context.

=item $thr->_handle()

This I<private> method returns a pointer (i.e., the memory location expressed
as an unsigned integer) to the internal thread structure associated with a
threads object.  For Win32, this is a pointer to the C<HANDLE> value returned
by C<CreateThread> (i.e., C<HANDLE *>); for other platforms, it is a pointer
to the C<pthread_t> structure used in the C<pthread_create> call (i.e.,
C<pthread_t *>).

This method is of no use for general Perl threads programming.  Its intent is
to provide other (XS-based) thread modules with the capability to access, and
possibly manipulate, the underlying thread structure associated with a Perl
thread.

=item threads->_handle()

Class method that allows a thread to obtain its own I<handle>.

=back

=head1 EXITING A THREAD

The usual method for terminating a thread is to
L<return()|perlfunc/"return EXPR"> from the entry point function with the
appropriate return value(s).

=over

=item threads->exit()

If needed, a thread can be exited at any time by calling
C<threads-E<gt>exit()>.  This will cause the thread to return C<undef> in a
scalar context, or the empty list in a list context.

When called from the I<main> thread, this behaves the same as C<exit(0)>.

=item threads->exit(status)

When called from a thread, this behaves like C<threads-E<gt>exit()> (i.e., the
exit status code is ignored).

When called from the I<main> thread, this behaves the same as C<exit(status)>.

=item die()

Calling C<die()> in a thread indicates an abnormal exit for the thread.  Any
C<$SIG{__DIE__}> handler in the thread will be called first, and then the
thread will exit with a warning message that will contain any arguments passed
in the C<die()> call.

=item exit(status)

Calling L<exit()|perlfunc/"exit EXPR"> inside a thread causes the whole
application to terminate.  Because of this, the use of C<exit()> inside
threaded code, or in modules that might be used in threaded applications, is
strongly discouraged.

If C<exit()> really is needed, then consider using the following:

    threads->exit() if threads->can('exit');   # Thread friendly
    exit(status);

=item use threads 'exit' => 'threads_only'

This globally overrides the default behavior of calling C<exit()> inside a
thread, and effectively causes such calls to behave the same as
C<threads-E<gt>exit()>.  In other words, with this setting, calling C<exit()>
causes only the thread to terminate.

Because of its global effect, this setting should not be used inside modules
or the like.

The I<main> thread is unaffected by this setting.

=item threads->create({'exit' => 'thread_only'}, ...)

This overrides the default behavior of C<exit()> inside the newly created
thread only.

=item $thr->set_thread_exit_only(boolean)

This can be used to change the I<exit thread only> behavior for a thread after
it has been created.  With a I<true> argument, C<exit()> will cause only the
thread to exit.  With a I<false> argument, C<exit()> will terminate the
application.

The I<main> thread is unaffected by this call.

=item threads->set_thread_exit_only(boolean)

Class method for use inside a thread to change its own behavior for C<exit()>.

The I<main> thread is unaffected by this call.

=back

=head1 THREAD STATE

The following boolean methods are useful in determining the I<state> of a
thread.

=over

=item $thr->is_running()

Returns true if a thread is still running (i.e., if its entry point function
has not yet finished or exited).

=item $thr->is_joinable()

Returns true if the thread has finished running, is not detached and has not
yet been joined.  In other words, the thread is ready to be joined, and a call
to C<$thr-E<gt>join()> will not I<block>.

=item $thr->is_detached()

Returns true if the thread has been detached.

=item threads->is_detached()

Class method that allows a thread to determine whether or not it is detached.

=back

=head1 THREAD CONTEXT

As with subroutines, the type of value returned from a thread's entry point
function may be determined by the thread's I<context>:  list, scalar or void.
The thread's context is determined at thread creation.  This is necessary so
that the context is available to the entry point function via
L<wantarray()|perlfunc/"wantarray">.  The thread may then specify a value of
the appropriate type to be returned from C<-E<gt>join()>.

=head2 Explicit context

Because thread creation and thread joining may occur in different contexts, it
may be desirable to state the context explicitly to the thread's entry point
function.  This may be done by calling C<-E<gt>create()> with a hash reference
as the first argument:

    my $thr = threads->create({'context' => 'list'}, \&foo);
    ...
    my @results = $thr->join();

In the above, the threads object is returned to the parent thread in scalar
context, and the thread's entry point function C<foo> will be called in list
(array) context such that the parent thread can receive a list (array) from
the C<-E<gt>join()> call.  (C<'array'> is synonymous with C<'list'>.)

Similarly, if you need the threads object, but your thread will not be
returning a value (i.e., I<void> context), you would do the following:

    my $thr = threads->create({'context' => 'void'}, \&foo);
    ...
    $thr->join();

The context type may also be used as the I<key> in the hash reference followed
by a I<true> value:

    threads->create({'scalar' => 1}, \&foo);
    ...
    my ($thr) = threads->list();
    my $result = $thr->join();

=head2 Implicit context

If not explicitly stated, the thread's context is implied from the context
of the C<-E<gt>create()> call:

    # Create thread in list context
    my ($thr) = threads->create(...);

    # Create thread in scalar context
    my $thr = threads->create(...);

    # Create thread in void context
    threads->create(...);

=head2 $thr->wantarray()

This returns the thread's context in the same manner as
L<wantarray()|perlfunc/"wantarray">.

=head2 threads->wantarray()

Class method to return the current thread's context.  This returns the same
value as running L<wantarray()|perlfunc/"wantarray"> inside the current
thread's entry point function.

=head1 THREAD STACK SIZE

The default per-thread stack size for different platforms varies
significantly, and is almost always far more than is needed for most
applications.  On Win32, Perl's makefile explicitly sets the default stack to
16 MB; on most other platforms, the system default is used, which again may be
much larger than is needed.

By tuning the stack size to more accurately reflect your application's needs,
you may significantly reduce your application's memory usage, and increase the
number of simultaneously running threads.

Note that on Windows, address space allocation granularity is 64 KB,
therefore, setting the stack smaller than that on Win32 Perl will not save any
more memory.

=over

=item threads->get_stack_size();

Returns the current default per-thread stack size.  The default is zero, which
means the system default stack size is currently in use.

=item $size = $thr->get_stack_size();

Returns the stack size for a particular thread.  A return value of zero
indicates the system default stack size was used for the thread.

=item $old_size = threads->set_stack_size($new_size);

Sets a new default per-thread stack size, and returns the previous setting.

Some platforms have a minimum thread stack size.  Trying to set the stack size
below this value will result in a warning, and the minimum stack size will be
used.

Some Linux platforms have a maximum stack size.  Setting too large of a stack
size will cause thread creation to fail.

If needed, C<$new_size> will be rounded up to the next multiple of the memory
page size (usually 4096 or 8192).

Threads created after the stack size is set will then either call
C<pthread_attr_setstacksize()> I<(for pthreads platforms)>, or supply the
stack size to C<CreateThread()> I<(for Win32 Perl)>.

(Obviously, this call does not affect any currently extant threads.)

=item use threads ('stack_size' => VALUE);

This sets the default per-thread stack size at the start of the application.

=item $ENV{'PERL5_ITHREADS_STACK_SIZE'}

The default per-thread stack size may be set at the start of the application
through the use of the environment variable C<PERL5_ITHREADS_STACK_SIZE>:

    PERL5_ITHREADS_STACK_SIZE=1048576
    export PERL5_ITHREADS_STACK_SIZE
    perl -e'use threads; print(threads->get_stack_size(), "\n")'

This value overrides any C<stack_size> parameter given to C<use threads>.  Its
primary purpose is to permit setting the per-thread stack size for legacy
threaded applications.

=item threads->create({'stack_size' => VALUE}, FUNCTION, ARGS)

To specify a particular stack size for any individual thread, call
C<-E<gt>create()> with a hash reference as the first argument:

    my $thr = threads->create({'stack_size' => 32*4096}, \&foo, @args);

=item $thr2 = $thr1->create(FUNCTION, ARGS)

This creates a new thread (C<$thr2>) that inherits the stack size from an
existing thread (C<$thr1>).  This is shorthand for the following:

    my $stack_size = $thr1->get_stack_size();
    my $thr2 = threads->create({'stack_size' => $stack_size}, FUNCTION, ARGS);

=back

=head1 THREAD SIGNALLING

When safe signals is in effect (the default behavior - see L</"Unsafe signals">
for more details), then signals may be sent and acted upon by individual
threads.

=over 4

=item $thr->kill('SIG...');

Sends the specified signal to the thread.  Signal names and (positive) signal
numbers are the same as those supported by
L<kill()|perlfunc/"kill SIGNAL, LIST">.  For example, 'SIGTERM', 'TERM' and
(depending on the OS) 15 are all valid arguments to C<-E<gt>kill()>.

Returns the thread object to allow for method chaining:

    $thr->kill('SIG...')->join();

=back

Signal handlers need to be set up in the threads for the signals they are
expected to act upon.  Here's an example for I<cancelling> a thread:

    use threads;

    sub thr_func
    {
        # Thread 'cancellation' signal handler
        $SIG{'KILL'} = sub { threads->exit(); };

        ...
    }

    # Create a thread
    my $thr = threads->create('thr_func');

    ...

    # Signal the thread to terminate, and then detach
    # it so that it will get cleaned up automatically
    $thr->kill('KILL')->detach();

Here's another simplistic example that illustrates the use of thread
signalling in conjunction with a semaphore to provide rudimentary I<suspend>
and I<resume> capabilities:

    use threads;
    use Thread::Semaphore;

    sub thr_func
    {
        my $sema = shift;

        # Thread 'suspend/resume' signal handler
        $SIG{'STOP'} = sub {
            $sema->down();      # Thread suspended
            $sema->up();        # Thread resumes
        };

        ...
    }

    # Create a semaphore and pass it to a thread
    my $sema = Thread::Semaphore->new();
    my $thr = threads->create('thr_func', $sema);

    # Suspend the thread
    $sema->down();
    $thr->kill('STOP');

    ...

    # Allow the thread to continue
    $sema->up();

CAVEAT:  The thread signalling capability provided by this module does not
actually send signals via the OS.  It I<emulates> signals at the Perl-level
such that signal handlers are called in the appropriate thread.  For example,
sending C<$thr-E<gt>kill('STOP')> does not actually suspend a thread (or the
whole process), but does cause a C<$SIG{'STOP'}> handler to be called in that
thread (as illustrated above).

As such, signals that would normally not be appropriate to use in the
C<kill()> command (e.g., C<kill('KILL', $$)>) are okay to use with the
C<-E<gt>kill()> method (again, as illustrated above).

Correspondingly, sending a signal to a thread does not disrupt the operation
the thread is currently working on:  The signal will be acted upon after the
current operation has completed.  For instance, if the thread is I<stuck> on
an I/O call, sending it a signal will not cause the I/O call to be interrupted
such that the signal is acted up immediately.

Sending a signal to a terminated/finished thread is ignored.

=head1 WARNINGS

=over 4

=item Perl exited with active threads:

If the program exits without all threads having either been joined or
detached, then this warning will be issued.

NOTE:  If the I<main> thread exits, then this warning cannot be suppressed
using C<no warnings 'threads';> as suggested below.

=item Thread creation failed: pthread_create returned #

See the appropriate I<man> page for C<pthread_create> to determine the actual
cause for the failure.

=item Thread # terminated abnormally: ...

A thread terminated in some manner other than just returning from its entry
point function, or by using C<threads-E<gt>exit()>.  For example, the thread
may have terminated because of an error, or by using C<die>.

=item Using minimum thread stack size of #

Some platforms have a minimum thread stack size.  Trying to set the stack size
below this value will result in the above warning, and the stack size will be
set to the minimum.

=item Thread creation failed: pthread_attr_setstacksize(I<SIZE>) returned 22

The specified I<SIZE> exceeds the system's maximum stack size.  Use a smaller
value for the stack size.

=back

If needed, thread warnings can be suppressed by using:

    no warnings 'threads';

in the appropriate scope.

=head1 ERRORS

=over 4

=item This Perl not built to support threads

The particular copy of Perl that you're trying to use was not built using the
C<useithreads> configuration option.

Having threads support requires all of Perl and all of the XS modules in the
Perl installation to be rebuilt; it is not just a question of adding the
L<threads> module (i.e., threaded and non-threaded Perls are binary
incompatible).

=item Cannot change stack size of an existing thread

The stack size of currently extant threads cannot be changed, therefore, the
following results in the above error:

    $thr->set_stack_size($size);

=item Cannot signal threads without safe signals

Safe signals must be in effect to use the C<-E<gt>kill()> signalling method.
See L</"Unsafe signals"> for more details.

=item Unrecognized signal name: ...

The particular copy of Perl that you're trying to use does not support the
specified signal being used in a C<-E<gt>kill()> call.

=back

=head1 BUGS AND LIMITATIONS

Before you consider posting a bug report, please consult, and possibly post a
message to the discussion forum to see if what you've encountered is a known
problem.

=over

=item Thread-safe modules

See L<perlmod/"Making your module threadsafe"> when creating modules that may
be used in threaded applications, especially if those modules use non-Perl
data, or XS code.

=item Using non-thread-safe modules

Unfortunately, you may encounter Perl modules that are not I<thread-safe>.
For example, they may crash the Perl interpreter during execution, or may dump
core on termination.  Depending on the module and the requirements of your
application, it may be possible to work around such difficulties.

If the module will only be used inside a thread, you can try loading the
module from inside the thread entry point function using C<require> (and
C<import> if needed):

    sub thr_func
    {
        require Unsafe::Module
        # Unsafe::Module->import(...);

        ....
    }

If the module is needed inside the I<main> thread, try modifying your
application so that the module is loaded (again using C<require> and
C<-E<gt>import()>) after any threads are started, and in such a way that no
other threads are started afterwards.

If the above does not work, or is not adequate for your application, then file
a bug report on L<http://rt.cpan.org/Public/> against the problematic module.

=item Memory consumption

On most systems, frequent and continual creation and destruction of threads
can lead to ever-increasing growth in the memory footprint of the Perl
interpreter.  While it is simple to just launch threads and then
C<-E<gt>join()> or C<-E<gt>detach()> them, for long-lived applications, it is
better to maintain a pool of threads, and to reuse them for the work needed,
using L<queues|Thread::Queue> to notify threads of pending work.  The CPAN
distribution of this module contains a simple example
(F<examples/pool_reuse.pl>) illustrating the creation, use and monitoring of a
pool of I<reusable> threads.

=item Current working directory

On all platforms except MSWin32, the setting for the current working directory
is shared among all threads such that changing it in one thread (e.g., using
C<chdir()>) will affect all the threads in the application.

On MSWin32, each thread maintains its own the current working directory
setting.

=item Environment variables

Currently, on all platforms except MSWin32, all I<system> calls (e.g., using
C<system()> or back-ticks) made from threads use the environment variable
settings from the I<main> thread.  In other words, changes made to C<%ENV> in
a thread will not be visible in I<system> calls made by that thread.

To work around this, set environment variables as part of the I<system> call.
For example:

    my $msg = 'hello';
    system("FOO=$msg; echo \$FOO");   # Outputs 'hello' to STDOUT

On MSWin32, each thread maintains its own set of environment variables.

=item Catching signals

Signals are I<caught> by the main thread (thread ID = 0) of a script.
Therefore, setting up signal handlers in threads for purposes other than
L</"THREAD SIGNALLING"> as documented above will not accomplish what is
intended.

This is especially true if trying to catch C<SIGALRM> in a thread.  To handle
alarms in threads, set up a signal handler in the main thread, and then use
L</"THREAD SIGNALLING"> to relay the signal to the thread:

  # Create thread with a task that may time out
  my $thr = threads->create(sub {
      threads->yield();
      eval {
          $SIG{ALRM} = sub { die("Timeout\n"); };
          alarm(10);
          ...  # Do work here
          alarm(0);
      };
      if ($@ =~ /Timeout/) {
          warn("Task in thread timed out\n");
      }
  };

  # Set signal handler to relay SIGALRM to thread
  $SIG{ALRM} = sub { $thr->kill('ALRM') };

  ... # Main thread continues working

=item Parent-child threads

On some platforms, it might not be possible to destroy I<parent> threads while
there are still existing I<child> threads.

=item Creating threads inside special blocks

Creating threads inside C<BEGIN>, C<CHECK> or C<INIT> blocks should not be
relied upon.  Depending on the Perl version and the application code, results
may range from success, to (apparently harmless) warnings of leaked scalar, or
all the way up to crashing of the Perl interpreter.

=item Unsafe signals

Since Perl 5.8.0, signals have been made safer in Perl by postponing their
handling until the interpreter is in a I<safe> state.  See
L<perl58delta/"Safe Signals"> and L<perlipc/"Deferred Signals (Safe Signals)">
for more details.

Safe signals is the default behavior, and the old, immediate, unsafe
signalling behavior is only in effect in the following situations:

=over 4

=item * Perl has been built with C<PERL_OLD_SIGNALS> (see C<perl -V>).

=item * The environment variable C<PERL_SIGNALS> is set to C<unsafe> (see L<perlrun/"PERL_SIGNALS">).

=item * The module L<Perl::Unsafe::Signals> is used.

=back

If unsafe signals is in effect, then signal handling is not thread-safe, and
the C<-E<gt>kill()> signalling method cannot be used.

=item Returning closures from threads

Returning closures from threads should not be relied upon.  Depending on the
Perl version and the application code, results may range from success, to
(apparently harmless) warnings of leaked scalar, or all the way up to crashing
of the Perl interpreter.

=item Returning objects from threads

Returning objects from threads does not work.  Depending on the classes
involved, you may be able to work around this by returning a serialized
version of the object (e.g., using L<Data::Dumper> or L<Storable>), and then
reconstituting it in the joining thread.  If you're using Perl 5.10.0 or
later, and if the class supports L<shared objects|threads::shared/"OBJECTS">,
you can pass them via L<shared queues|Thread::Queue>.

=item END blocks in threads

It is possible to add L<END blocks|perlmod/"BEGIN, UNITCHECK, CHECK, INIT and
END"> to threads by using L<require|perlfunc/"require VERSION"> or
L<eval|perlfunc/"eval EXPR"> with the appropriate code.  These C<END> blocks
will then be executed when the thread's interpreter is destroyed (i.e., either
during a C<-E<gt>join()> call, or at program termination).

However, calling any L<threads> methods in such an C<END> block will most
likely I<fail> (e.g., the application may hang, or generate an error) due to
mutexes that are needed to control functionality within the L<threads> module.

For this reason, the use of C<END> blocks in threads is B<strongly>
discouraged.

=item Open directory handles

In perl 5.14 and higher, on systems other than Windows that do
not support the C<fchdir> C function, directory handles (see
L<opendir|perlfunc/"opendir DIRHANDLE,EXPR">) will not be copied to new
threads. You can use the C<d_fchdir> variable in L<Config.pm|Config> to
determine whether your system supports it.

In prior perl versions, spawning threads with open directory handles would
crash the interpreter.
L<[perl #75154]|http://rt.perl.org/rt3/Public/Bug/Display.html?id=75154>

=item Perl Bugs and the CPAN Version of L<threads>

Support for threads extends beyond the code in this module (i.e.,
F<threads.pm> and F<threads.xs>), and into the Perl interpreter itself.  Older
versions of Perl contain bugs that may manifest themselves despite using the
latest version of L<threads> from CPAN.  There is no workaround for this other
than upgrading to the latest version of Perl.

Even with the latest version of Perl, it is known that certain constructs
with threads may result in warning messages concerning leaked scalars or
unreferenced scalars.  However, such warnings are harmless, and may safely be
ignored.

You can search for L<threads> related bug reports at
L<http://rt.cpan.org/Public/>.  If needed submit any new bugs, problems,
patches, etc. to: L<http://rt.cpan.org/Public/Dist/Display.html?Name=threads>

=back

=head1 REQUIREMENTS

Perl 5.8.0 or later

=head1 SEE ALSO

L<threads> Discussion Forum on CPAN:
L<http://www.cpanforum.com/dist/threads>

L<threads::shared>, L<perlthrtut>

L<http://www.perl.com/pub/a/2002/06/11/threads.html> and
L<http://www.perl.com/pub/a/2002/09/04/threads.html>

Perl threads mailing list:
L<http://lists.perl.org/list/ithreads.html>

Stack size discussion:
L<http://www.perlmonks.org/?node_id=532956>

=head1 AUTHOR

Artur Bergman E<lt>sky AT crucially DOT netE<gt>

CPAN version produced by Jerry D. Hedden <jdhedden AT cpan DOT org>

=head1 LICENSE

threads is released under the same license as Perl.

=head1 ACKNOWLEDGEMENTS

Richard Soderberg E<lt>perl AT crystalflame DOT netE<gt> -
Helping me out tons, trying to find reasons for races and other weird bugs!

Simon Cozens E<lt>simon AT brecon DOT co DOT ukE<gt> -
Being there to answer zillions of annoying questions

Rocco Caputo E<lt>troc AT netrus DOT netE<gt>

Vipul Ved Prakash E<lt>mail AT vipul DOT netE<gt> -
Helping with debugging

Dean Arnold E<lt>darnold AT presicient DOT comE<gt> -
Stack size API

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         package Math::BigInt::FastCalc;

use 5.006;
use strict;
use warnings;

use Math::BigInt::Calc 1.997;

use vars '$VERSION';

$VERSION = '0.31';

##############################################################################
# global constants, flags and accessory

# announce that we are compatible with MBI v1.83 and up
sub api_version () { 2; }

# use Calc to override the methods that we do not provide in XS

for my $method (qw/
    str num
    add sub mul div
    rsft lsft
    mod modpow modinv
    gcd
    pow root sqrt log_int fac nok
    digit check
    from_hex from_bin from_oct as_hex as_bin as_oct
    zeros base_len
    xor or and
    alen 1ex
    /)
    {
    no strict 'refs';
    *{'Math::BigInt::FastCalc::_' . $method} = \&{'Math::BigInt::Calc::_' . $method};
    }

require XSLoader;
XSLoader::load(__PACKAGE__, $VERSION, Math::BigInt::Calc::_base_len());

##############################################################################
##############################################################################

1;
__END__
=pod

=head1 NAME

Math::BigInt::FastCalc - Math::BigInt::Calc with some XS for more speed

=head1 SYNOPSIS

Provides support for big integer calculations. Not intended to be used by
other modules. Other modules which sport the same functions can also be used
to support Math::BigInt, like L<Math::BigInt::GMP> or L<Math::BigInt::Pari>.

=head1 DESCRIPTION

In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use library modules for core math routines. Any module which
follows the same API as this can be used instead by using the following:

	use Math::BigInt lib => 'libname';

'libname' is either the long name ('Math::BigInt::Pari'), or only the short
version like 'Pari'. To use this library:

	use Math::BigInt lib => 'FastCalc';

Note that from L<Math::BigInt> v1.76 onwards, FastCalc will be loaded
automatically, if possible.

=head1 STORAGE

FastCalc works exactly like Calc, in stores the numbers in decimal form,
chopped into parts.

=head1 METHODS

The following functions are now implemented in FastCalc.xs:

	_is_odd		_is_even	_is_one		_is_zero
	_is_two		_is_ten
	_zero		_one		_two		_ten
	_acmp		_len
	_inc		_dec
	__strip_zeros	_copy

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 AUTHORS

Original math code by Mark Biggar, rewritten by Tels L<http://bloodgate.com/>
in late 2000.
Separated from BigInt and shaped API with the help of John Peacock.

Fixed, sped-up and enhanced by Tels http://bloodgate.com 2001-2003.
Further streamlining (api_version 1 etc.) by Tels 2004-2007.

Bug-fixing by Peter John Acklam E<lt>pjacklam@online.noE<gt> 2010-2011.

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>,
L<Math::BigInt::GMP>, L<Math::BigInt::FastCalc> and L<Math::BigInt::Pari>.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_LINUX_IOCTL_H)) {
    eval 'sub _LINUX_IOCTL_H () {1;}' unless defined(&_LINUX_IOCTL_H);
    require 'asm/ioctl.ph';
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_LINUX_POSIX_TYPES_H)) {
    eval 'sub _LINUX_POSIX_TYPES_H () {1;}' unless defined(&_LINUX_POSIX_TYPES_H);
    require 'linux/stddef.ph';
    undef(&__FD_SETSIZE) if defined(&__FD_SETSIZE);
    eval 'sub __FD_SETSIZE () {1024;}' unless defined(&__FD_SETSIZE);
    require 'asm/posix_types.ph';
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           require '_h2ph_pre.ph';

no warnings qw(redefine misc);

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    require '_h2ph_pre.ph';

no warnings qw(redefine misc);

if(defined(&_LIBC)) {
    die("Applications\ may\ not\ define\ the\ macro\ _LIBC");
}
eval 'sub __stub_chflags () {1;}' unless defined(&__stub_chflags);
eval 'sub __stub_create_module () {1;}' unless defined(&__stub_create_module);
eval 'sub __stub_fattach () {1;}' unless defined(&__stub_fattach);
eval 'sub __stub_fchflags () {1;}' unless defined(&__stub_fchflags);
eval 'sub __stub_fdetach () {1;}' unless defined(&__stub_fdetach);
eval 'sub __stub_get_kernel_syms () {1;}' unless defined(&__stub_get_kernel_syms);
eval 'sub __stub_getmsg () {1;}' unless defined(&__stub_getmsg);
eval 'sub __stub_getpmsg () {1;}' unless defined(&__stub_getpmsg);
eval 'sub __stub_gtty () {1;}' unless defined(&__stub_gtty);
eval 'sub __stub_lchmod () {1;}' unless defined(&__stub_lchmod);
eval 'sub __stub_putmsg () {1;}' unless defined(&__stub_putmsg);
eval 'sub __stub_putpmsg () {1;}' unless defined(&__stub_putpmsg);
eval 'sub __stub_query_module () {1;}' unless defined(&__stub_query_module);
eval 'sub __stub_revoke () {1;}' unless defined(&__stub_revoke);
eval 'sub __stub_setlogin () {1;}' unless defined(&__stub_setlogin);
eval 'sub __stub_sigreturn () {1;}' unless defined(&__stub_sigreturn);
eval 'sub __stub_sstk () {1;}' unless defined(&__stub_sstk);
eval 'sub __stub_stty () {1;}' unless defined(&__stub_stty);
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    require '_h2ph_pre.ph';

no warnings qw(redefine misc);

if(!defined (&__ARM_PCS_VFP)) {
    require 'gnu/stubs-soft.ph';
}
if(defined (&__ARM_PCS_VFP)) {
    require 'gnu/stubs-hard.ph';
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               require '_h2ph_pre.ph';

no warnings qw(redefine misc);

if((!defined(&_STDDEF_H)  && !defined(&_STDDEF_H_)  && !defined(&_ANSI_STDDEF_H)  && !defined(&__STDDEF_H__)) || defined(&__need_wchar_t) || defined(&__need_size_t) || defined(&__need_ptrdiff_t) || defined(&__need_NULL) || defined(&__need_wint_t)) {
    if((!defined(&__need_wchar_t)  && !defined(&__need_size_t)  && !defined(&__need_ptrdiff_t)  && !defined(&__need_NULL)  && !defined(&__need_wint_t))) {
	eval 'sub _STDDEF_H () {1;}' unless defined(&_STDDEF_H);
	eval 'sub _STDDEF_H_ () {1;}' unless defined(&_STDDEF_H_);
	eval 'sub _ANSI_STDDEF_H () {1;}' unless defined(&_ANSI_STDDEF_H);
    }
    unless(defined(&__sys_stdtypes_h)) {
	if(defined (&__BSD_NET2__) || defined (&____386BSD____) || (defined (&__FreeBSD__)  && ((defined(&__FreeBSD__) ? &__FreeBSD__ : undef) < 5)) || defined(&__NetBSD__)) {
	    require 'machine/ansi.ph';
	}
	if(defined (&__FreeBSD__)  && ((defined(&__FreeBSD__) ? &__FreeBSD__ : undef) >= 5)) {
	    require 'sys/_types.ph';
	}
	if(defined(&_ANSI_H_) || defined(&_MACHINE_ANSI_H_) || defined(&_X86_64_ANSI_H_) || defined(&_I386_ANSI_H_)) {
	    if(!defined(&_SIZE_T_)  && !defined(&_BSD_SIZE_T_)) {
		eval 'sub _SIZE_T () {1;}' unless defined(&_SIZE_T);
	    }
	    if(!defined(&_PTRDIFF_T_)  && !defined(&_BSD_PTRDIFF_T_)) {
		eval 'sub _PTRDIFF_T () {1;}' unless defined(&_PTRDIFF_T);
	    }
	    if(!defined(&_WCHAR_T_)  && !defined(&_BSD_WCHAR_T_)) {
		unless(defined(&_BSD_WCHAR_T_)) {
		    eval 'sub _WCHAR_T () {1;}' unless defined(&_WCHAR_T);
		}
	    }
	    if(defined (&__need_ptrdiff_t) || defined (&_STDDEF_H_)) {
		undef(&_PTRDIFF_T_) if defined(&_PTRDIFF_T_);
		undef(&_BSD_PTRDIFF_T_) if defined(&_BSD_PTRDIFF_T_);
	    }
	    if(defined (&__need_size_t) || defined (&_STDDEF_H_)) {
		undef(&_SIZE_T_) if defined(&_SIZE_T_);
		undef(&_BSD_SIZE_T_) if defined(&_BSD_SIZE_T_);
	    }
	    if(defined (&__need_wchar_t) || defined (&_STDDEF_H_)) {
		undef(&_WCHAR_T_) if defined(&_WCHAR_T_);
		undef(&_BSD_WCHAR_T_) if defined(&_BSD_WCHAR_T_);
	    }
	}
	if(defined (&__sequent__)  && defined (&_PTRDIFF_T_)) {
	    undef(&_PTRDIFF_T_) if defined(&_PTRDIFF_T_);
	}
	if(defined (&_TYPE_ptrdiff_t)  && (defined (&__need_ptrdiff_t) || defined (&_STDDEF_H_))) {
	    undef(&_TYPE_ptrdiff_t) if defined(&_TYPE_ptrdiff_t);
	}
	if(defined (&_TYPE_size_t)  && (defined (&__need_size_t) || defined (&_STDDEF_H_))) {
	    undef(&_TYPE_size_t) if defined(&_TYPE_size_t);
	}
	if(defined (&_TYPE_wchar_t)  && (defined (&__need_wchar_t) || defined (&_STDDEF_H_))) {
	    undef(&_TYPE_wchar_t) if defined(&_TYPE_wchar_t);
	}
	if(defined (&_STDDEF_H) || defined (&__need_ptrdiff_t)) {
	    unless(defined(&_PTRDIFF_T)) {
		unless(defined(&_T_PTRDIFF_)) {
		    unless(defined(&_T_PTRDIFF)) {
			unless(defined(&__PTRDIFF_T)) {
			    unless(defined(&_PTRDIFF_T_)) {
				unless(defined(&_BSD_PTRDIFF_T_)) {
				    unless(defined(&___int_ptrdiff_t_h)) {
					unless(defined(&_GCC_PTRDIFF_T)) {
					    eval 'sub _PTRDIFF_T () {1;}' unless defined(&_PTRDIFF_T);
					    eval 'sub _T_PTRDIFF_ () {1;}' unless defined(&_T_PTRDIFF_);
					    eval 'sub _T_PTRDIFF () {1;}' unless defined(&_T_PTRDIFF);
					    eval 'sub __PTRDIFF_T () {1;}' unless defined(&__PTRDIFF_T);
					    eval 'sub _PTRDIFF_T_ () {1;}' unless defined(&_PTRDIFF_T_);
					    eval 'sub _BSD_PTRDIFF_T_ () {1;}' unless defined(&_BSD_PTRDIFF_T_);
					    eval 'sub ___int_ptrdiff_t_h () {1;}' unless defined(&___int_ptrdiff_t_h);
					    eval 'sub _GCC_PTRDIFF_T () {1;}' unless defined(&_GCC_PTRDIFF_T);
					    unless(defined(&__PTRDIFF_TYPE__)) {
						eval 'sub __PTRDIFF_TYPE__ () {\'long int\';}' unless defined(&__PTRDIFF_TYPE__);
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	    undef(&__need_ptrdiff_t) if defined(&__need_ptrdiff_t);
	}
	if(defined (&_STDDEF_H) || defined (&__need_size_t)) {
	    unless(defined(&__size_t__)) {
		unless(defined(&__SIZE_T__)) {
		    unless(defined(&_SIZE_T)) {
			unless(defined(&_SYS_SIZE_T_H)) {
			    unless(defined(&_T_SIZE_)) {
				unless(defined(&_T_SIZE)) {
				    unless(defined(&__SIZE_T)) {
					unless(defined(&_SIZE_T_)) {
					    unless(defined(&_BSD_SIZE_T_)) {
						unless(defined(&_SIZE_T_DEFINED_)) {
						    unless(defined(&_SIZE_T_DEFINED)) {
							unless(defined(&_BSD_SIZE_T_DEFINED_)) {
							    unless(defined(&_SIZE_T_DECLARED)) {
								unless(defined(&___int_size_t_h)) {
								    unless(defined(&_GCC_SIZE_T)) {
									unless(defined(&_SIZET_)) {
									    unless(defined(&__size_t)) {
										eval 'sub __size_t__ () {1;}' unless defined(&__size_t__);
										eval 'sub __SIZE_T__ () {1;}' unless defined(&__SIZE_T__);
										eval 'sub _SIZE_T () {1;}' unless defined(&_SIZE_T);
										eval 'sub _SYS_SIZE_T_H () {1;}' unless defined(&_SYS_SIZE_T_H);
										eval 'sub _T_SIZE_ () {1;}' unless defined(&_T_SIZE_);
										eval 'sub _T_SIZE () {1;}' unless defined(&_T_SIZE);
										eval 'sub __SIZE_T () {1;}' unless defined(&__SIZE_T);
										eval 'sub _SIZE_T_ () {1;}' unless defined(&_SIZE_T_);
										eval 'sub _BSD_SIZE_T_ () {1;}' unless defined(&_BSD_SIZE_T_);
										eval 'sub _SIZE_T_DEFINED_ () {1;}' unless defined(&_SIZE_T_DEFINED_);
										eval 'sub _SIZE_T_DEFINED () {1;}' unless defined(&_SIZE_T_DEFINED);
										eval 'sub _BSD_SIZE_T_DEFINED_ () {1;}' unless defined(&_BSD_SIZE_T_DEFINED_);
										eval 'sub _SIZE_T_DECLARED () {1;}' unless defined(&_SIZE_T_DECLARED);
										eval 'sub ___int_size_t_h () {1;}' unless defined(&___int_size_t_h);
										eval 'sub _GCC_SIZE_T () {1;}' unless defined(&_GCC_SIZE_T);
										eval 'sub _SIZET_ () {1;}' unless defined(&_SIZET_);
										if((defined (&__FreeBSD__)  && ((defined(&__FreeBSD__) ? &__FreeBSD__ : undef) >= 5)) || defined(&__FreeBSD_kernel__)) {
										}
 elsif(defined (&__VMS__)) {
										} else {
										    eval 'sub __size_t () {1;}' unless defined(&__size_t);
										}
										unless(defined(&__SIZE_TYPE__)) {
										    eval 'sub __SIZE_TYPE__ () {\'long unsigned int\';}' unless defined(&__SIZE_TYPE__);
										}
										if(!(defined (&__GNUG__)  && defined )) {
										    if(defined(&__BEOS__)) {
										    }
										}
									    }
									}
								    }
								}
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	    undef(&__need_size_t) if defined(&__need_size_t);
	}
	if(defined (&_STDDEF_H) || defined (&__need_wchar_t)) {
	    unless(defined(&__wchar_t__)) {
		unless(defined(&__WCHAR_T__)) {
		    unless(defined(&_WCHAR_T)) {
			unless(defined(&_T_WCHAR_)) {
			    unless(defined(&_T_WCHAR)) {
				unless(defined(&__WCHAR_T)) {
				    unless(defined(&_WCHAR_T_)) {
					unless(defined(&_BSD_WCHAR_T_)) {
					    unless(defined(&_BSD_WCHAR_T_DEFINED_)) {
						unless(defined(&_BSD_RUNE_T_DEFINED_)) {
						    unless(defined(&_WCHAR_T_DECLARED)) {
							unless(defined(&_WCHAR_T_DEFINED_)) {
							    unless(defined(&_WCHAR_T_DEFINED)) {
								unless(defined(&_WCHAR_T_H)) {
								    unless(defined(&___int_wchar_t_h)) {
									unless(defined(&__INT_WCHAR_T_H)) {
									    unless(defined(&_GCC_WCHAR_T)) {
										eval 'sub __wchar_t__ () {1;}' unless defined(&__wchar_t__);
										eval 'sub __WCHAR_T__ () {1;}' unless defined(&__WCHAR_T__);
										eval 'sub _WCHAR_T () {1;}' unless defined(&_WCHAR_T);
										eval 'sub _T_WCHAR_ () {1;}' unless defined(&_T_WCHAR_);
										eval 'sub _T_WCHAR () {1;}' unless defined(&_T_WCHAR);
										eval 'sub __WCHAR_T () {1;}' unless defined(&__WCHAR_T);
										eval 'sub _WCHAR_T_ () {1;}' unless defined(&_WCHAR_T_);
										eval 'sub _BSD_WCHAR_T_ () {1;}' unless defined(&_BSD_WCHAR_T_);
										eval 'sub _WCHAR_T_DEFINED_ () {1;}' unless defined(&_WCHAR_T_DEFINED_);
										eval 'sub _WCHAR_T_DEFINED () {1;}' unless defined(&_WCHAR_T_DEFINED);
										eval 'sub _WCHAR_T_H () {1;}' unless defined(&_WCHAR_T_H);
										eval 'sub ___int_wchar_t_h () {1;}' unless defined(&___int_wchar_t_h);
										eval 'sub __INT_WCHAR_T_H () {1;}' unless defined(&__INT_WCHAR_T_H);
										eval 'sub _GCC_WCHAR_T () {1;}' unless defined(&_GCC_WCHAR_T);
										eval 'sub _WCHAR_T_DECLARED () {1;}' unless defined(&_WCHAR_T_DECLARED);
										if(defined(&_BSD_WCHAR_T_)) {
										    undef(&_BSD_WCHAR_T_) if defined(&_BSD_WCHAR_T_);
										    if(defined(&_BSD_RUNE_T_)) {
											if(!defined (&_ANSI_SOURCE)  && !defined (&_POSIX_SOURCE)) {
											    eval 'sub _BSD_WCHAR_T_DEFINED_ () {1;}' unless defined(&_BSD_WCHAR_T_DEFINED_);
											    eval 'sub _BSD_RUNE_T_DEFINED_ () {1;}' unless defined(&_BSD_RUNE_T_DEFINED_);
											    if(defined (&__FreeBSD__)  && ((defined(&__FreeBSD__) ? &__FreeBSD__ : undef) < 5)) {
												undef(&_BSD_RUNE_T_) if defined(&_BSD_RUNE_T_);
											    }
											}
										    }
										}
										if(defined (&__FreeBSD__)  && ((defined(&__FreeBSD__) ? &__FreeBSD__ : undef) >= 5)) {
										    if(!defined (&_ANSI_SOURCE)  && !defined (&_POSIX_SOURCE)) {
											if((defined(&__BSD_VISIBLE) ? &__BSD_VISIBLE : undef)) {
											    unless(defined(&_RUNE_T_DECLARED)) {
												eval 'sub _RUNE_T_DECLARED () {1;}' unless defined(&_RUNE_T_DECLARED);
											    }
											}
										    }
										}
										unless(defined(&__WCHAR_TYPE__)) {
										    eval 'sub __WCHAR_TYPE__ () {\'int\';}' unless defined(&__WCHAR_TYPE__);
										}
										unless(defined(&__cplusplus)) {
										}
									    }
									}
								    }
								}
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	    undef(&__need_wchar_t) if defined(&__need_wchar_t);
	}
	if(defined (&__need_wint_t)) {
	    unless(defined(&_WINT_T)) {
		eval 'sub _WINT_T () {1;}' unless defined(&_WINT_T);
		unless(defined(&__WINT_TYPE__)) {
		    eval 'sub __WINT_TYPE__ () {\'unsigned int\';}' unless defined(&__WINT_TYPE__);
		}
	    }
	    undef(&__need_wint_t) if defined(&__need_wint_t);
	}
	if(defined(&_ANSI_H_) || defined(&_MACHINE_ANSI_H_) || defined(&_X86_64_ANSI_H_) || defined(&_I386_ANSI_H_)) {
	    if(defined(&_GCC_PTRDIFF_T_)) {
		undef(&_PTRDIFF_T_) if defined(&_PTRDIFF_T_);
		undef(&_BSD_PTRDIFF_T_) if defined(&_BSD_PTRDIFF_T_);
	    }
	    if(defined(&_GCC_SIZE_T_)) {
		undef(&_SIZE_T_) if defined(&_SIZE_T_);
		undef(&_BSD_SIZE_T_) if defined(&_BSD_SIZE_T_);
	    }
	    if(defined(&_GCC_WCHAR_T_)) {
		undef(&_WCHAR_T_) if defined(&_WCHAR_T_);
		undef(&_BSD_WCHAR_T_) if defined(&_BSD_WCHAR_T_);
	    }
	    if(defined(&_GCC_PTRDIFF_T)) {
		undef(&_PTRDIFF_T_) if defined(&_PTRDIFF_T_);
		undef(&_BSD_PTRDIFF_T_) if defined(&_BSD_PTRDIFF_T_);
	    }
	    if(defined(&_GCC_SIZE_T)) {
		undef(&_SIZE_T_) if defined(&_SIZE_T_);
		undef(&_BSD_SIZE_T_) if defined(&_BSD_SIZE_T_);
	    }
	    if(defined(&_GCC_WCHAR_T)) {
		undef(&_WCHAR_T_) if defined(&_WCHAR_T_);
		undef(&_BSD_WCHAR_T_) if defined(&_BSD_WCHAR_T_);
	    }
	}
    }
    if(defined (&_STDDEF_H) || defined (&__need_NULL)) {
	undef(&NULL) if defined(&NULL);
	if(defined(&__GNUG__)) {
	    eval 'sub NULL () { &__null;}' unless defined(&NULL);
	} else {
	    unless(defined(&__cplusplus)) {
		eval 'sub NULL () {(( &void *)0);}' unless defined(&NULL);
	    } else {
		eval 'sub NULL () {0;}' unless defined(&NULL);
	    }
	}
    }
    undef(&__need_NULL) if defined(&__need_NULL);
    if(defined(&_STDDEF_H)) {
	eval 'sub offsetof {
	    my($TYPE, $MEMBER) = @_;
    	    eval q( &__builtin_offsetof ($TYPE, $MEMBER));
	}' unless defined(&offsetof);
	if((defined (&__STDC_VERSION__)  && (defined(&__STDC_VERSION__) ? &__STDC_VERSION__ : undef) >= 201112) || (defined(&__cplusplus)  && (defined(&__cplusplus) ? &__cplusplus : undef) >= 201103)) {
	    unless(defined(&_GCC_MAX_ALIGN_T)) {
		eval 'sub _GCC_MAX_ALIGN_T () {1;}' unless defined(&_GCC_MAX_ALIGN_T);
	    }
	}
	if(defined(&__cplusplus)  && (defined(&__cplusplus) ? &__cplusplus : undef) >= 201103) {
	    unless(defined(&_GXX_NULLPTR_T)) {
		eval 'sub _GXX_NULLPTR_T () {1;}' unless defined(&_GXX_NULLPTR_T);
	    }
	}
    }
}
1;
                                                                                           package NDBM_File;

use strict;
use warnings;

require Tie::Hash;
require XSLoader;

our @ISA = qw(Tie::Hash);
our $VERSION = "1.12";

XSLoader::load();

1;

__END__

=head1 NAME

NDBM_File - Tied access to ndbm files

=head1 SYNOPSIS

  use Fcntl;   # For O_RDWR, O_CREAT, etc.
  use NDBM_File;

  tie(%h, 'NDBM_File', 'filename', O_RDWR|O_CREAT, 0666)
    or die "Couldn't tie NDBM file 'filename': $!; aborting";

  # Now read and change the hash
  $h{newkey} = newvalue;
  print $h{oldkey};
  ...

  untie %h;

=head1 DESCRIPTION

C<NDBM_File> establishes a connection between a Perl hash variable and
a file in NDBM_File format;.  You can manipulate the data in the file
just as if it were in a Perl hash, but when your program exits, the
data will remain in the file, to be used the next time your program
runs.

Use C<NDBM_File> with the Perl built-in C<tie> function to establish
the connection between the variable and the file.  The arguments to
C<tie> should be:

=over 4

=item 1.

The hash variable you want to tie.

=item 2.

The string C<"NDBM_File">.  (Ths tells Perl to use the C<NDBM_File>
package to perform the functions of the hash.)

=item 3.

The name of the file you want to tie to the hash.

=item 4.

Flags.  Use one of:

=over 2

=item C<O_RDONLY>

Read-only access to the data in the file.

=item C<O_WRONLY>

Write-only access to the data in the file.

=item C<O_RDWR>

Both read and write access.

=back

If you want to create the file if it does not exist, add C<O_CREAT> to
any of these, as in the example.  If you omit C<O_CREAT> and the file
does not already exist, the C<tie> call will fail.

=item 5.

The default permissions to use if a new file is created.  The actual
permissions will be modified by the user's umask, so you should
probably use 0666 here. (See L<perlfunc/umask>.)

=back

=head1 DIAGNOSTICS

On failure, the C<tie> call returns an undefined value and probably
sets C<$!> to contain the reason the file could not be tied.

=head2 C<ndbm store returned -1, errno 22, key "..." at ...>

This warning is emitted when you try to store a key or a value that
is too long.  It means that the change was not recorded in the
database.  See BUGS AND WARNINGS below.

=head1 BUGS AND WARNINGS

There are a number of limits on the size of the data that you can
store in the NDBM file.  The most important is that the length of a
key, plus the length of its associated value, may not exceed 1008
bytes.

See L<perlfunc/tie>, L<perldbmfilter>, L<Fcntl>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            package MIME::Base64;

use strict;
use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(encode_base64 decode_base64);
@EXPORT_OK = qw(encode_base64url decode_base64url encoded_base64_length decoded_base64_length);

$VERSION = '3.14';

require XSLoader;
XSLoader::load('MIME::Base64', $VERSION);

*encode = \&encode_base64;
*decode = \&decode_base64;

sub encode_base64url {
    my $e = encode_base64(shift, "");
    $e =~ s/=+\z//;
    $e =~ tr[+/][-_];
    return $e;
}

sub decode_base64url {
    my $s = shift;
    $s =~ tr[-_][+/];
    $s .= '=' while length($s) % 4;
    return decode_base64($s);
}

1;

__END__

=head1 NAME

MIME::Base64 - Encoding and decoding of base64 strings

=head1 SYNOPSIS

 use MIME::Base64;

 $encoded = encode_base64('Aladdin:open sesame');
 $decoded = decode_base64($encoded);

=head1 DESCRIPTION

This module provides functions to encode and decode strings into and from the
base64 encoding specified in RFC 2045 - I<MIME (Multipurpose Internet
Mail Extensions)>. The base64 encoding is designed to represent
arbitrary sequences of octets in a form that need not be humanly
readable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used,
enabling 6 bits to be represented per printable character.

The following primary functions are provided:

=over 4

=item encode_base64( $bytes )

=item encode_base64( $bytes, $eol );

Encode data by calling the encode_base64() function.  The first
argument is the byte string to encode.  The second argument is the
line-ending sequence to use.  It is optional and defaults to "\n".  The
returned encoded string is broken into lines of no more than 76
characters each and it will end with $eol unless it is empty.  Pass an
empty string as second argument if you do not want the encoded string
to be broken into lines.

The function will croak with "Wide character in subroutine entry" if $bytes
contains characters with code above 255.  The base64 encoding is only defined
for single-byte characters.  Use the Encode module to select the byte encoding
you want.

=item decode_base64( $str )

Decode a base64 string by calling the decode_base64() function.  This
function takes a single argument which is the string to decode and
returns the decoded data.

Any character not part of the 65-character base64 subset is
silently ignored.  Characters occurring after a '=' padding character
are never decoded.

=back

If you prefer not to import these routines into your namespace, you can
call them as:

    use MIME::Base64 ();
    $encoded = MIME::Base64::encode($decoded);
    $decoded = MIME::Base64::decode($encoded);

Additional functions not exported by default:

=over 4

=item encode_base64url( $bytes )

=item decode_base64url( $str )

Encode and decode according to the base64 scheme for "URL applications" [1].
This is a variant of the base64 encoding which does not use padding, does not
break the string into multiple lines and use the characters "-" and "_" instead
of "+" and "/" to avoid using reserved URL characters.

=item encoded_base64_length( $bytes )

=item encoded_base64_length( $bytes, $eol )

Returns the length that the encoded string would have without actually
encoding it.  This will return the same value as C<< length(encode_base64($bytes)) >>,
but should be more efficient.

=item decoded_base64_length( $str )

Returns the length that the decoded string would have without actually
decoding it.  This will return the same value as C<< length(decode_base64($str)) >>,
but should be more efficient.

=back

=head1 EXAMPLES

If you want to encode a large file, you should encode it in chunks
that are a multiple of 57 bytes.  This ensures that the base64 lines
line up and that you do not end up with padding in the middle. 57
bytes of data fills one complete base64 line (76 == 57*4/3):

   use MIME::Base64 qw(encode_base64);

   open(FILE, "/var/log/wtmp") or die "$!";
   while (read(FILE, $buf, 60*57)) {
       print encode_base64($buf);
   }

or if you know you have enough memory

   use MIME::Base64 qw(encode_base64);
   local($/) = undef;  # slurp
   print encode_base64(<STDIN>);

The same approach as a command line:

   perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' <file

Decoding does not need slurp mode if every line contains a multiple
of four base64 chars:

   perl -MMIME::Base64 -ne 'print decode_base64($_)' <file

Perl v5.8 and better allow extended Unicode characters in strings.
Such strings cannot be encoded directly, as the base64
encoding is only defined for single-byte characters.  The solution is
to use the Encode module to select the byte encoding you want.  For
example:

    use MIME::Base64 qw(encode_base64);
    use Encode qw(encode);

    $encoded = encode_base64(encode("UTF-8", "\x{FFFF}\n"));
    print $encoded;

=head1 COPYRIGHT

Copyright 1995-1999, 2001-2004, 2010 Gisle Aas.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

Distantly based on LWP::Base64 written by Martijn Koster
<m.koster@nexor.co.uk> and Joerg Reichelt <j.reichelt@nexor.co.uk> and
code posted to comp.lang.perl <3pd2lp$6gf@wsinti07.win.tue.nl> by Hans
Mulder <hansm@wsinti07.win.tue.nl>

The XS implementation uses code from metamail.  Copyright 1991 Bell
Communications Research, Inc. (Bellcore)

=head1 SEE ALSO

L<MIME::QuotedPrint>

[1] L<http://en.wikipedia.org/wiki/Base64#URL_applications>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package MIME::QuotedPrint;

use strict;
use vars qw(@ISA @EXPORT $VERSION);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(encode_qp decode_qp);

$VERSION = "3.13";

use MIME::Base64;  # will load XS version of {en,de}code_qp()

*encode = \&encode_qp;
*decode = \&decode_qp;

1;

__END__

=head1 NAME

MIME::QuotedPrint - Encoding and decoding of quoted-printable strings

=head1 SYNOPSIS

 use MIME::QuotedPrint;

 $encoded = encode_qp($decoded);
 $decoded = decode_qp($encoded);

=head1 DESCRIPTION

This module provides functions to encode and decode strings into and from the
quoted-printable encoding specified in RFC 2045 - I<MIME (Multipurpose
Internet Mail Extensions)>.  The quoted-printable encoding is intended
to represent data that largely consists of bytes that correspond to
printable characters in the ASCII character set.  Each non-printable
character (as defined by English Americans) is represented by a
triplet consisting of the character "=" followed by two hexadecimal
digits.

The following functions are provided:

=over 4

=item encode_qp( $str)

=item encode_qp( $str, $eol)

=item encode_qp( $str, $eol, $binmode )

This function returns an encoded version of the string ($str) given as
argument.

The second argument ($eol) is the line-ending sequence to use.  It is
optional and defaults to "\n".  Every occurrence of "\n" is replaced
with this string, and it is also used for additional "soft line
breaks" to ensure that no line end up longer than 76 characters.  Pass
it as "\015\012" to produce data suitable for external consumption.
The string "\r\n" produces the same result on many platforms, but not
all.

The third argument ($binmode) will select binary mode if passed as a
TRUE value.  In binary mode "\n" will be encoded in the same way as
any other non-printable character.  This ensures that a decoder will
end up with exactly the same string whatever line ending sequence it
uses.  In general it is preferable to use the base64 encoding for
binary data; see L<MIME::Base64>.

An $eol of "" (the empty string) is special.  In this case, no "soft
line breaks" are introduced and binary mode is effectively enabled so
that any "\n" in the original data is encoded as well.

=item decode_qp( $str )

This function returns the plain text version of the string given
as argument.  The lines of the result are "\n" terminated, even if
the $str argument contains "\r\n" terminated lines.

=back


If you prefer not to import these routines into your namespace, you can
call them as:

  use MIME::QuotedPrint ();
  $encoded = MIME::QuotedPrint::encode($decoded);
  $decoded = MIME::QuotedPrint::decode($encoded);

Perl v5.8 and better allow extended Unicode characters in strings.
Such strings cannot be encoded directly, as the quoted-printable
encoding is only defined for single-byte characters.  The solution is
to use the Encode module to select the byte encoding you want.  For
example:

    use MIME::QuotedPrint qw(encode_qp);
    use Encode qw(encode);

    $encoded = encode_qp(encode("UTF-8", "\x{FFFF}\n"));
    print $encoded;

=head1 COPYRIGHT

Copyright 1995-1997,2002-2004 Gisle Aas.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

L<MIME::Base64>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      require '_h2ph_pre.ph';

no warnings qw(redefine misc);

eval 'sub _GCC_NEXT_LIMITS_H () {1;}' unless defined(&_GCC_NEXT_LIMITS_H);
eval {
    my(@REM);
    my(%INCD) = map { $INC{$_} => 1 } (grep { $_ eq "limits.ph" } keys(%INC));
    @REM = map { "$_/limits.ph" } (grep { not exists($INCD{"$_/limits.ph"}) and -f "$_/limits.ph" } @INC);
    require "$REM[0]" if @REM;
};
warn($@) if $@;
undef(&_GCC_NEXT_LIMITS_H) if defined(&_GCC_NEXT_LIMITS_H);
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            require '_h2ph_pre.ph';

no warnings qw(redefine misc);

require 'sys/syscall.ph';
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # Devel::Peek - A data debugging tool for the XS programmer
# The documentation is after the __END__

package Devel::Peek;

$VERSION = '1.16';
$XS_VERSION = $VERSION;
$VERSION = eval $VERSION;

require Exporter;
require XSLoader;

@ISA = qw(Exporter);
@EXPORT = qw(Dump mstat DeadCode DumpArray DumpWithOP DumpProg
	     fill_mstats mstats_fillhash mstats2hash runops_debug debug_flags);
@EXPORT_OK = qw(SvREFCNT CvGV);
%EXPORT_TAGS = ('ALL' => [@EXPORT, @EXPORT_OK]);

XSLoader::load();

sub import {
  my $c = shift;
  my $ops_rx = qr/^:opd(=[stP]*)?\b/;
  my @db = grep m/$ops_rx/, @_;
  @_ = grep !m/$ops_rx/, @_;
  if (@db) {
    die "Too many :opd options" if @db > 1;
    runops_debug(1);
    my $flags = ($db[0] =~ m/$ops_rx/ and $1);
    $flags = 'st' unless defined $flags;
    my $f = 0;
    $f |= 2  if $flags =~ /s/;
    $f |= 8  if $flags =~ /t/;
    $f |= 64 if $flags =~ /P/;
    $^D |= $f if $f;
  }
  unshift @_, $c;
  goto &Exporter::import;
}

sub DumpWithOP ($;$) {
   local($Devel::Peek::dump_ops)=1;
   my $depth = @_ > 1 ? $_[1] : 4 ;
   Dump($_[0],$depth);
}

$D_flags = 'psltocPmfrxuLHXDSTR';

sub debug_flags (;$) {
  my $out = "";
  for my $i (0 .. length($D_flags)-1) {
    $out .= substr $D_flags, $i, 1 if $^D & (1<<$i);
  }
  my $arg = shift;
  my $num = $arg;
  if (defined $arg and $arg =~ /\D/) {
    die "unknown flags in debug_flags()" if $arg =~ /[^-$D_flags]/;
    my ($on,$off) = split /-/, "$arg-";
    $num = $^D;
    $num |=  (1<<index($D_flags, $_)) for split //, $on;
    $num &= ~(1<<index($D_flags, $_)) for split //, $off;
  }
  $^D = $num if defined $arg;
  $out
}

1;
__END__

=head1 NAME

Devel::Peek - A data debugging tool for the XS programmer

=head1 SYNOPSIS

        use Devel::Peek;
        Dump( $a );
        Dump( $a, 5 );
        Dump( @a );
        Dump( %h );
        DumpArray( 5, $a, $b, ... );
	mstat "Point 5";

        use Devel::Peek ':opd=st';

=head1 DESCRIPTION

Devel::Peek contains functions which allows raw Perl datatypes to be
manipulated from a Perl script.  This is used by those who do XS programming
to check that the data they are sending from C to Perl looks as they think
it should look.  The trick, then, is to know what the raw datatype is
supposed to look like when it gets to Perl.  This document offers some tips
and hints to describe good and bad raw data.

It is very possible that this document will fall far short of being useful
to the casual reader.  The reader is expected to understand the material in
the first few sections of L<perlguts>.

Devel::Peek supplies a C<Dump()> function which can dump a raw Perl
datatype, and C<mstat("marker")> function to report on memory usage
(if perl is compiled with corresponding option).  The function
DeadCode() provides statistics on the data "frozen" into inactive
C<CV>.  Devel::Peek also supplies C<SvREFCNT()> which can query reference
counts on SVs.  This document will take a passive, and safe, approach
to data debugging and for that it will describe only the C<Dump()>
function.

The C<Dump()> function takes one or two arguments: something to dump, and
an optional limit for recursion and array elements (default is 4).  The
first argument is evaluted in rvalue scalar context, with exceptions for
@array and %hash, which dump the array or hash itself.  So C<Dump @array>
works, as does C<Dump $foo>.  And C<Dump pos> will call C<pos> in rvalue
context, whereas C<Dump ${\pos}> will call it in lvalue context.

Function C<DumpArray()> allows dumping of multiple values (useful when you
need to analyze returns of functions).

The global variable $Devel::Peek::pv_limit can be set to limit the
number of character printed in various string values.  Setting it to 0
means no limit.

If C<use Devel::Peek> directive has a C<:opd=FLAGS> argument,
this switches on debugging of opcode dispatch.  C<FLAGS> should be a
combination of C<s>, C<t>, and C<P> (see B<-D> flags in L<perlrun>).
C<:opd> is a shortcut for C<:opd=st>.

=head2 Runtime debugging

C<CvGV($cv)> return one of the globs associated to a subroutine reference $cv.

debug_flags() returns a string representation of C<$^D> (similar to
what is allowed for B<-D> flag).  When called with a numeric argument,
sets $^D to the corresponding value.  When called with an argument of
the form C<"flags-flags">, set on/off bits of C<$^D> corresponding to
letters before/after C<->.  (The returned value is for C<$^D> before
the modification.)

runops_debug() returns true if the current I<opcode dispatcher> is the
debugging one.  When called with an argument, switches to debugging or
non-debugging dispatcher depending on the argument (active for
newly-entered subs/etc only).  (The returned value is for the dispatcher before the modification.)

=head2 Memory footprint debugging

When perl is compiled with support for memory footprint debugging
(default with Perl's malloc()), Devel::Peek provides an access to this API.

Use mstat() function to emit a memory state statistic to the terminal.
For more information on the format of output of mstat() see
L<perldebguts/Using $ENV{PERL_DEBUG_MSTATS}>.

Three additional functions allow access to this statistic from Perl.
First, use C<mstats_fillhash(%hash)> to get the information contained
in the output of mstat() into %hash. The field of this hash are

  minbucket nbuckets sbrk_good sbrk_slack sbrked_remains sbrks
  start_slack topbucket topbucket_ev topbucket_odd total total_chain
  total_sbrk totfree

Two additional fields C<free>, C<used> contain array references which
provide per-bucket count of free and used chunks.  Two other fields
C<mem_size>, C<available_size> contain array references which provide
the information about the allocated size and usable size of chunks in
each bucket.  Again, see L<perldebguts/Using $ENV{PERL_DEBUG_MSTATS}>
for details.


Keep in mind that only the first several "odd-numbered" buckets are
used, so the information on size of the "odd-numbered" buckets which are
not used is probably meaningless.

The information in

 mem_size available_size minbucket nbuckets

is the property of a particular build of perl, and does not depend on
the current process.  If you do not provide the optional argument to
the functions mstats_fillhash(), fill_mstats(), mstats2hash(), then
the information in fields C<mem_size>, C<available_size> is not
updated.

C<fill_mstats($buf)> is a much cheaper call (both speedwise and
memory-wise) which collects the statistic into $buf in
machine-readable form.  At a later moment you may need to call
C<mstats2hash($buf, %hash)> to use this information to fill %hash.

All three APIs C<fill_mstats($buf)>, C<mstats_fillhash(%hash)>, and
C<mstats2hash($buf, %hash)> are designed to allocate no memory if used
I<the second time> on the same $buf and/or %hash.

So, if you want to collect memory info in a cycle, you may call

  $#buf = 999;
  fill_mstats($_) for @buf;
  mstats_fillhash(%report, 1);		# Static info too

  foreach (@buf) {
    # Do something...
    fill_mstats $_;			# Collect statistic
  }
  foreach (@buf) {
    mstats2hash($_, %report);		# Preserve static info
    # Do something with %report
  }

=head1 EXAMPLES

The following examples don't attempt to show everything as that would be a
monumental task, and, frankly, we don't want this manpage to be an internals
document for Perl.  The examples do demonstrate some basics of the raw Perl
datatypes, and should suffice to get most determined people on their way.
There are no guidewires or safety nets, nor blazed trails, so be prepared to
travel alone from this point and on and, if at all possible, don't fall into
the quicksand (it's bad for business).

Oh, one final bit of advice: take L<perlguts> with you.  When you return we
expect to see it well-thumbed.

=head2 A simple scalar string

Let's begin by looking a simple scalar which is holding a string.

        use Devel::Peek;
        $a = 42; $a = "hello";
        Dump $a;

The output:

        SV = PVIV(0xbc288) at 0xbe9a8
          REFCNT = 1
          FLAGS = (POK,pPOK)
          IV = 42
          PV = 0xb2048 "hello"\0
          CUR = 5
          LEN = 8

This says C<$a> is an SV, a scalar.  The scalar type is a PVIV, which is
capable of holding an integer (IV) and/or a string (PV) value. The scalar's
head is allocated at address 0xbe9a8, while the body is at 0xbc288.
Its reference count is 1.  It has the C<POK> flag set, meaning its
current PV field is valid.  Because POK is set we look at the PV item
to see what is in the scalar.  The \0 at the end indicate that this
PV is properly NUL-terminated.
Note that the IV field still contains its old numeric value, but because
FLAGS doesn't have IOK set, we must ignore the IV item.
CUR indicates the number of characters in the PV.  LEN indicates the
number of bytes allocated for the PV (at least one more than CUR, because
LEN includes an extra byte for the end-of-string marker, then usually
rounded up to some efficient allocation unit).

=head2 A simple scalar number

If the scalar contains a number the raw SV will be leaner.

        use Devel::Peek;
        $a = 42;
        Dump $a;

The output:

        SV = IV(0xbc818) at 0xbe9a8
          REFCNT = 1
          FLAGS = (IOK,pIOK)
          IV = 42

This says C<$a> is an SV, a scalar.  The scalar is an IV, a number.  Its
reference count is 1.  It has the C<IOK> flag set, meaning it is currently
being evaluated as a number.  Because IOK is set we look at the IV item to
see what is in the scalar.

=head2 A simple scalar with an extra reference

If the scalar from the previous example had an extra reference:

        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $a;

The output:

        SV = IV(0xbe860) at 0xbe9a8
          REFCNT = 2
          FLAGS = (IOK,pIOK)
          IV = 42

Notice that this example differs from the previous example only in its
reference count.  Compare this to the next example, where we dump C<$b>
instead of C<$a>.

=head2 A reference to a simple scalar

This shows what a reference looks like when it references a simple scalar.

        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $b;

The output:

        SV = IV(0xf041c) at 0xbe9a0
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xbab08
          SV = IV(0xbe860) at 0xbe9a8
            REFCNT = 2
            FLAGS = (IOK,pIOK)
            IV = 42

Starting from the top, this says C<$b> is an SV.  The scalar is an IV,
which is capable of holding an integer or reference value.
It has the C<ROK> flag set, meaning it is a reference (rather than an
integer or string).  Notice that Dump
follows the reference and shows us what C<$b> was referencing.  We see the
same C<$a> that we found in the previous example.

Note that the value of C<RV> coincides with the numbers we see when we
stringify $b. The addresses inside IV() are addresses of
C<X***> structures which hold the current state of an C<SV>. This
address may change during lifetime of an SV.

=head2 A reference to an array

This shows what a reference to an array looks like.

        use Devel::Peek;
        $a = [42];
        Dump $a;

The output:

        SV = IV(0xc85998) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xc70de8
          SV = PVAV(0xc71e10) at 0xc70de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0xc7e820
            FILL = 0
            MAX = 0
            ARYLEN = 0x0
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0xc70f88) at 0xc70f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42

This says C<$a> is a reference (ROK), which points to
another SV which is a PVAV, an array.  The array has one element,
element zero, which is another SV. The field C<FILL> above indicates
the last element in the array, similar to C<$#$a>.

If C<$a> pointed to an array of two elements then we would see the
following.

        use Devel::Peek 'Dump';
        $a = [42,24];
        Dump $a;

The output:

        SV = IV(0x158c998) at 0x158c9a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0x1577de8
          SV = PVAV(0x1578e10) at 0x1577de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0x1585820
            FILL = 1
            MAX = 1
            ARYLEN = 0x0
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0x1577f88) at 0x1577f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42
            Elt No. 1
            SV = IV(0x158be88) at 0x158be98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 24

Note that C<Dump> will not report I<all> the elements in the array,
only several first (depending on how deep it already went into the
report tree).

=head2 A reference to a hash

The following shows the raw form of a reference to a hash.

        use Devel::Peek;
        $a = {hello=>42};
        Dump $a;

The output:

	SV = IV(0x8177858) at 0x816a618
	  REFCNT = 1
	  FLAGS = (ROK)
	  RV = 0x814fc10
	  SV = PVHV(0x8167768) at 0x814fc10
	    REFCNT = 1
	    FLAGS = (SHAREKEYS)
	    ARRAY = 0x816c5b8  (0:7, 1:1)
	    hash quality = 100.0%
	    KEYS = 1
	    FILL = 1
	    MAX = 7
	    RITER = -1
	    EITER = 0x0
	    Elt "hello" HASH = 0xc8fd181b
	    SV = IV(0x816c030) at 0x814fcf4
	      REFCNT = 1
	      FLAGS = (IOK,pIOK)
	      IV = 42

This shows C<$a> is a reference pointing to an SV.  That SV is a PVHV, a
hash. Fields RITER and EITER are used by C<L<perlfunc/each>>.

The "quality" of a hash is defined as the total number of comparisons needed
to access every element once, relative to the expected number needed for a
random hash. The value can go over 100%.

The total number of comparisons is equal to the sum of the squares of the
number of entries in each bucket.  For a random hash of C<<n>> keys into
C<<k>> buckets, the expected value is:

		n + n(n-1)/2k

=head2 Dumping a large array or hash

The C<Dump()> function, by default, dumps up to 4 elements from a
toplevel array or hash.  This number can be increased by supplying a
second argument to the function.

        use Devel::Peek;
        $a = [10,11,12,13,14];
        Dump $a;

Notice that C<Dump()> prints only elements 10 through 13 in the above code.
The following code will print all of the elements.

        use Devel::Peek 'Dump';
        $a = [10,11,12,13,14];
        Dump $a, 5;

=head2 A reference to an SV which holds a C pointer

This is what you really need to know as an XS programmer, of course.  When
an XSUB returns a pointer to a C structure that pointer is stored in an SV
and a reference to that SV is placed on the XSUB stack.  So the output from
an XSUB which uses something like the T_PTROBJ map might look something like
this:

        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (OBJECT,IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0
            STASH = 0xc1d10       "CookBookB::Opaque"

This shows that we have an SV which is a reference, which points at another
SV.  In this case that second SV is a PVMG, a blessed scalar.  Because it is
blessed it has the C<OBJECT> flag set.  Note that an SV which holds a C
pointer also has the C<IOK> flag set.  The C<STASH> is set to the package
name which this SV was blessed into.

The output from an XSUB which uses something like the T_PTRREF map, which
doesn't bless the object, might look something like this:

        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0

=head2 A reference to a subroutine

Looks like this:

	SV = IV(0x24d2dd8) at 0x24d2de8
	  REFCNT = 1
	  FLAGS = (TEMP,ROK)
	  RV = 0x24e79d8
	  SV = PVCV(0x24e5798) at 0x24e79d8
	    REFCNT = 2
	    FLAGS = ()
	    COMP_STASH = 0x22c9c50	"main"
	    START = 0x22eed60 ===> 0
	    ROOT = 0x22ee490
	    GVGV::GV = 0x22de9d8	"MY" :: "top_targets"
	    FILE = "(eval 5)"
	    DEPTH = 0
	    FLAGS = 0x0
	    OUTSIDE_SEQ = 93
	    PADLIST = 0x22e9ed8
	    PADNAME = 0x22e9ec0(0x22eed00) PAD = 0x22e9ea8(0x22eecd0)
	    OUTSIDE = 0x22c9fb0 (MAIN)


This shows that 

=over 4

=item *

the subroutine is not an XSUB (since C<START> and C<ROOT> are
non-zero, and C<XSUB> is not listed, and is thus null);

=item *

that it was compiled in the package C<main>;

=item *

under the name C<MY::top_targets>; 

=item *

inside a 5th eval in the program;

=item *

it is not currently executed (see C<DEPTH>);

=item *

it has no prototype (C<PROTOTYPE> field is missing).

=back

=head1 EXPORTS

C<Dump>, C<mstat>, C<DeadCode>, C<DumpArray>, C<DumpWithOP> and
C<DumpProg>, C<fill_mstats>, C<mstats_fillhash>, C<mstats2hash> by
default. Additionally available C<SvREFCNT>, C<SvREFCNT_inc> and
C<SvREFCNT_dec>.

=head1 BUGS

Readers have been known to skip important parts of L<perlguts>, causing much
frustration for all.

=head1 AUTHOR

Ilya Zakharevich	ilya@math.ohio-state.edu

Copyright (c) 1995-98 Ilya Zakharevich. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

Author of this software makes no claim whatsoever about suitability,
reliability, edability, editability or usability of this product, and
should not be kept liable for any damage resulting from the use of
it. If you can use it, you are in luck, if not, I should not be kept
responsible. Keep a handy copy of your backup tape at hand.

=head1 SEE ALSO

L<perlguts>, and L<perlguts>, again.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ELF          (      4   d   4    (                  x  x               @                                         $   $         Qtd                          Rtd                         GNU hF!n%   W         A <( h@u@CKq `W   Y       Z   [   \   ^           `   b       d   f   g       j       m                   n   p   r   t   x           y   z       |             &+<#&<#&B 4rQ&U_2AZZ6G=iC$:Xy,KqX|X+}s&9ICEZ	NhU~SJW}wT<                    (       	                          A             \             )             L           "                               $                           _                           @                                       m                                       ~                                                                                                                                                                                       j                                                    L                            }                                       	                                                    m                                        w             [             $                          #                                                    f                           Z             M                          |                                                    [                                         R                          4             a                                                    ]             F             2               @                                        )             S             '             0               x%         P      ?  `  T    G  8!  \     o  \M      S  $          p                   0"  p     V  b  L                 #        k  <       <m      )  <\        %                  dI          X P     o                     "  h       k          7  8       Hl         LE         D       ?  6                 !       n  !       0  !       f  B  $    t           D         @&  l      H       ;  `J        l  <                P                 (       	   8X         D        __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses recursive_lock_release pthread_mutex_lock pthread_mutex_unlock Perl_croak_nocontext pthread_cond_signal PL_sharedsv_lock sharedsv_array_mg_copy Perl_sv_magicext PL_charclass sharedsv_elem_vtbl sharedsv_scalar_mg_dup sharedsv_elem_mg_dup Perl_sv_2iv_flags sharedsv_array_mg_dup recursive_lock_init memset pthread_mutex_init pthread_cond_init recursive_lock_destroy pthread_mutex_destroy pthread_cond_destroy sharedsv_userlock_free recursive_lock_acquire pthread_cond_wait Perl_save_destructor_x Perl_push_scope Perl_pop_scope pthread_setspecific Perl_save_strlen Perl_free_tmps Perl_sv_free2 PL_sharedsv_space PL_thr_key sharedsv_array_mg_free sharedsv_scalar_mg_local sharedsv_array_mg_FETCHSIZE Perl_hv_placeholders_get Perl_av_len malloc sharedsv_userlock_vtbl Perl_hv_iternext_flags Perl_hv_iterkey Perl_newSVpvn_flags __stack_chk_fail Perl_croak_xs_usage __stack_chk_guard Perl_hv_iterinit Perl_hv_common_key_len Perl_sv_2pvutf8 Perl_av_exists Perl_av_fill Perl_av_extend Perl_sharedsv_find Perl_mg_find Perl_sv_derived_from sharedsv_scalar_vtbl sharedsv_array_vtbl Perl_shared_object_destroy Perl_croak Perl_sv_2pv_flags Perl_ckwarn Perl_gv_stashpvn Perl_sv_bless Perl_sv_2mortal Perl_newSVpv Perl_warner pthread_cond_broadcast Perl_newSViv Perl_newSVuv Perl_mg_get Perl_sharedsv_associate Perl_newSV Perl_sv_setref_iv Perl_sv_unmagic Perl_sv_upgrade Perl_sharedsv_share Perl_mg_set Perl_newRV Perl_sv_setsv_flags sharedsv_scalar_mg_get sharedsv_scalar_mg_free Perl_sv_newmortal sharedsv_array_mg_CLEAR Perl_av_clear Perl_hv_clear sharedsv_elem_mg_FETCH Perl_av_fetch sharedsv_elem_mg_DELETE Perl_av_delete Perl_av_shift Perl_av_pop Perl_sharedsv_cond_timedwait pthread_cond_timedwait Perl_sv_2nv_flags Perl_sv_setiv sharedsv_scalar_store sharedsv_scalar_mg_set sharedsv_elem_mg_STORE Perl_av_unshift Perl_newSVsv Perl_av_store Perl_av_push Perl_sharedsv_unlock Perl_sharedsv_lock Perl_sharedsv_locksv Perl_sharedsv_init perl_alloc perl_construct boot_threads__shared Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_newXS_flags Perl_call_list libpthread.so.0 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                                                                                                      ii                    ii                    ii                     x \  |       n      p      $   }   ~   '   g   x   j   X   i   C   O   z   |   W   a   u   [   `      Z   {   Y   h   v    f  4 l            r         $ 	  ( 
  ,   0 e  4   8   <   @   D   H   L   P   T   X   \ [  `   d p  h   l   p   t   x t  |    o             !   "   #   _   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   j   6   7   8   9   :   ;    <   =   >   ?   @   A   w   {    B  $ D  ( E  , F  0 G  4 H  8 I  < J  @ K  D L  H M  L N  P b  T P  X Q  \ R  ` S  d T  h   l U  p V  t c  @- -f          | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $           0 0   R/[`b   404 0  00` S 00/ 0  S//d |d $b   88   `,0A0/ 0  S//4d 0d a   @-H0H 0  0  S400  S  
(0 0 0  c a |  4c c 8 @-    ,0  R0  @ 0  S
3/D` (a       8@- P @  P  0 S
  
   P8 p p    000C  S00  n  P
 4 4    0        0Q  Q  `Q  hQ  DQ   Q  0 0p@- P@ u  P   @O  P   TpP0 0p@ 0/ 8 8    00 ( (     0`   $b P  P    P  P    p@-Mp@p@
Pd `Q ^P $P|  0`P-   000p\_       0    S   /@-0   
80 0S  
   P000   0    0    S   /@- @P  ~   P
      P ( (    0b     0\N  dO  0O  N  @- @  P
      P , ,    0G      0@N  <O  pN  N  p@-P  U	  
@P  `P   `  p     0%N   N    @- ` @pp  P$  0 S P     \  P  0  S0`0 t  P  x0  @\000 P P    0 < <    0 ( (    0\   @M  N  $M   M  M  0M  A-  Q$a`P @q/1p   1.0 S  0C0 A] 0  `    P$    4K0040  R   B 0 40 R   A    P
 \ \    T0   0    (0[ L          K  L    L    @-  A-@P  UMp `  
x0x   ?0 00P
0  P   0     XZ   (K  A- P4A`0q,1@p  11  @  k  P2    40040  R  
     P   
 0 40`` R
     M  P     T 0 40 ` @ @    80	 0    0Y J    *      I  J  1  pJ  G-MQp@ `L1P! 1 J 00  S  
 $ R  A   \=  
 0  S  T3  
P!P1     P9   %4 \00 40	  @0	 0 ~0=00 q	P \ P  0 40 R   ?   P   8 @ h h    `0\ \ 	   P0L L    D0,X   I  j  LU~     x  LU  ,H  G    H  G  y  H  G    O-MhRD d2PBpD ` 0a  b B! R @v  `0  
20S_   0   0  01	 	 1!1  P  j PL    400 40  P*  
0  0	W0 40 R      I  P5    X$1	7   P  0 ` ` 0 R   @0 40 R     '  P  0  f ,| 	   p0 h \ \    T0 L L    D0$V      F             F    F  D  E    D  E    O-MxRDt2PLpD `  0a0n C1 S @z  `0  
2 0Sb   0   0  01	 	 1!1  P   PP    40040   P P*  
0  0	0 40 R        P6    X(1	7   PJ  0 ` ` 0 R   0 40 R     t  P  0    x| 	   p04 h \ \    T0) L L    D0"dS      C             4C    TC  B  C    A  B    O-$M(SD $3PB0D `  a 00 c @B! R  `0;\  
20Sc   00 Sa  
0"  RM      >0 pcp' pd0`2  P2/L"L2  P   Pv    4T0 4 0
    pp0 40 R!   D    PQ   =0  W   0 `0 ` 0 RI  $0   	0     ,q1p  1!1  P    P*    40 04  0S   0 
  p 	    > x x    p0Oh 	   40H P    ,0BP            @    u      l?  k  ?  >  ?  x  ?  l?  G- PD 0BD `  Aa0 c@B! RU  |0\>  
 {/   lLL1	 	 <1j8!81  @  /  P/   X 400 40 0 40 R       P#   0` `0 0S	   0  p 0   D T 	   <0 @ 4 4    ,0L    =    _      =  =  l<  `=  a  G- PD 0BD `  Aa0 c@B! RU  |0\>  
 {/   LL1	 	 <18!81  @    P/    400 40 0 40 R   	    P#   0` `0 0S	   0  p 0    T 	   <0M @1 4 4    ,0BK    ;    U      ;  ;  x:  l;  W  p@-@ P `r0 SP  0C S!  n m  P  
0 0 R!  
   
     P  
0	  
h0 0S  
  ~p  pP K  P
00 0 R p 0 p$I   ;       @-0f  P  
  P    O- @D 3 BpD  ` 0a 0bM C1  S  ` SP  
  Q   
    
0     0 00
h20Sj  
  0{      P  
  Rn  
	 0\   U	 000 b   	 P=  
 1  1!1  P    PO   4 00400  
 0 001  Q  
0  S*     [
   '0 40 R       P-   0 ` ` 0 R   00 0x X7  z   Q      d T    L0' D D    <0 G   9     7          7  7   7    5  6    p@- @D0 CD P 0Q 0bC1 S)  0 "  
0o P   
 ( ` G  P  
0 S  
p  ( P ]  P  0P Pp@8 ,        =47  6  6  x6  4  7  p@- @D0 CD P 0Q 0bC1 S)  0 "  
0& P   
 ( `   P  
0 S  
p  ( OP   P  0P Pp@8 ,s        06  l6  ,6  T5  3  3  i  C- PD0 CD ` 0a 0bC1C \w   S0  m  
p0p P a  
 b W  X @P  
0S  
 0 P G  
 O @p W>    P4   P   P%  	   P  
   {  P  0  Sp   P2  0` `      0      0      0     0    xp d X X    P01  2    1  2    1  1    h1  1    T5   5  4  4  p4  H4  1  D1    p@- @D0 CD P 0Q0lC1 S(  P007  P  
  0 `   0P Pp (  P  
0<  (0 X0  0P Pp 4  1  p@- @D0 CD P 0Q0lC1 S#  P0`0   `  P  
 0 `   0P Pp00  0P Pp K0  C-@0qM C RPp `   SB  1p  n0 p@    T0000000P  PG  
1 p R5  
  d!   @   	P  P0 p@  	 T000  
000  R   B n U0  Pp
 p R  
 n 0 S0 S CJ	 \     80 0 P0i  T000=     x/  l.  C- `00  p @   P#   " 4Y0040 `  P  o0 40 R   K    P   	   < <    }? $ $    ~?;     ,  +  +  ,  p@-@0|P	 SP  
 S  hv `X0X   ?  0p p@^: /    `+  </  p@- @D0 CD P 0Q0lC1 S  P0   
`0` `  i 0P Pp '-$,  .  10A-p M 0` P0C  
@  T  
  WX  
09  
  Q  
  RU   B     @   D0@0  0  
   1  0S   
  0   0 0  60  P000    0 R*   0  0;0 0    0     Q  
  R   B 0600  " 
  0dH9      @-`@p P0@  0 0;  
  k00   7      0;00 U87   (    @-`P @0P  0 (6 S  
0  
0P U  
       p 0  &00
  0;000 |6   `'  C  O-MB p`R2@P  2"2`F oo  b  ]  P    4(&00 R40S  
  V:   7P  V9  
  UJ  
 @PE  T
0  
@  T
  R   r   /    PM     0  0     P
 P!P   H1 0  VPP    P  
@  0;0   V  
 :0 40 R   \   @P   U  0 40 R  h h    `0\ \    P0 H    0t5 h&    >      %   &  M  $  %  J  $  #  S  $  O-pLCL3@ 0$M0 0 P0[  
3 0Sl  
   b2`  2  XN  
0 S  
` ve  
"2  @   pP    40  4 0  pp  `0 40 RC     j  Pw    V  
  0-  
  	 000  
  0;0 00   z1!  1y	  0/ 0    0 R@  $ 0 	: 	  0 80,! R  
 0 0 0 >0 `c`&`    0  @   P   1 4h0 4 0    `pp p    ? X X    P0L    @02       #          !     t!  x   `   T!    <!    O-`B2@ pM 00O  
2 P 0SO  
    YC  
 T2T"  H2  'n    P  
 0 SE  
p w3  
!1  @   `PY    40 D4 	
 0 `` 0 40 R     x  PE     0   R6   0 w0(! R     >0 pcp'p 0  @  Q  P%   z 400	40  0
 0 0 0 p p    d0 \ \    T0 L L    ?>.        t           t  x    `  T    D  8  C- @D0 CD ` 0Qa0lPC1 Se  `0{?   '1  x1%tt1  P    P?    4J0040 K0 40 R p&   A    P/   P  0   W  
  R   B  *0` `0 0S   0  p    T    L0u D D    <0n 4R+     E         8  F  (    H  <  C- @D0 CD ` 0Qa0lPC1 Se  `0{?   1  x1tt1  P  c  P?    40040 '0 40 R p&     M  P/   P  0 K  W  
  R   B  0` `0 0S   0  p 8 l I T    L0 D D    <0 4) p    4           5       7     {!k00@-M@[  0z0E0 
  P  
n P      0 R  $    Y      eA'     O-- PD0 CD p @q0@cDAD \   v  
  2 ` 0SX  
  y@ T 000  
` 0` P v  
 | V  [ @P  
0v  
 0 P j  
 i @` VY    PO   P   P@  
 H      P.  0  S`   PK    Z
  0  0  0 0 	 p0
  0  0  	/      0      0     0  tl  \ \    T0 L       I      E  d    ?  L  H       P     H  M    C- p(60T S`@P  
0  0V  
 	8 `P  
#3  P    P    4E00400  S  
 0  0000`;00  0  
 0 0  
  001  Q  
0  S     }0  60  0 40 R       P "   2o7"0 P   P    40 	04   r0S  0  
 0 0  
  001  Q  
0  S  
   Q   
   10  60  0 40 R-     Y  P !   1#0 XU  	  	 00G
  0;00 =(  =     Q  
  R%   B 060     Q  
  R   B 060H  4 `   QPPx x 	   l0 %0 !0 D D    <0#     ,           #            t    C-pA` P1@  1  0 R  * 0  @    P'    4&00 40 A0 40 R       P
         @ @    80o 0    ?i     1      ,     6    O-B2@ 0,MP0 0[ `$0  
2 0S^  
  P0{  
"|O  
 2	 	 =0 Si  
0 y0I  
T"T2  @  S Pz   { 40 04  	0  Q P0 40 R%     5 @PT     8    0  pp0$   0 RG  ,  S"  | p 0  !00! R  
  0 0  0 >0 c)   p 0  @    P    4N0040  0 Pp p    d0O\ \    P0 H 	   ?      P                           O-MD 0BD  @S	!0@cPDA  T p    0; 0  
2 0S  
    b2`  2"2   P    P    400 D40   E0 40 Rf     o  Pp   T 	  N     b  PU    R>   B 0 X=  
0 	
0 Pk  
"l    S.  l ` <   0   @9  P3   b 400 400 ` 0`0000 40 R . B` 0 0 0 0 r       0      x0 p p    h0 `    X0 Ph                   	  (    	  $    	    l	      O-MD 0BD p @lb!  @b`DA  T P   	  
0" Rs  
 0  Tf  
"  @ p 
q!  Z0 `K  
"L    SP  L @ 1
      0    @@	  P@  	 	 40 4 	  9   04  Q  	   f  P      R B   0 W  
p0	 d x0 W0 0 0l@    X X    Q> D 
   <0	 4          X  	              @-   @  @  Q/@-  @ 0   @C     @- @0Q P  
 @Q   X
  p@- P@0@`  l  ^00    P  0 zt0tt  l0     R07pL0'0  7p 4 4    ,0                    G-MD0`CD " p	 0 @
`0f 02A  0R"P0  xpp"0  q\\"0  jHH"0  c44"0  \  "0  U"0  N!0  G!0 q ?! `p0   p`L!0  p` C!0  p` :t!t   l!0 ` /T!T   L!0 ` $44!0  p` !0  p`      0 `  $ R  
 $0  00 0T	  (	  8	  	  $ 	  $	   $	  $	  (	  ,	  0	  4	  	  ,	  ` 	  H	  ,	   	  X0	   	  l	  	  $	    @-panic: MUTEX_LOCK (%d) [%s:%d]  shared.xs   panic: COND_SIGNAL (%d) [%s:%d] panic: MUTEX_UNLOCK (%d) [%s:%d]    panic: MUTEX_INIT (%d) [%s:%d]  panic: COND_INIT (%d) [%s:%d]   panic: MUTEX_DESTROY (%d) [%s:%d]   panic: COND_DESTROY (%d) [%s:%d]    panic: COND_WAIT (%d) [%s:%d]   panic: pthread_setspecific (%d) [%s:%d] obj, oldkey obj obj, index  obj, count  threads::shared::tie    myref, ...  Attempt to bless into a reference   Explicit blessing to '' (assuming package main) myref   Argument to cond_broadcast needs to be passed as ref    cond_broadcast can only be used on shared values    cond_broadcast() called on unlocked variable    panic: COND_BROADCAST (%d) [%s:%d]  Argument to cond_signal needs to be passed as ref   cond_signal can only be used on shared values   cond_signal() called on unlocked variable   ref_cond, ref_lock= 0   Argument to cond_wait needs to be passed as ref cond_wait can only be used on shared values cond_wait lock needs to be passed as ref    cond_wait lock must be a shared value   You need a lock before you can cond_wait    %-p is not shared   Cannot share globs yet  Cannot share subs yet   Argument to share needs to be passed as ref panic: cond_timedwait   ref_cond, abs, ref_lock= 0  Argument to cond_timedwait needs to be passed as ref    cond_timedwait can only be used on shared values    cond_timedwait lock needs to be passed as ref   cond_timedwait lock must be a shared value  Invalid value for shared scalar obj, ...    lock can only be used on shared values  v5.20.0 1.46    threads::shared::tie::PUSH  shared.c    threads::shared::tie::UNSHIFT   threads::shared::tie::POP   threads::shared::tie::SHIFT threads::shared::tie::EXTEND    threads::shared::tie::STORESIZE threads::shared::tie::EXISTS    threads::shared::tie::FIRSTKEY  threads::shared::tie::NEXTKEY   threads::shared::_id    threads::shared::_refcnt    threads::shared::share  threads::shared::cond_wait  \[$@%];\[$@%]   threads::shared::cond_timedwait \[$@%]$;\[$@%]  threads::shared::cond_signal    threads::shared::cond_broadcast threads::shared::bless  $;$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               P                        (     p                      o     
       
                              P     0              o  o   o  o                                                    4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4  4                                                                                                                                                                                                           A.   aeabi $   6 	
"shared.so    .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       x               (             @              0         
  
                   8   o                      E   o       `                T   	      0  0                  ]   	   B   P  P       
         f         (  (                    a         4  4  X                l             @S                 r         p  p                    x      2   p  p                            x  x                                                                                                                                                                                                               H D  `                       p        D  /                                s                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF          (      4   !   4    (                                                                               $   $         Qtd                          Rtd                         GNU 8ko%X   ,          01 B,   /   2    4BE|WqXvT<|Yy                    	       	            #                          P             L           "                                             ?                                                                                              o                                           $                          b                          2                                       u             Q                                                                  [                                          s                           2                            1                          ?                          	                                                    	       	                      ]  8                 __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_sv_2pv_flags Perl_filter_del Perl_warn_nocontext Perl_sv_setpvn Perl_sv_2mortal Perl_pop_scope Perl_ninstr Perl_sv_catpvn_flags Perl_push_scope Perl_save_strlen Perl_save_int Perl_save_sptr Perl_newSVpv Perl_call_method Perl_sv_2iv_flags Perl_filter_read Perl_call_sv Perl_free_tmps Perl_markstack_grow Perl_stack_grow Perl_gv_add_by_type Perl_croak_nocontext Perl_mg_size Perl_croak_xs_usage Perl_newSV Perl_filter_add Perl_savepv Perl_newSVsv Perl_sv_setiv Perl_sv_newmortal Perl_mg_set boot_Filter__Util__Call Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS_flags Perl_my_cxt_init Perl_call_list libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                              ii   !                                 !    &                         	  $  
  (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |       "    #    $    %    '    (    )    *    +  @-w  -                  x p h ` X P H @ 8 0 (             0 0   R/    404 0  00` S 00/ 0  S//      88   `,0A0/ 0  S//l h     @-H0H 0  0  S400  S  
(0 W0 0   T      8 @-    ,0  R0  @ 0  S
3/     8@- @D0 CD  0!Pb UPe  00 0S  
  0A @ P8      O- @DP  U0,  0,M qQ  0  S  &6  %0  %0 0
 00   00    R  
h    ^  
   0 h0    R  
 00  S	  
  (h0    R  
 0 40 ` R     [m   0  [  
(0`  Y`    0  P    0   0  0    0 0 !0A  
 0 `  S^    400 40h0 h0   
  D0H 0 SD0N  
  bB!   "0>  00f SF  <0 0 ` x P `   3`F 0Sm
  _ 0j  	0   [ 0  S	  
0L 0   0  S0`, h  [   0 0 ,H Q<   h D0  0-  ` 0  O zh0 0 00  S0  B
  R  
 005   0hh 0    ^       $0 Y$0    Rh0    R0 0f    G 0 0 00  0  0    00	00 0  S?  	 [0	0    Y+        0  0  0|	f  	0     0 K  l	  0  0  Sd
 0 0     Z i"	 ?" 0Qd    	0 0  D H   00   <    T       4
  D    \    @- @D 0BD P  Q0 c"!)  ,    Rq  
  Q  
`    V  001  S  
 0    00 0y  V   R
` h0   O- @D 0BD ` PMa0cL! RI  l(! p R;  
0  ?00 0 0S1  
   ` )   P
   K  _H        <       b 0 0 0 0` 	        A- @D0P CD  `  aPPeMEQ UF  0  4  
 0q  U`0  
 `0 0S"  
   0h ,      RQ  
 H0  ? 0  p0` ` 00 p  00       H	 @  G-MD0`CD L! 	p 0 @
`0f 01A  0]! `  QD  P0       0 `      0 `      0 ` w  B `$ R  
 $b0  00 0              D    $    P @-**** In filter_call - maxlen = %d, out len buf = %Ld idx = %d my_sv = %Ld [%s]
 BLOCK(%d): size = %d, maxlen = %d
  
   recycle %d - leaving %d, returning %Ld [%s] gonna call %s::filter
  filter  Filter::Util::Call - %s::filter returned %d values, 1 was expected 
    status = %d, length op buf = %Ld [%s]
  filter_read %d returned %d , returning %Ld
 object, perlmodule, coderef size=0  v5.20.0 1.49    Filter::Util::Call::filter_read Call.c  ;$  Filter::Util::Call::real_import $$$ Filter::Util::Call::filter_del  Filter::Util::Call::unimport    ;$@                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             	                           o          d  
   +                 0                |     @         o\  o   o  o                                                     	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	                        A.   aeabi $   6 	
"Call.so *x .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       L                (         d  d  `              0             +                 8   o       l                E   o   \  \                   T   	      |  |  @                ]   	   B       0     
         f         	  	                    a         	  	                  l                              r                               x      2       (                                                                                                                                                                                                                                                                             p           /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ELF          (      4   t   4    (                  
  
               @  D                                          $   $         Qtd                          Rtd                         GNU o$FyKrb1r              1 B          4BE|8{WqXvT<Yy                    x       	                          L           "                                                                                                     [               o              2                                           Q  X       /  T       d  X                P  X       6  T         x       	 B  T          	        \  X        __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_hv_common_key_len Perl_get_hv Perl_newSVpvn Perl_sv_2mortal boot_File__DosGlob Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_my_cxt_init Perl_call_list libc.so.6 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                 %         ii   i              L    8   <   @   D   H                    	  $ 
  (   ,   0   4   @-&  -l
  l d \ T L D < 4 , $ 0 0   R/	 @   404 0  00` S 00/ 0  S//
  
 	 <   88   `,0A0/ 0  S//	 	 P	 H   @-H0H 0  0  S400  S  
(0 0 0  d	 	 8   4	 (	 8 @-    ,0  R0  @ 0  S
3/  D   0@-M(& R  
0,(0 @ 0Q   Q  
 0D 0   00  S  
 3/0 |  P   
   8@- D0LD00 @1c Pd 0Q  V00 08G-MD0`CD   	p 0 @
`>0 0f0A  0#P 0P0  (  ,(   d0 !0 $4  R  
 $0  00 0     0       4@-File::DosGlob::entries  v5.20.0 1.12    File::DosGlob::_callsite    DosGlob.c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   D           %     x     	                      o          d  
   s                X                       @         o  o   o  o                                                                                               L A.   aeabi $   6 	
"DosGlob.so  f .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       L                (         d  d                0             s                 8   o       6                E   o                        T   	          @                ]   	   B         X      
         f         x  x                    a                              l                              r         	  	                    x      2   	  	  P                          
  
                                                                                                                                                          L                          L L                             T T                         p        T  /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF          (    (  4   t   4    (                  r  r                  H  L                                       $   $         Qtd                          Rtd                            GNU 54Kh8%4L   O          1 BO   S   V    4BE|(xWqXvT<Yy                           	                                                                5             !             R           "                x                                          1             k                          Z             K             |                          4                                                                                                        ]                                                                  c                                                                     d                                                                                                          s                                       u                           (                                       /             i             a                            j             F                                                                               J             8                            
             G                          =                                        W                                       U             -  L         H       @  L         m  $    ,  L         H                 	   H          n        8  L        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_sv_2mortal Perl_mg_find Perl_newSVpvn Perl_croak_xs_usage Perl_sv_catpvn_flags Perl_sv_grow Perl_ckwarn_d Perl_utf8n_to_uvchr __sprintf_chk PL_utf8skip __snprintf_chk strcmp Perl_mg_get Perl_gv_fetchmeth_pvn Perl_push_scope Perl_save_strlen Perl_call_method Perl_pop_scope Perl_newSVsv Perl_warn_nocontext Perl_safesysmalloc Perl_safesysfree Perl_sv_2pv_flags strncmp strcpy Perl_sv_setsv_flags Perl_av_push Perl_newRV Perl_sv_2uv_flags Perl_av_fetch Perl_sv_setiv __stack_chk_guard PL_charclass Perl_hv_common_key_len Perl_sv_catsv_flags Perl_newSV_type memcmp Perl_sv_catpvf_nocontext Perl_get_cv Perl_call_sv Perl_sv_2iv_flags Perl_sv_free2 Perl_av_len Perl_newSViv memcpy Perl_hv_iternext_flags Perl_hv_iterkeysv Perl_hv_iterval Perl_sv_newmortal Perl_free_tmps Perl_stack_grow Perl_markstack_grow Perl_sv_2bool_flags Perl_instr Perl_gv_add_by_type Perl_sv_cmp Perl_sv_cmp_locale Perl_hv_iterinit Perl_sortsv __stack_chk_fail Perl_croak_nocontext Perl_sv_insert_flags Perl_sv_setpvn Perl_av_clear Perl_sv_backoff Perl_dowantarray boot_Data__Dumper Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS_flags Perl_call_list libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                                                            ii   E                 ii   E                           D     	      $   (   , !  0 #  4 3  8 9  < C  @ M                     $ 	  ( 
  ,   0   4   8   <   @   D   H   L   P   T   X   \   `   d   h   l   p   t    x "  | #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   4   5   6   7   8   :   ;   <   =   >   ?   @   A   B   D   E   F    G   H   I   J   K   L   N  @-  -p                    | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $      0 0   R/l 0  404 0  00` S 00/ 0  S//m m l    88   `,0A0/ 0  S//m m Dl <  @-H0H 0  0  S400  S  
(0 0 0  Lm  l    m m 8 @-    ,0  R0  @ 0  S
3/j k 8   Q  
  Q    / 0- SA0 10C S0A S  S  
000C	 S  P  
000C	 S 00 S  
- S
10C S /  R  
@-    \@  \ S  
 Q	  
0' S@Q Q  /8@- @D0 CD P 0Q0lC1 S  P0 	     0 0P P8V  0P  
  ,0000 X  C-M PQ`p (@1  
  T  0 0  $"   $"0 S  : W  
   0]@T   W    0     c S   PxY  O-p  <MP0 W( $0` *d0 `0S0@4p0`` `,`0p%    Sc  @70 00 UH    Wa    Y\ X 
  Y' XJ 
" X        Y@ X   R 0    0   Z@@ U`    Z,   0 	 
& 00 U        Y X  Y X   X  Y  X   D  Y  X     Y    X $ `    ,  0 d P   0 0 S:  W
` X   Q P    X   Q P   R  Y X
  Y X   0 P   Q	 P  ,0 4p  0  0  $@ ]  
 0   00(`   0"  W @>  *4\`00  Z     " P 0 0   Q\ P  ^    Q@ P  
0  S  
  Q P0 0  Q P0  S^    Q P0 0  Z 00  SU    Q P    @  Zp  
3  00p W: "0 0 0 0(0  h  $000<  0(`   e0'  W   *pGPE\ 0 ' S\ S    W 0'0  0  Y X   0 P   Q	 P`  X   Q^ P`  Y\ X,  ,  P 0  S R `Q   RN  I  D  ?  :  I  4  /  F  E  D  C  B  A  @  ?  >  =  <  ;  :    0` @ , 0 g P	     V         0 @re00@nr00@jf00@fn00@bt00@^b00@Za00@V0&   0  S9  $10 00 U     00 R 0  S	 R   Q P0 0 S  0  @9d  0 P  000 0` 0  000 U  Q? P0 0 S  !0 0 00 0@0 U?   1  0000 0 @Xh @      \T  O-[M `Q ` 0Qd11\010101d01x0101p01X01t01l01h0 
0 @ S  p0  F    Z
  
  S> . Rc  0!0  p   0   P 3 0 
x. Rr  0 00 Y 
0L. R  0pp1  S6 
	   P& 02  010	 0   X 
 0X |0p6   R   X  
0  
 00  SB  | wp 0 0|0 0 0   
  001  Q  
0  S2   Z00 0 000 W 00  S0t  
l ?o20j   0 00b) Si  p0e
 0`|     X        P8  
  p4 sD0H00  SD04 
 
  bB!  00g S
 X0`  p V p0   Y: 
0
 0	 0 S	 
 ;+ 0 Sz	 
0 40 p R	  C0|0p6|   S 0wp 0p  Zg 
!1  R?o2 0  S(  
 0 R%   :0S  000Tjp`  0 p0   p  p 0 `0d! 0 R [>  R 0     ?  R0 0  S&  *l0 :0S: l  0 00  d)	0   1 S  x  00)	0 0 0 x  = d   0  0  2  X   W  	 W 
 Wj 
 W 
 W 
  0  SG  *x0!  S R    R!	  B l(0 0  0`  pP 
0   ' R\ R  S  Q 
    `0  0   0  g '`0 `  ]t0  S  
0  
t0 00  S 0  S  
  R  B  00C 01  S 0  S  Z  Dwp	 Wo  
  V	  
x s  Ru 
&  Rp 
&0 0  0%P  ` 
0 `  p & 0 ` 0 `  S a 
h&0  0 00 \4 |8 l < @ h D H L  Pd x p$X(t,% `0    R  B +% Rd 
0  0x0 x0  S  
pC Wp    S  P  Wx0 0Cx x00 0x 	p: S 4 
$1
9
	S  
  0$  R  Pp 0  x0   0 * 0	p  000 !  R 00
T  P   P  #  U x #p | #0  #  `q  p  
 U
 
  Zd  
 0  0	0`   x0 	!|0 `160   `0  t
  0   W     0 0  00 0 00\48l<@hDHL  dp p $X
(t,  Z  
  R>  B  U 
00P  U   Z
 r Q
lh! Q!  Ro 
    0  x0 010#0
 V :  P
 0    0  0  '`   0 	0p`  0    0  `0   000 0   0   ` $  O  XM   
  <K  `J  dJ  hJ  0J  I  H  G  G  xG  F  G    (  8F  4T  D  HD  D       C     ?  >  >  =  <  =  ;     :  p:  8  (9  7  7  6  6  6  5  4  4   4  T3  H3  <3   0 0  \0`  P?  
 0  S<  
 9  
  Q5  
 	 	0  Pg  
   Xd  
	0    P]  
   QZ  
 10S  0! R 00 0  SM  
H!`0   `  0rx!  ` 0 0 V 
1  S  
0 S   0  0
0    h	    # Y    R$ 0  0\0  B  Rq  B 0 00 0   \0.  P;  
 0	 S8  
 5  
	 Q2  
 	 	0  P 
 `	 V 
1	 S~ 
 0	 S{ 0 W 0 t 
 W 
8#	0 
  .T#p 0 p P    0   |0  0@ S% S 
 W* S6 

   	  0 0000 	 	 $ 0  0\0    R  B 	 \  PO
 Y    Yc <  D   \0    0Ip ;   G P6  
  p4 !D0H00  SD04  
  bB!  00g S `  p  0 P  `  X     V  
   40  0 Q(   M J 50Sn  
  0p &   0pXX \  *86d0X0`   W   0\ S`
/ S`0h   X 0  0 f0C0`0    0 0 l0  x0 0 0  0 $    	0 0  0  0 e   QF 0pp0 P\  0 : SX  0p 00x00 0! ( 0 ` Q t 0,( `0  E40  0 Q  L 00   0 ! 0 0 
0   )0&  d` 0  `( `  0  Xt
 0 }n: S
 00 0	00|0Q  
 0   > 0 *0{    0	    0   $ 0 } 0 p 0])0 0 0 1  S-

  )( i0 0 
0   R El  0! 0  x0 '  0 * 0{p 	  0}   0  0 0|  0  +p 
0 p `  ~H+  0 pw`+  0 pp 0 00 \4 |8 l < @ h D H L  Pd x p$X(t,  R  B | A 0      `` Y 0 @ S0 0 
,0 !  Z 
0
00S0] Sz 
	0p- 
 `>   00 0* S 
00p[0  0 ? 0 `  kx 0 f 0 R0  l=00x=00=00D    0O  0Jp0\$0X0(0t0 ,0100140180l0<01@0h0D01H01L0> % P0	 dx d
 X  0 0  0 Z5  |  0 `0   P  0`  0  1 S]0 p 0 00  00`     `0p  0d   0  A0   0 `   0  V  
  R5  B 0  0@ S0 0G 
/0 @0  S  
0  R  B 0  R  B 	 0  S  
  R  B   YO
  R  B I0 0@ S% Sr   \ Q   Q 
p  0 p
.  0 p  0m.  p 0 ` 
  0% S0 0   
d.0   Z  
0
00S0] SN 
8.0 0  0 0* S 
.` 0  `  0 p  .x  0)h   R 
0 R m 
 `A4 D0H00  SD04 P 
  bB!  00f SL |   h
    ` `  P	  
 0`F   
000 Sp 
   000 40 ` R  0  S  
 < 00<00<00h0  S` 
  Qo 
 h  Yk   YK  	  0  P 
 `(<0S+  000     0c    |  Pp 
 00 ;0S  0  
x0 0     00  1p  S`  
 0 `   00  F0 0
 0  ` 0 0  00 p e1 S  x ,    ^  pp @  R0  0 0
 
 A 0 00 \4 8 l < @ h D H L  P d p$X(t,^  R   B  1  X S    R   B ,  00  1p  S^  `0 0  PA  (0 0!
)
	R 03  
1  S``P  X0O  
 ' R\ R` S  '0  V  0F  
   p0' p       0 
 I8  '0     R S :0 0 0 4 00"  0O   `xL 0 A0   G'0  0  "0 0  0 a |h & pP  
  Y   |  `    Y  0  0% S0 0 
&0 0  R  B 0  R  B 5xp) w `y s   Q, 60w  
 0  S0  |
 00 S   Xv
0    R 
  l%0  0 00 \4 |8 l < @ h D H L  Pd x p$X(t,- x   T P 00 0Q0	`0T   0U pP D0D 08  0  	   , 0 0  0580  
 0!0x0 0
0 0 0{@{ jt#0 $0 000
`	 W0X}0C?o2 0  S
, G    P 
- >0   00`0"0 |    0
  d    0A 0  i 0 ` O  0J  V
  R  B T"0 D"0 0$ 0  0 00 Z
00S}0C?o2 0  S
0 J  F  P 
!0 0  
 3  0  Z
`
p 0{ S|
 0\ SH 

`
p  Z 0{ S
 0\ S0{ S! }  0t p D0   Y  	  0 	  P  $ & .	 |0  .  .  t.   /  .  \.  `-  P-  x,     (    `&  D%  %  #  #  $  "  $  "  L"  T"     8   
  4  ,  |  h        0   |h00  Bl   0 00C   	  0 0  S
0   Y	  0 000   Y	  0 00  0   Y	  0 00 S  
0   Y	  u|1|! 0 S0   Y	  e0 000     Yy	  X0 000 .    Yo	  K0 i  Y	  C0 0 0  Sf
0    R 70 0 00 S0    R  
 00  SP
0 00 0X  YN	  0 000   
  YD	  0 0 0!00   Y< 	 0 00$
0 0  S4	  0 0. D0  0I `00{ S+|` p    ,  P 000|   W P 0`2x0S. SP5 0#10  S   \40   00040 0  X  G    P G    P  0  ; 0 0 00  S
0    RT z0P0X J  i  P"0t J  a  P0  7    Zv.O- DPNOMDP P0M Q0 `c @Lq  Wd `  0lh0  
 S00005   W 
 &4 D0H00  SD04  
 h bB!  00a S h `00   Wp   p  t P  P 4 00 R  hPs 
x    0   P 
`  V 
0 S  0 p,- p  0  PH 
  0; 000 0  0 ,  0  P  
 0 s  R 
,  R  
 0  0 ,  0  P   
  0;00 0  0 @,  0  P   
  0;00 0  0 +  0q  P 
 P< 0S  00x0 0  0 +  0\  P   
 ; 0S  000 0  0 X+  0F  PX   
   Q 
0 8 s  R5 
*
   R0 
X 0  0 *  0(  P  
   Q 
0 & s  R# 
|*|  R 
  0  0 t*0      P 00 l0 00 8*0     P 00 0 00 *0     P 00 0 00 )0  0    P  )0 0     P 00 0 00 l)0     P 00 0 00 8)0     P 00 0 00 )0     P 00 0 00 (0   P  
   Q+ 
0@  s  R 
L(L  R 
  0  0 h(  	0  Pi 
   Q
 
01 Y s  RV 
'  R P 
 0  0 '0  b    P 00 0 00 '0 T  P   
 7 0S  000 0  0 p'  
0>  P 
 7 0S  0!- 0  0  '  0)  P 
 0  S0  
00  s  R	 
x&x  R 
 00 0  S p 
    `  ,  Vd  X0Xp#\600T600L6000t00\000~  r0 S  
50 S  
0  
  0* S 
$ S  
 0   0 
Z\0|0t0x  R 00  S  h0  0 0 d04   8  < X @ x D l H  L  @$ ( ,0 0h0 X t0  `09  l 0{ d 0v  0ql$ 0 d z0 S 
0|  S\00\0 \0 `CXp`  0 Yp 0  P ` `Q Pv  
  0 
8 0 b
+0hQd
"0 
0_ 
 0? 
 0+\ 	 ?A   0  Z|P 0 *   
N0p0b 
 0  S 
0 St 00 
     R
  R` 1 00 
   X
 XK 0X0 
 0  Sr 
0 SX 00 
 0  Sc 
0 SX 00W 
2<0
 
 0! 0 0 0 0  	 0    Y  
  R/  B h0  0 0 d04   8  < X @ x D l mH  L e @$ (, 0  0 R Bh0  * $           
  T        8    \  $        d  4      p        D        t  p        
      P  	         @  @  @  40dp  0 00 0   0 0    0 dplp  0" d 0  0  Y
 0 lp ` Xpl	 
  0  P  
    R  
 0
 V  `0  0	 0  0  0
 V!`  ` 0Xpk  0b0h 0b SF   0p  Sh 0  (   h0 PT  
 Q<  
 Q  
 Q3  
$0 0Xp  RS  B d0  S  
  RG  B 0 S=  
h0$ 00 0 Rp O" R<   0 000 00 0h 	 @0 0\0|0%0 0\0|0  G   -  x 
   0h 0b S,  Oh 0h0   00 00  |d   W
/ 2,  
  
  	 ^<  
 0{@{0 00,  
  
  	 <  
 0{@{0 00,n  
  
  	 /<  
 0{@{0 00,X  
  
  	 <X0
 0{@{0 0X0,=  
  
    
   {@{
0 Php     4 00E Rh  `J   k 000 S00  hP[ 7 8 2  P
00 +X  '  # A  Xx
0 00X0X0s  R
    0 R  S  
0 000S00)  S  
0 000S00x   S  
0 000S00000g00f/ 0-B0 00x0 X8Qd v r    PC
  X        3 DD0>     0h < 0h h0       G-MD0`CD   	p 0 @
`0f 00A  0w  ` PD  P0  t t   l ` 0 $ R  
 $0  00 0<    0          4@-         sv  \x{%Lx} WARNING(Freezer method call failed): %-p    {}  []  do{my $o}    =  {   ref name not found for 0x%Lx    \   Regexp  '   Recursion limit of %Ld exceeded (   re::regexp_pattern  qr/ \/  /   ${  do{\(my $o =    )}  *{  (   [   {SCALAR}    {ARRAY} {HASH}  %Ld #   ,   ]   ->  sub { "DUMMY" } Encountered CODE ref, using dummy placeholder   cannot handle ref type %d   , ' ' ) ()  %Lu panic: snprintf buffer overflow '%s'    main::  undef   Sortkeys subroutine did not return ARRAYREF
    href, ...   Usage: Data::Dumper::Dumpxs(PACKAGE, VAL_ARY_REF, [NAME_ARY_REF])   new seen    noseen  todump  names   indent  purity  terse   useqq   pad xpad    apad    sep pair    varname freezer toaster deepcopy    quotekeys   bless   maxdepth    maxrecurse  sortkeys    $   ;   Call to new() method failed to return HASH ref  v5.20.0 2.151_01    Data::Dumper::Dumpxs    Dumper.c    $;$$    Data::Dumper::_vstring                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              P        o  o  o                    n                       o          d  
   O                                 8              o  o   oD  o                                                                                                                                                                                                                                    D A.   aeabi $   6 	
"Dumper.so   nNN .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                         $                     o       L                (         d  d                0             O                 8   o   D  D                  E   o       @                T   	      8  8                  ]   	   B             
         f                               a             D                l         (  (  [                 r         n  n                    x         n  n                            r  r                                                                                                                                                                                        D                         D D                             H H                         p        H  /                                w                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ELF          (    (  4   b   4    (                  Z  Z           _  _ _              _  _ _                         $   $         Qtd                          Rtd_  _ _                      GNU )x"hvp   :          "3 B:   =   @    4BE|WqXvT<F/	Xy)cn                           	     _                                                            &             R           "                               >                                       u                           1                          +                          }                                                                                                         u             [                                                                     F                           f             ?             h                                                                 S             F                                                     L             \                                        a                            8                            8                           +  `       	  `       >  `       *  `         `                 	   `          HN        `  (J       6  `       r  @J       __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_sv_derived_from Perl_sv_2iv_flags Perl_sv_setuv Perl_sv_newmortal Perl_mg_set Perl_croak Perl_croak_xs_usage BZ2_bzDecompressEnd Perl_safesysfree BZ2_bzlibVersion Perl_sv_setpv pthread_getspecific Perl_newSVpv Perl_sv_2mortal Perl_mg_get Perl_croak_nocontext PL_thr_key Perl_sv_pvbyten_force Perl_sv_upgrade __stack_chk_fail __stack_chk_guard Perl_sv_2pv_flags BZ2_bzDecompress Perl_sv_grow Perl_sv_setnv Perl_sv_utf8_downgrade Perl_sv_pvn_force_flags memmove Perl_sv_utf8_upgrade_flags_grow BZ2_bzCompress BZ2_bzCompressEnd Perl_safesysmalloc memset BZ2_bzDecompressInit Perl_sv_setref_pv Perl_sv_2pvbyte Perl_newSViv Perl_dowantarray Perl_stack_grow BZ2_bzCompressInit Perl_newSVpvf_nocontext memcmp Perl_sv_setiv __printf_chk putchar puts bz_internal_error boot_Compress__Raw__Bzip2 Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_call_list libbz2.so.1.0 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                   ii   C                 ii   C      _    _    `    `   ` 
  `   `   `   ` 4  ` 6  `   `   `   `   `    `   $` 	  (`   ,`   0`   4`   8`   <`   @`   D`   H`   L`   P`   T`   X`   \`   ``   d`   h`   l`   p`   t`    x` !  |` "  ` #  ` $  ` %  ` &  ` '  ` (  ` )  ` *  ` +  ` ,  ` -  ` .  ` /  ` 0  ` 1  ` 2  ` 3  ` 5  ` 7  ` 8  ` 9  @-  -4S  4 , $                     | t l d \ T L D < 4 , $               0 0   R/P    404 0  00` S 00/ 0  S//Q Q P    88   `,0A0/ 0  S//LQ HQ DP    @-H0H 0  0  S400  S  
(0 90 0  P  P    P P 8 @-    ,0  R0  @ 0  S
3/N O        @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   
  P%  
0  0S  
  D  0 P 0  `0p p 0 ^  ` :<0<0 04 40  0 ?     d>  h>  >  ?  ?  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  @  0 P0  `0p p 0   ` <0<0 04 40  0 =     <  <  8=  X>  H>  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   P  P%  
0  0S  
  +  0 Pf0  `0p p 0   ` <0<0 04 40  0V I,<     |;  ;  ;  <  <  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P	0  `0p p 0 G  ` #<0<0 04 40  0 :     :  :  :  p;  `;  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  q8  0 P0  `0p p 0   ` <0<0 04 40  0 D9     8  8  T9  9  9  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   9  P%  
0  0S  
  <  0 PO0  `0p p 0   ` i<0<0 04 40  0? 27      7  $7   8  8  x8  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  D  0 P0  `0p p 0 0  ` <0<0 04 40  0 |7     6  5  6  7  7  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  Z@  0 P0  `0p p 0   ` <0<0 04 40  0 x6     X5  <4  5  5  5  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   "  P%  
0  0S  
    0 P80  `0p p 0 v  ` R<0<0 04 40  0( 4     3  2  44  ,4  4  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P0  `0p p 0   ` <0<0 04 40  0  3     p2  T1  2  2  2  p@- @D0 CD P 0Q 0bC1 S  0   
p0 0S
  
 U ` | 0P Pp 0`(( (0 0    02  H2  1  1  @- @D 0BD P  Q00c#1  0    
 0a9   M0pp  `0PP P ` ~ R8  0 0p@- @ P  !0 `$  	  
@0  s  B R"    ,  s Q  
   Q  
t 9  p@V p T0P0,   )    %0?     
  7  0  0  10A-p`!M  @0  0 Q  \ P  s  R  
h!hQ PRP  
@0;  \s  P#  
 B RB  ;    s0 S!    U%    10S  
  	  0  R*  xS. Q
    R
PPQP    U
t    00<   u,   >        
   )/  5  .  .  <6O-4M0D @0$6B0D `0
 0
 0b C1 S P,s `
p0] 
% >  PX 
 5
  0S  
   @ 4`	 0    0  
x     
L% R  
 0 ( 2(0(	  40 2  
x0 0  00y  
 00  0 00  0  S0  
      
 C a V     Rx  *0 00 0Kb0p  <   S	  
	 5  P   0 r  0  S@   0  p  ``  	   P
0 8   
  @/
 0 
0
@ 30  x3 l0" 0,
 0"<00
0  0 Q  4   R ,      P0  
0|00  " R
  
0 $ d0M0     $ E 0@8  0 0(0L0   8`@ (pDpf0c  b<0D@ 0  
2<;0<000    Q  00@  0D   0   
0  0  R -     0 008   @
 0 

0T!  \ 
@s
g    P&  
0   < 000   0 K  E   +   (   %|0|0 0t t0  00 v L ,<    +     \.     -     '   	\0  *  )  D)  h&  l&  (  '  (  O-MD 0BD ,# @ 
 
 @b PDA T  `
0  
"   P  
 2
  0Sd  
  | @ 0 04`0   
x0 0 y  
 0  S  0  000 0pph0p	    @/o"/ 0  0  S 0 	  p``  @ p a  P8 @ "  
  @0:
   
1 0  S
@*  h!  Q0
 0"<00
  0@  
",+ php !   0@2
   
 0
@0 0   0 0c " 	    P   C 	 T0`0`0 0X X0  0) @        ?5 &     d)  ,     8!  &  #  "  |&  0$  \&  O-MD 0BD (# @ 
 
 @b PDA T  `
0  
"   P  
 2
  0Sd  
   @ 0 04`0   
x0 0 y  
 0  S  0  000 0pph0p	    @/o"/ 0  0  S 0 	  p``  @ p a  P8 @ "  
  @0:
   
P 0  S
@*  d!  p0
 0"<00
  0@  
",+ php !   0@1
   
# 0
@0 0   80 0c " 	   P|   b 	 s0\0\0 0T T0  0H <;      @ 2 #     %  l)       #  d   H  X#     "  $4O-$M0D P04B0D `0 0 0b C1 S @  0p0P0`  
#   P  
 3  0S  
   h 4P  p  
x0 0   
830Sp  
 0  0	  0 p  
x0 0   
 0 0  0  `    	f	   
   P      Q  
  R 0  	` PP   D @P` b   a [8@ D,  
 P0   PK   [P5  !  l0   0"<00 0  0 QD  $ 0 00 0u  
",+ `i` '   P0:   P P0    * 0k "    Pp   U  	  P  
 N _|   F	p0p0 0h h0  01 P$        ?.    h     "     H"  \%       (         \  P  T  p@- @D0 CD P 0Q 0bC1 S  0   
p0 0S
  
  `  '0P Pp 0`(( (0 0        <  ,  @-H  H  @ O-MD0 CD  @3

 b0NPH U 0  @n lu  r  Pr  
   Pm  
 Xu  x#
   R    P Xj  
H#
   R    0 0 X_  
#
   R     XT  
"
   R    p X 	  
 2
 0S~   0 Pp  
	  J pPw   0 PP  SP  ZP   P48  0   00d S Pm  P0@00?  
 Co  P   @  P  
   $ X `P0 0  p`~ ? k  Yz P T!  W 1   0"<000d S8  P@ @   Pe 6 @o   s    b   pu   } %  |00  p0 g0"  0 @  0 @ $)  
                 O-MD 0BD |# P
 
0 @   cBI ^  Pb0lc  s  R`  
,#,   R[  
 Yc   3
  0S   0p YX  
 2
  0S   0 YM  
 2
  0Sz   0 Y 	  
 2
 0Sr   0 P  
0
  [ Pj   pp9 p840  	0  00e S `f  `0P00=  
 Co  P   P! R
  
   , Y `p ` ? u  c ` @!  X ,   0"<000e S3  `P P   py @ @o   z      	 4  |0h0  l  "  0 P  0 P $$  
               H  C-D4PN `DP  PM0 c Bq W @ Pb  ;  
 qh4 0S-  
0   0 0C S  F  O    U  ^    i  w                0D S  
E S  
    0   0 0 R   00 0 0 p|  J  P 00e S  	0  0  0p  0  P    &  P
    P 0H Sc  
K S    P
0F SL  
I Sp    P 
0M SY  
N S8    P 
0N S@  
O S     P 
u    P 
k0F SE  
G Sf    P 
\    P  v
R\    PK k8    P
@    P Z
6    P P
,    P F
"    P <
 E  0j P4y XH!       P      h  P  ,                            @-P   @   U  
p  
   T  
P  @0  0$     0  S  
 q`pPF`  v U
 o  m0  S  
 fq`pPF`  ] U
 Vp  T`  OP4  J@  E0  @   ;   6    1 0      ( 0       0      
 @      x @  D  4  8  @  H  P  h  \                         P    ,                @- @D0 CD ` 0MaPPeEQ0E SH  p08  
! }  P3  
 1  0S%  
  X U p#  000,  s  P  
    P    R
  
   o  0` ` 0 Up H0H0 0@ @0  0u (h      
            `	    @- @D0 CD ` 0MaPPeEQ0E SH  p08  
!   P3  
 1  0S%  
   U p#  000,  s  P  
    P    R
  
     0` ` 0 Up H0H0 0@ @0  0 (d      
     |  `      @    @-  \  G-MD0`CD  # p	 0 @
`0 0f2A  0R"P0  "0  "0  "0  "0  tt"0  ``"0  LL"0  88"0  $$"0  "0  !0  !0  !0  !0  !0  }!0  v!0  opp!0  h\\!0  aHH!0  Z44!0  S 1  0   01 S  $  R  
 $B0  0     2<    $          @  Tl	   	  T  HX       `  T  @     p  x  h  $  <    T     @-End of Stream                   Finish OK                       Flush OK                        Run OK                                                          Sequence Error                  Param Error                     Memory Error                    Data Error                      Magic Error                     IO Error                        Unexpected EOF                  Output Buffer Full              Config Error                                                    Compress::Raw::Bunzip2  %s: %s is not of type %s    Compress::Raw::Bunzip2::uncompressedBytes   Compress::Raw::Bunzip2::compressedBytes Compress::Raw::Bunzip2::total_out_lo32  Compress::Raw::Bunzip2::total_in_lo32   Compress::Raw::Bunzip2::status  Compress::Raw::Bunzip2::inflateCount    Compress::Raw::Bzip2    Compress::Raw::Bzip2::uncompressedBytes Compress::Raw::Bzip2::compressedBytes   Compress::Raw::Bzip2::total_out_lo32    Compress::Raw::Bzip2::total_in_lo32 %s: %s is not a reference   Compress::Raw::Bunzip2::DESTROY %s: buffer parameter is not a SCALAR reference  %s: buffer parameter is a reference to a reference  %s: buffer parameter is read-only   s, buf, output  Compress::Raw::Bunzip2::bzinflate   Compress::Raw::Bunzip2::bzinflate input parameter cannot be read-only when ConsumeInput is specified    Wide character in Compress::Raw::Bunzip2::bzinflate input parameter Wide character in Compress::Raw::Bunzip2::bzinflate output parameter    s, output   Compress::Raw::Bzip2::bzflush   Wide character in Compress::Raw::Bzip2::bzflush input parameter Compress::Raw::Bzip2::bzclose   Wide character in Compress::Raw::Bzip2::bzclose input parameter Compress::Raw::Bzip2::bzdeflate Wide character in Compress::Raw::Bzip2::bzdeflate input parameter   Wide character in Compress::Raw::Bzip2::bzdeflate output parameter  Compress::Raw::Bzip2::DESTROY   className, appendOut=1, consume=1, small=0, verbosity=0, limitOutput=0  className, appendOut=1, blockSize100k=1, workfactor=0, verbosity=0  sv  BZ_OK   BZ_RUN  BZ_FLUSH    BZ_FINIS    BZ_RUN_O    BZ_FLUSH_OK BZ_IO_ERROR BZ_MEM_ERROR    BZ_FINISH_OK    BZ_STREAM_END   BZ_DATA_ERROR   BZ_PARAM_ERROR  BZ_OUTBUFF_FULL BZ_CONFIG_ERROR BZ_UNEXPECTED_EOF   BZ_SEQUENCE_ERROR   BZ_DATA_ERROR_MAGIC %s is not a valid Bzip2 macro   Enabled Disabled    DispStream 0x%p  - %s 
     stream pointer is NULL      stream           0x%p
             opaque    0x%p
             state     0x%p
             next_in   0x%p              next_out  0x%p    =>  %02x              avail_in  %lu
              avail_out %lu
       bufsize          %lu
         total_in_lo32  %u
          total_in_hi32  %u
          total_out_lo32 %u
          total_out_hi32 %u
        flags            0x%x
             APPEND    %s
               CONSUME   %s
               LIMIT     %s
    s, message=NULL Compress::Raw::Bunzip2::DispStream  Compress::Raw::Bzip2::DispStream    bz_internal_error %d
   v5.20.0 2.064   Compress::Raw::Bzip2::constant  Bzip2.c Compress::Raw::Bzip2::bzlibversion  Compress::Raw::Bzip2::new   Compress::Raw::Bunzip2::new Compress::Raw::Bzip2 needs bzip2 version 1.x, you have %s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      P                               HN     _          _       o          h  
   M            `                     
     P         o
  o   o
  o                                           _                                                                                                                                         ` A.   aeabi $   6 	
"Bzip2.so    Q .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       P                (         h  h  P              0             M                 8   o   
  
                  E   o   
  
  @                T   	      
  
  P                ]   	   B              
         f                               a             l                l         (  (   ?                 r         HN  HN                    x         PN  PN  0                          Z  Z                             _ _                             _ _                             _ _                             _ _                            `  `                            ` `                             ` `                         p        `  /                                #a                                  3a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (    P  4   t   4    (                                   T  X                                       $   $         Qtd                          Rtd                         GNU GE{b]   Q           @( A%DQ   V   Y    4BE|sFWqXvT<1Yy                           	                         p                           _                                       R           "                                            
                                                                               A                                                    s             Y                                       .             m             i             O                                        b             T             u             h                                                                                              4                          *                                       "                                                                                                        H             `                          S             H                                                                                C                          a               2                                       <             5             8                                                                                                         5  \         X       H  \       u          4  \         X                 	 &  X       u  ,  	               @  \        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses my_zcalloc Perl_safesysmalloc my_zcfree Perl_safesysfree Perl_sv_derived_from Perl_sv_2iv_flags Perl_sv_setuv Perl_sv_newmortal Perl_mg_set Perl_croak Perl_croak_xs_usage Perl_sv_setiv Perl_sv_setpv zlibVersion memset Perl_sv_2pvbyte Perl_sv_2bool_flags pthread_getspecific Perl_newSVpv Perl_sv_2mortal Perl_mg_get Perl_croak_nocontext PL_thr_key crc32 Perl_sv_2uv_flags Perl_sv_utf8_downgrade __stack_chk_fail __stack_chk_guard adler32 inflateEnd Perl_sv_free2 Perl_sv_pvbyten_force Perl_sv_upgrade deflateTune adler32_combine crc32_combine zlibCompileFlags __errno_location strerror Perl_sv_setnv Perl_sv_pvn_force_flags inflateSync memmove Perl_sv_2pv_flags inflate Perl_sv_grow inflateSetDictionary Perl_sv_utf8_upgrade_flags_grow deflateParams deflateInit2_ Perl_sv_setref_pv deflateSetDictionary deflatePrime Perl_newSViv Perl_dowantarray Perl_stack_grow inflateReset deflateReset inflateInit2_ Perl_sv_len Perl_newSVsv memcmp Perl_newSVpvf_nocontext Perl_sv_setpvn memcpy deflateEnd __printf_chk putchar puts deflate boot_Compress__Raw__Zlib Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_get_sv Perl_call_list libz.so.1 libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end ZLIB_1.2.0.2 ZLIB_1.2.0.8 ZLIB_1.2.2.3 ZLIB_1.2.2 GLIBC_2.4                                                                                                                                                                      P   2   M     8   Z     3   g     '   t                 ii                    ii                 T    0 Q  4 	  8   <   @   D '  H U  L D  P J                     $ 	  ( 
  ,   0   4   8   <   @   D   H   L   P   T   X   \   `   d   h   l   p   t    x !  | "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B    C   E   F   G   H   I   K   L    M  $ N  ( O  , P  @-  -$  $                     | t l d \ T L D < 4 , $                     | t l d \ T L D < 4 , $            0 0   R/ D  404 0  00` S 00/ 0  S//  d 8  88   `,0A0/ 0  S//   P  @-H0H 0  0  S400  S  
(0 0 0  4  4    8 @-    ,0  R0  @ 0  S
3/ h L        r@- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P0  `0p p 0 Y  `  <0<0 04 40  0      <  P  h      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   i  P%  
0  0S  
  >  0 P0  `0p p 0   ` <0<0 04 40  0 wx         $    t  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P40  `0p p 0   ` f<0<0 04 40  0-      T  h         @- @D0 CD P 0MQ0lC1 SE  0 .  
0ap0.  
     P(  
0  0S  
  0   S B  0P0  `0p p 0 ?  ` <0<0 04 40  0                @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   O  P%  
0  0S  
  $t  0 Pw0  `0p p 0   ` <0<0 04 40  0p ]     `  t  d      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  p  0 P0  `0p p 0   ` L<0<0 04 40  0            ,      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  jl  0 P0  `0p p 0 (  ` <0<0 04 40  0 (     x      4  $  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   8  P%  
0  0S  
    0 P`0  `0p p 0   ` <0<0 04 40  0Y F               @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  D  0 P0  `0p p 0 n  ` 5<0<0 04 40  0 @           L  <  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   ~  P%  
0  0S  
  S   0 P0  `0p p 0   ` <0<0 04 40  0        0  X      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   !  P%  
0  0S  
    0 PI0  `0p p 0   ` {<0<0 04 40  0B /X           d  T  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P0  `0p p 0 W  ` <0<0 04 40  0      4  H        @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   g  P%  
0  0S  
  <L  0 P0  `0p p 0   ` <0<0 04 40  0 up           |  l  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   
  P%  
0  0S  
    0 P20  `0p p 0   ` d<0<0 04 40  0+      L  `  D      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  P  0 P0  `0p p 0 @  ` <0<0 04 40  0                @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   P  P%  
0  0S  
  %t  0 Px0  `0p p 0   ` <0<0 04 40  0q ^     d  x~         @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  p  0 P0  `0p p 0   ` M<0<0 04 40  0      ~  }  x      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  kl  0 P0  `0p p 0 )  ` <0<0 04 40  0 ,~     |}  {  8  8  (  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   9  P%  
0  0S  
     0 Pa0  `0p p 0   ` <0<0 04 40  0Z G~     ~  z  ~      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P0  `0p p 0 o  ` 6<0<0 04 40  0 L}     |  x  |  P  @  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  Tt  0 P0  `0p p 0   ` <0<0 04 40  0 {     ({  4w  {      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   "  P%  
0  0S  
  p  0 PJ0  `0p p 0   ` |<0<0 04 40  0C 0dz     y  u  Xz  h  X  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P0  `0p p 0 X  ` <0<0 04 40  0 x     @x  Lt  y      @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   h  P%  
0  0S  
  =L  0 P0  `0p p 0   ` <0<0 04 40  0 v|w     v  r  w  ~  p~  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
    0 P30  `0p p 0   ` e<0<0 04 40  0, v     Xu  dq  v  }  |  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  P  ?PH0  `0p p 0 A  ` <0<0 04 40  0 t     s  o  Du  {  {  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
   Q  P%  
0  0S  
  &D  0 Py0  `0p p 0   ` <0<0 04 40  0r _ s     pr  |n  s  $z  z  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  h  ?P0  `0p p 0   ` N<0<0 04 40  0 q     p  m  r  x  x  @- @D0 CD P 0MQ0lC1 SB  0 +  
0ap0+  
     P%  
0  0S  
  lX  ?P10  `0p p 0 *  ` <0<0 04 40  0 8p     o  k  xq  <w  ,w  @- @D0` CD  P 0Q`0f#1  0    
 0q 0 J-|0
  p0PP P`` p  o|  @- @D0 CD P 0MQ0lC1 SA  0 *  
0ap0*  
   
  P$  
 0  0S  
  $   0P  `0p p 0   ` e<0<0 04 40  0, k     Pk  di  xo  u  t  @- @D0 CD P 0MQ0lC1 SA  0 *  
0ap0*  
     P$  
 0  0S  
  $   0P  `0p p 0 B  ` 	<0<0 04 40  0 l     k  g  0n  s  s  @- @D 0BD P  Q00c#1  0    
 0a   s0pp  `0PP P  `  x  @- h   @ 0 0  ,000l H  0  @- @D0 CD P 0MQ``fFa VK  p0;  
$!   P6  
0!   R+  
  0 `0 
  r  P  
    P  
 000S  
      Q 0   0c03" 000 0  `H0H0 0@ @0  0& (,f      
     8e  Le  k  p  k  @- @D0 CD  P  MQ0 cB! Rp    Q`  
0Y  l-  s  R*  
!   R%  
P0P  
!    PJ  
 h1  0S)   0     V0        S0   0P P  
 0  S!  
0 S  `,  
  <  
 0{@{` `  G  a   S  
0 00`S`` 9 ``D0D0 0< <0  0 $ 
  Df      e  c  i  n  i  0 0p@- @ P  @0 `$  	  
@0  s  B R"    ,  s Q  
   Q  
t m  p@ p 00,   c    _` @   
  t  i  h  l2O-0D`"PLDP `  MaPPe EQ E R @~  0 	 l  
 0q U 	   1  0Sa   0   =  10SH  
    U  000  s  R	  
`!`   R  
       @!@   R.  
    
 j 0`   0(  p0 	0 0 0 R(  x0 0   u  P  
 00S 00 0 0  p  E   8g,   L <     Tf      
      f  f   2G-0D"PLDP `  MaPPe EQ E R @k  0 	 ^  
 0q
   <  10SG  

  ?  U  000  s  R	  
D!D   R  
     `  $!$   R-  
  
  T 0`   /0#  p0 	0 0 0 R#  x0 0  
   P  
 p00S 00 0 0  p J 4	(   & <  c      
      d  d  p@- @D0 CD P 0Q 0bC1 S&  0 &  
0 0S  
 ~ ` H  Q  
  R   B |   P   
 0P Pp 0` $ $ 0 0   g  c  c  g  10A-p`!M  @0  u0 Q  \ P  s  R  
h!hQ PRP  
@0;  \s  P#  
 B RB  ;    s0 S!    U%    10S  
    0  R*  xS. Q
    R
PPQP  /  U
t   . 00<   k,   fH <  @   
   )b  (l  $a  `  O- @D0 CD  P 0MQ0lC1 S  2 0SZ  
  1 0S_  
   1 0SP  
   p1 0S:  
  0   8  
 0a0
0@  
<!    P:  
 1
  0S+  
  ~	 0  0P  ? =0  `0
  0 00   / ` 0p 0 0  <0<0 04 40  0    \  |[  W  `  0c  _  G- @D0 CD P 0Q0lC1 SS  pT1P!0 S7  
 /   1 !  0 S8  
  "   0  0 S!  
  0     
 0a	
  J 0P   L0  `00 0 0 00    ` 0 v 5    p^  G- @D0 CD P 0Q0lC1 SS  pT1P!0 S7  
    1 !  0 S8  
     0  0 S!  
  0     
 0a	
   0P   0  `00 0 0 00   H ` 0      \  @- @D 0BD P  Q00c#1  0    
 0a 0pp   0  `0PP P `  ,e  D0D 0@- @0  ] t  
$ @d  @  yw @  Q  @- @D0 CD P 0MQ0lC1 SF  P06  
! &  P1  
 0`  0S%  
  `` 0 Ppz  0 0   W `  
    0 0"<00P P 00@0@0 08 80  0;  (lR     c  Q  Q  |Z  H]  8]  A- @D0 CD P `MQ0`cFa V  P0u  
"   Pp  
 2  0S]  
   p y  `@  10SK  
  0     0  0 0L   RP  0  ;   0  007   `= 0 j0!  X `  
 &   0 0"<00P Px0 0   a  P   
 00S  0p O T0T0 0L L0  0 4,   R     8Z   	a  Q  O  ,X  Z  X  <X  8O-0D'@N4M D@ ` @a   @b PDApD W, 000p 
'   P 
 x7	  0Si 
    T  0`  Q  
  T r0 SQ 
70  SL 
 D` 0   0  
x    i 
& R@ 
 0 $ $0 0 \0 2  
x0 0  00  
 00  0 00  0  S0   
      
 C a VD    R  * 50S9 
  0 	    000C0b0  l ( p@    P   
 0   
 p  P# 
0 s  
00  
 p%  
  P  0  S 0 	 
p  ``  H  Qr  
 40S`   0 ( <0 L0  P
0 @  SX   P  p $plt

0c  bl0tp 0  
2<;0l000    Q  00  0   0       0 i   ` J 0 `0  T`<  #  ,0 ,  0"<00 0 00 0 Q  4 0  $(     R@   0 n @000 0 T0  SP@   ` J 0 `0`    	   P0  
000  " R  
@0   00  0  R \     0 00
  +0       ,  0  0 0$0 0  0 c 0  `
 0  0 c 0  P
 	 B@  l  P!  
0    	 000 @  Sl @P@	0 O 	!  2]Z       |0h0h0 0` `0  0L   Ps <  P      
  hW     V  (\   	TQ  Q  P  H  F  lP  xR  P  G- @D0 CD ` Ma0cL \  \  
  0 pt  P  
   0 D  Pp  
   0 20  S`  
    `0e  
!    P_  
 1  0ST  
   P 	X>  
  hh V  0 pD p0  P  
Up Pd 0 0 PQ   0 0"<00` `0?o2U0 PD) 0 r0 P X 0   ps 0PP0P0 0H H0  0 0               4I  U  G  C  N  PO  \N  8@- @?   PD  T0P t p    8      8   D  8O- @D0 CD P `$MQ0cN \ x`n\  
  0 H  P  
   0   P  
   0   P  
   0 p  P  
   0   P  
   0  \3\0  So  
    P0  
$#    P  
 2  0So  
    PP  
 2   08\h X`pd 0  0 P  
 4 P00f Sw   TX"0 P  x 000_  
 Co  P:   P$ | 3<0L0 P0  %0000<0<0 00  Q
 a  000  q pb S D 4 0 ?    ` /   X    [0"<000e S  `P P$  @o     0 `  0 PP0P0 0H H0  0e 0R       A  L  LD  P  4>  H>  I  I  TI  @- @D0 CD P 0MQ0lC1 SY  P0I  
h!   PD  
 T1  0S#  
   p s `P!  
 pj 0 0 `v   0 0"<00P P 0p Q `PD  `0 W `b 0 0X ` L0L0 0D D0  0 ,          |=     hN  P<  d<  H  H  G  @- @D0 CD P 0MQ0lC1 SY  P0I  
h! r  PD  
 T1  0S#  
  G p  `P!  
 pj 0 >0 `   i0 0"<00P P 0p  `PD  `0  ` 0 0X ` L0L0 0D D0  0t ,a          =     L  p<  :  tF  ,F  F  @- @D0 CD P 0MQ0lC1 SY  P0I  
h!   PD  
 T1  0S#  
   p  `P!  
 pj 0 0 `   0 0"<00P P 0p  `PD  `0 g `r 0 0X ` L0L0 0D D0  0 ,          =     J  <  8  D  LD  <D  #O- DPN0DP M P0c `Lq  W @p  #Pl R|  
 Y00 T#   Rn  
  M00 `(#(   RQ  
  O00  PN  
"00 `` 80 P$  

   WB  
"   
0 00e S `h  `0P00X  
 Co  P5  0  P 0 R   	r  P  
`0  ST  	 ^H  0
  W\  
 !      P  W!    `   ?   y ` T!  X     0"<000e S3  `P ] @o     0 P 00S  
	      P

 F	l	|  ft  k 0    0 P 8\ <         B  8  8  5  |G     4  @  C-D8PN `DP  PM0 c Bq W @ Pb  E  
 q8 0S7  
0   0 0C S  @  Y  b    h  v                        %  0S S  
T S    T  P  
p    0   0 0 R  00 0 0 p  3  P      )  P  00e S| 	0  0y p0    P `    P
0R S  
S S0    P 0U S  
X S\ 
F S 	   P  0D0C S* !    ~  |{z  0T S  
U S- 
R Sr\ 
   Pk 0F S~  
M S. 
E Sa    PZ 0L0C SR  P  NML      HGFEDCBA@?      P7	 a0T S8  
U S/\  }  P
'@  u  PK
0S S  
T S  h  P>
  `  P 6
  V  P,
   N  P
  F  P 
t 	 <  P
X  4  P 

4 
 *  P  
     P 
    P
    P 
    PC
    P;
t    PD
X    P
<    P00e S    0 P!00 0 Z0$  0p    P 
m    P
e    P
]l    P
U   0 P{  
   Pj
> 	   P b
4    P X
* X <     A  \A  @  >  >  |>  >  T>  ?  =  =  =  =  =  =  4=  ;   =  <  ;  ;  ;  ;  :  :  d;  4;  ;  :  ;  8  x:  l9  D9  9  D9   9   9  08  O- PD 0BD p `Mq `bFaF \ 0r 
& )  Pm 
 5  0S  
   @ V  0p  Q  
 C p  r0 Sm  
50  Sh  
	     
x0 0   
\50S`  
  0 	  0  p0`0l    =  l0 90a0b  Rl0t080)b     
@ 0 000  [  
0  S5  
 |0b00  V00S 00 sM  
 pg  
 0 
0 | )b  0  
0 | )b  ,  0@z   P   p   0cp0@9 0 f0  [@&  \#  0 0"<00   0P 0   p0  00ap0@ 0 =0@   0  P	 0p 0x00bp0 00  \0C 0b
0  
 P 
0  S   0  R G   0  00Z   @v 	   P\  
  |`	P!!  P(  
 P-  
1 P )C  
 Q/  :b R0  0c S  Q  R | pR     0 S9C Q R  90  pj  a Q  00c S   	 G:    p l   d0d0 0\ \0  0 D        ?x*      
  8     9    3  $  $  |3  d0  L3  p@- @D0 CD P 0Q 0bC1 S"  0 "  
0 0S  
 a ` H  Q  
  R
   B  0P Pp 0`  $ 0 0   </  X+  2   /  p@- @D0 CD P 0Q 0bC1 S&  0 &  
0 0S  
   ` H  Q  
  R   B |   P   
 0P Pp 0`  $d 0 0l   (.  D*  1  .  @-P   @   U  
  
 w  T  
h  vX,  qH0  l84  g((  b$   R  
 [   V0  S  
 Or`pPF`  F U
 <  =0  S  
 6r`pPF`  - U
 #P  $@  0      <   D  H  L  T          0!  ;    0p!  /  d  0T!  #  H  08!    ,  0!     |  
 @             aI @  \1  1  1  1  1  1  1  1  2  (2  2  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  \/  1  8/  1  /  1  .  1  .  1  1  .  |.  p.  d.  X.  </  d.  @- @D0 CD ` 0MaPPeEQ0E SH  p08  
!   P3  
 1  0S%  
   U p#  000,  s  P  
    P    R
  
     0` ` 0 Up H0H0 0@ @0  0 (\      
     t    t/  0(  P/  @- @D0 CD ` 0MaPPeEQ0E SH  p08  
! {  P3  
 1  0S%  
  P U p#  000,  s  P  
    P    R
  
   y  >0` ` 0 Up H0H0 0@ @0  0 ({      
         .  &  -  @- @D0 CD ` 0MaPPeEQ0E SH  p08  
!   P3  
 1  0S%  
   U p#  000,  s  P  
    P    R
  
     0` ` 0 Up H0H0 0@ @0  0' (,      
     D  P  ,  $  ,  O- @D 0BD p P$Mq0cL! R L$Pl R  
 00 $   R  
  00 #   R  
  w00 #   R  
  k00 `#   R  
  _00 \#   Rq  
  S00 0#0   R[  
  U00 p  PX  
 2   08\h X``d 0 0 v0     X  
	   "	0   00e S `n  `0P00^  
 Co  P9   P$0  
     R  
  
x0 0 e  
 <0L0  Pk   0	    p   P        `q  b  S    C ?   n ` !  X    0"<000e S  `P P$ P @o r    0 P Ds  0 P    P  
 0  0 _           #    P'  (  L(  O- PD 0BD ` @Ma @bDAD \  p0  
# }  P  
 3  0S  
  R  T   t3` 0S  
  C L 00 D@0   
x0 0   
 0  S  0  0U         Q  `    
V   0`0`F0`U   Vp  
	 
K  R p 0  
  R8    Pj   0  0 pd`@@@    R
p0p0a0 b 0p P00  
2<;0pkp0Z   @ h 0 @0!@     P
 p p   S` bP0p 
 @00:0   @ 0 @y   0 0"<000 0` 0X P
p P0 a ppp 0;    PSh     P0P0 0H H0  0 0             '  #  $  D  P  $    T$  $O- D|4PL$M0DP `0 00l PC1 S @P 0p0P0`  
$ `  P  
 3  0S  
  5  DP  p  
x0 0   
30S  
   0c  0        d 0 p  
x0 0   
 00  0  0U      Q
k
0	  
V    0 0C 0U`  	  %  Pd  0  Q  
  S 0  
` @PP   p tP` k0ca  RP p0t-  0  
2<;0`j`0]   P p 0 P0!P  0   0"<00 0  0 QP  $ P e *  0 P 0 PN  0 0   \ 0B   [   0 S    P[     z  P  
 3 t0t0 0l l0  0 TtH             4 <  \     $     #    ,!      `   T  <   h   G-MD0`CD ' p	 0 @
`0f 0x7A  0hWdd'P0  LL'0  88'0  $$'0  '0  }&0  v&0  o&0  h&0 f ``0  Y  0  Ptt&0   FTT&0  ?@@&0  8,,&0  1&0  *&0  #%0  %0  %0  %0  %0   %0  xx%0  dd%0  PP%0  <<%0  ((%0  %0    %0  $0  $0  $0  $0  $0  $0  tt$0  ``$0  LL$0  88$0  $$$0  {$0  t#0  m#0  f#0  _#0  X#0  Q#0  J#0  Cpp#0  <\\#0  5HH#0  .44#0  '  #0   #0  "0  "0  "0  "0  "0  "0  "0   01 S  \    0  $  R  
 $0  0       T   h   @   tL   T   \   Th    l   dl   \t      `        x    (d  0    l  \  \    <  4      H  l    L  \  |  0    T
  0`
  
    D  4	  HD	    (  d    x}  ,  {L  x  P  x   @     yX   x  v   uT  ds  q
    T  8\  o  `n    @-need dictionary                 stream end                                                      file error                      stream error                    data error                      insufficient memory             buffer error                    incompatible version                                            Compress::Raw::Zlib::inflateScanStream  %s: %s is not of type %s    Compress::Raw::Zlib::inflateScanStream::adler32 Compress::Raw::Zlib::inflateScanStream::crc32   Compress::Raw::Zlib::inflateScanStream::getLastBufferOffset Compress::Raw::Zlib::inflateScanStream::getLastBlockOffset  Compress::Raw::Zlib::inflateScanStream::uncompressedBytes   Compress::Raw::Zlib::inflateScanStream::compressedBytes Compress::Raw::Zlib::inflateScanStream::inflateCount    Compress::Raw::Zlib::inflateScanStream::getEndOffset    Compress::Raw::Zlib::inflateStream  Compress::Raw::Zlib::inflateStream::get_Bufsize Compress::Raw::Zlib::inflateStream::total_out   Compress::Raw::Zlib::inflateStream::adler32 Compress::Raw::Zlib::inflateStream::total_in    Compress::Raw::Zlib::inflateStream::dict_adler  Compress::Raw::Zlib::inflateStream::crc32   Compress::Raw::Zlib::inflateStream::status  Compress::Raw::Zlib::inflateStream::uncompressedBytes   Compress::Raw::Zlib::inflateStream::compressedBytes Compress::Raw::Zlib::inflateStream::inflateCount    Compress::Raw::Zlib::deflateStream  Compress::Raw::Zlib::deflateStream::total_out   Compress::Raw::Zlib::deflateStream::total_in    Compress::Raw::Zlib::deflateStream::uncompressedBytes   Compress::Raw::Zlib::deflateStream::compressedBytes Compress::Raw::Zlib::deflateStream::adler32 Compress::Raw::Zlib::deflateStream::dict_adler  Compress::Raw::Zlib::deflateStream::crc32   Compress::Raw::Zlib::deflateStream::status  Compress::Raw::Zlib::deflateStream::get_Bufsize Compress::Raw::Zlib::deflateStream::get_Strategy    Compress::Raw::Zlib::deflateStream::get_Level   Compress::Raw::Zlib::inflateStream::msg Compress::Raw::Zlib::deflateStream::msg s, byte Compress::Raw::Zlib::inflateScanStream::resetLastBlockByte  s, mode Compress::Raw::Zlib::inflateStream::set_Append  %s: buffer parameter is not a SCALAR reference  %s: buffer parameter is a reference to a reference  buf, crc=crcInitial, offset=0   Wide character in Compress::Raw::Zlib::crc32    buf, adler=adlerInitial Wide character in Compress::Raw::Zlib::adler32  %s: %s is not a reference   Compress::Raw::Zlib::inflateScanStream::DESTROY %s: buffer parameter is read-only   s, good_length, max_lazy, nice_length, max_chain    Compress::Raw::Zlib::deflateStream::deflateTune adler1, adler2, len2    crc1, crc2, len2    Compress::Raw::Zlib::inflateScanStream::status  s, buf  Compress::Raw::Zlib::inflateStream::inflateSync Wide character in Compress::Raw::Zlib::Inflate::inflateSync s, buf, output, eof=FALSE   Compress::Raw::Zlib::inflateStream::inflate Compress::Raw::Zlib::Inflate::inflate input parameter cannot be read-only when ConsumeInput is specified    Wide character in Compress::Raw::Zlib::Inflate::inflate input parameter Wide character in Compress::Raw::Zlib::Inflate::inflate output parameter    s, flags, level, strategy, bufsize  Compress::Raw::Zlib::deflateStream::_deflateParams  inf_s, flags, level, method, windowBits, memLevel, strategy, bufsize    Compress::Raw::Zlib::inflateScanStream::_createDeflateStream    inf_s   1.2.8   Compress::Raw::Zlib::inflateScanStream::inflateReset    Compress::Raw::Zlib::inflateStream::inflateReset    Compress::Raw::Zlib::deflateStream::deflateReset    flags, windowBits, bufsize, dictionary  sv  Z_OK    Z_RLE   Z_NULL  Z_FIXE  OS_COD  Z_ASCI  Z_BLOC  Z_ERRN  Z_TREE  Z_BINARY    Z_FINISH    DEF_WBITS   Z_UNKNOWN   MAX_WBITS   Z_FILTERED  Z_DEFLATED  Z_NO_FLUSH  Z_NEED_DICT Z_BUF_ERROR Z_MEM_ERROR Z_FULL_FLUSH    Z_SYNC_FLUSH    Z_STREAM_END    Z_BEST_SPEED    Z_DATA_ERROR    ZLIB_VERSION    MAX_MEM_LEVEL   Z_STREAM_ERROR  Z_HUFFMAN_ONLY  Z_VERSION_ERROR Z_PARTIAL_FLUSH Z_NO_COMPRESSION    Z_BEST_COMPRESSION  Z_DEFAULT_STRATEGY  Z_DEFAULT_COMPRESSION   %s is not a valid Zlib macro    Your vendor has not defined Zlib macro %s, used s, buf, out=NULL, eof=FALSE Compress::Raw::Zlib::inflateScanStream::scan    inflateScan Wide character in Compress::Raw::Zlib::InflateScan::scan input parameter    Compress::Raw::Zlib::deflateStream::DESTROY Compress::Raw::Zlib::inflateStream::DESTROY Enabled Disabled    DispStream %p   - %s 
      stream pointer is NULL      stream           %p
               zalloc    %p
               zfree     %p
               opaque    %p
               state     %p
               msg       %s
               msg                     next_in   %p            next_out  %p  =>  %02x              avail_in  %lu
              avail_out %lu
              total_in  %ld
              total_out %ld
              adler     %ld
       bufsize          %ld
       dictionary       %p
        dict_adler       0x%ld
     zip_mode         %d
        crc32            0x%x
      adler32          0x%x
      flags            0x%x
             APPEND    %s
               CRC32     %s
               ADLER32   %s
               CONSUME   %s
               LIMIT     %s
        window           %p
    s, message=NULL Compress::Raw::Zlib::inflateScanStream::DispStream  Compress::Raw::Zlib::inflateStream::DispStream  Compress::Raw::Zlib::deflateStream::DispStream  flags, level, method, windowBits, memLevel, strategy, bufsize, dictionary   Wide character in Compress::Raw::Zlib::Deflate::new dicrionary parameter    s, output, f=Z_FINISH   Compress::Raw::Zlib::deflateStream::flush   Wide character in Compress::Raw::Zlib::Deflate::flush input parameter   s, buf, output  Compress::Raw::Zlib::deflateStream::deflate Wide character in Compress::Raw::Zlib::Deflate::deflate input parameter Wide character in Compress::Raw::Zlib::Deflate::deflate output parameter    v5.20.0 2.065   Compress::Raw::Zlib::constant   Zlib.c  Compress::Raw::Zlib::zlib_version   Compress::Raw::Zlib::ZLIB_VERNUM    Compress::Raw::Zlib::zlibCompileFlags   Compress::Raw::Zlib::adler32    Compress::Raw::Zlib::crc32  Compress::Raw::Zlib::crc32_combine  Compress::Raw::Zlib::adler32_combine    Compress::Raw::Zlib::_deflateInit   Compress::Raw::Zlib::_inflateInit   Compress::Raw::Zlib::_inflateScanInit   Compress::Raw::Zlib needs zlib version 1.x
 Compress::Raw::Zlib::gzip_os_code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x                                                     o     D     t  
                   H           x          `         o  o   o  o                                                                                                                                                                                                                                          T A.   aeabi $   6 	
"Zlib.so 4Z .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       \                (         t  t                0         D  D                   8   o                       E   o                       T   	          `                ]   	   B   x  x  H     
         f                               a                             l         P  P                   r                               x                                                                                                                                                                                                   T                         T T                             X X                         p        X  /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF          (      4   $   4    (                                                                             $   $         Qtd                          Rtd                         GNU bh[kcCdQ$.{   <          1B<   @   D    4BEH^+|W< 1qXvT<Yy                           	                                                   0             L           "                                                                                    $                          j                                                                                 C                                                    B                            o                                                                                                           ~                                       [             3             8                                        S             [               b                          )             R             D                          |                          2                                          v                                       -                  o   $      @         ,         q                           	                     8          __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses __getBerkeleyDBInfo pthread_getspecific Perl_get_sv db_version __sprintf_chk Perl_sv_setpv Perl_sv_setiv Perl_croak_nocontext __stack_chk_fail __stack_chk_guard PL_thr_key Perl_sv_derived_from Perl_sv_2iv_flags Perl_sv_mortalcopy_flags Perl_sv_setsv_flags Perl_newSVsv Perl_sv_free2 Perl_croak Perl_croak_xs_usage Perl_sv_2uv_flags Perl_sv_newmortal Perl_mg_set Perl_push_scope Perl_save_strlen Perl_save_int Perl_save_sptr Perl_call_sv Perl_pop_scope Perl_sv_2mortal Perl_sv_2pvbyte Perl_free_tmps Perl_markstack_grow Perl_newSVpvn Perl_stack_grow Perl_sv_setpvf_nocontext Perl_sv_2pv_flags Perl_safesysmalloc memset db_create Perl_safesysfree Perl_sv_setref_pv Perl_hv_common_key_len Perl_sv_isa Perl_sv_setpvn Perl_mg_get Perl_sv_magic Perl_newSVpvf_nocontext memcmp boot_DB_File Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_my_cxt_init Perl_call_list libdb-5.3.so libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end DB5_3 GLIBC_2.4                                                                                                                                        #[H    E                 ii   K                 ii   K                      
            -   6                     $ 	  (   ,   0   4   8   <   @   D >  H   L   P   T   X   \   `   d   h   l   p   t   x    | !   "   #   $   %   &   '   (   )   *   +   ,   .   /   0   1   2   3   4   5   7   8   9   :   ;  @-  -             x p h ` X P H @ 8 0 (                        x p h ` X P H @ 8 00 0   R/@    404 0  00` S 00/ 0  S//       88   `,0A0/ 0  S//      @-H0H 0  0  S400  S  
(0 -0 0   x    P D 8 @-    ,0  R0  @ 0  S
3/$     X1X0C-LM`H! D0  4  P@$   :   4  p S0  S   R)   R$  
 00@0 (  ! 	    0( 0     0 MD  0 R	  L Q0   0        T  T  L  T    x  A- @D0 CD P `MQ0`cFa VS  Pp0A  
<!   P<  
 (1  0S!  
   `0  Q   
  0 0 00 X pp  W    X  
  S  
  00P P 0` 0   R   B  000 <0<0 04 40  0 H     <  0  H  `    G- @D0 CD p 0MqPPeEQ0E Se  1,0 0 I  
0a0I  
`!  $  PC  
 H1  0S-  
   U +   1  0  S  
   0 23/p  P   0?   v0  `0  0 0 U i  ` -H0H0 0@ @0  0	 (L `         8  ,  p  \  P  !C- D1PNpDP P 0MQ`0f C1 S @]   1,0 0 7  
 0a0A  
L!    P;  
 41  0S  
      0  R0  
 00   0 P0  `0   0 R%   0  `0 d13/  P ? L0L0 0D D0  0 ,\    ( <~     4}  (}  |}  X}  H}  X4O-0DLPN DP P p|Mj,J   Z @$`t  3,0 0   
01 0$00(00  
#    P  
 3  0S  
   ` Tp`$ <0X0	 0</  P  <0 080 Z|  
0
P
1040080040080Q0   040 80  0X \< 80 @,  	0</  PV  0P Up  
40  S<  
80  Su   5 00 40<080h0   h0 0   0 070D0H 0 SD0#  
   bB!   p 40 40 p R      p1  0S
  4  D0  ? `P$ P0   0(00t 0 0,0 0 R  |8e 0`O   0   .      xsN 08 	  $0XX  T0  0  d 0 0 x     |        Xy  py  <y  x  x  x  O-p10    (10 0,( @ Pa0  [^     400 400 0  D0H 0 SD0@  
  bB!  00e S1   
 f  6	   ^  .   P0 E 0 P(    PC0 R  
   `0 40 P R      0`  0 P D08     0               w   w  O-p10    10 0,( @ Pa0  [^     400 40f0 0  D0H 0 SD0@  
  bB!  00e S1   
   	        P0  0 P(    PC0 R  
  5 `0 40 P R    =  0`  0* P D08     a0       Z        pu  u  C-p10    10 0,( @ Pa0  YT  x 4 00 400 y0  D0H 0 SD08  
  `@  00e S)    ^  .   P0 E 0 P(    PC0 R  
   `0 40 P R      0`  0 P D08     0       ~        s  t  h h  p@-@P  L   ` Pp  T  
, 0p@  p@|     t  s  .O- DPN<MDP p0 Pq Pl @EQ`E V4 `.0 R  
 N0$ p> 0Sz  
   0n  U6  08.   RQ      U~ 
.   R?        0  s  R  
-  R
  - R5 
 , 0=o  U 0p   B0 U0O  \= 0< ,H=,0  0<  p10 PH0    P  o Pp  
 I P po 0  04 `0 ` 0 R < 00$0~px `23/  Y  
0 
T, 0  0 0%  P 
 0  s  R  
+  R + 	  0P  
$0  S 
 0    +0 
 0  P  
 00  s  R  
`+`  R  
 0  0 \+ 
 0  P  
 <;<+ x 0 S   0 9/ 0  0 + 
 0  P  
 :*  0 S   0 9/ 0  0 * 
 0  P  
 |:|*  0 S   0 9/ 0  0 P* 
 	0  P  
 :* P 0 Sk   0  0 9/ 0  0 )
  0  P  
 9 0S9  
    9/0@0+  
0 8  	  0 00$</ P-  
0  H13/ 00  0    0  00,0 0o   R; 0|2 3/   C0$  P0</  P0  S       C   n   Q( 	 0  P  
$0  S0 
     '00 
 0 P  
 00  s  R  
X'X  R  @2 3/    0  0 \' 
 0 P  
 00  s  R  
&  R  L2 3/    0  0 & 
 0  P  
 6& p 0 SK  
  C  9/ 0  0 |& 
 	0  P  
 $6$& P 0 S.  
  )   0 9/ 0  0 & 
 0  P  
 5%  0 S  
    9/ 0  0 %
  0l  P 0  0 0h  6`%	    P- 
$0  S'    $  0  $% 0 
 0F  P 
 4 0S   0 700 0  0 $ 
 	0/  P  
 X4X$ P 0 S   0  0 9/ 0  0 d$ 
 0  P  
 3#  0 S   0 9/ 0  0 $ 
 0  P
  
 d3 0S   0 9/ 0  0 # 
 0  P  
 0D  s  RA  
"  R<  
0  SK    X  
2 3/ 0  0 0#
  0  P  
 0  s  R  
t"t  R  
 p2 3/0  Si
p2 p3/@033" RE   0000    S
B  
! RI   0000 0  0  S<  
2 3/ 0  0 " 
 0  P
 1!  0 S7   02 3/    G  *   X   j0 0 00   R   02 3/u 0 0   $00       
            0   T|           
    { Tq  q  (q  p      xp   p  o  lo  m  m  0m  Tn  k  k  k  Hj  (k  |l  j  j  Hi  i  <i  h   e  e  Pe  f  |f  f  #G- D3PN`DP P pHMQ00c C1 S @D  P@30,( 0  
 # l  P  
 3  0S  
  S  0(0,0004080<0@000000 0$0$0(  0</    Z W  00a  0T"  S   `0 a   SZ  0 02000  S1  
80  Sv    4"00 408080h0 h0 0   0 070D0H 0 SD09  
 a A  p0m0 40 R   $0  13/  P  
0  090D P P 0 R2  H 0} : .0 0   00t0: +D0 08 	  $0tt  p0  0   0 0  @4 4  l    Lm a     4b  ^  ^  ^  ^  ^  b  #G- D3PN`DP P pHMQ00c C1 S @D  P@30,( 0  
 # y  P  
 3  0S  
  `  000000 0$0(0,0004080<0@0$0 ( 0</    Z W  00a  ,0T"  S  ( `0 a   SZ  0 02000  S1  
80  Sv    4/00 408080h0 h0 0   0 070D0H 0 SD09  
 a A  p0z0 40 R   $0  13/  P  
0  0F0D P P 0 R2  H 0} G ;0 0   00t0G 8D0 08 	  $0tt  p0  0   0 0  @4 4  h    i ]     h^  Z  Z   [  Z  [  ^  `3G-0DT#PNDP P pHMQ``f  Fa V @D   P30,( 0  
"   P  
 2  0Sx  
  n ` 000000 0$0(0,0004080<0@0`$0 ( 0</    Z M  00l   0 SX  
0"  S   `0 a   SS  0 020(0  S1  
80  Sg    4:00 408080h0 h0 0   0 070D0H 0 SD0  
 a A  p(0 40 R   0D P P 0 R,  H 0` _ _D00    B?r 0   00t0Y >0d0d0 0\ \0  0 @8 8  e    e Y     Z  PW  DW  [  tW  x[  W  [  `#G- DT3PNDP P pHMQ00c C1 S @D  P30,( 0  
"   P  
 2  0Sx  
   ` 000000 0$0(0,0004080<0@0`$0 ( 0</    Z M  00l   0 SX  
0"  S   `0 a   SS  0 020(0  S1  
80  Sg    4S00 408080h0 0h0 0   0 070D0H 0 SD0  
 a A  p(0 40 R   ,0D P P 0 R,  H 0` x xD00    B? 0   00t0r W0d0d0 0\ \0  0(  @ 8 8  'ta    b PV     V  S  S  $X  S  S  S  W  L4O-0D@PN DP  |M	PPe,EQ   U @$`t  3,0 0 q  
01 0$00(00  
#    P  
 3
  0S  
   ` 0H0L0P0T0d0h0l0p0<0@0D0X0\0`0`$ X0<0 0</pUu  
40080	P080040Q0   0080  $ \00X <00@04  0</  Pn  pWPER  
40  S;  
80  Ss    V00 408h0 4 u h0 0   0 070D0H 0 SD0$  
   bB!    40 40  R   * t  l1  0S
  380   p pD0   0 `P$ P0   0(00t 0 0,0 0 R  |  ? 0`Oo   1  3    x 08 	  $0XX  T0  0   0 0 ]    t^ xR        O  O  O  O  O  <O  0p@-@MP   @ 0  a@@@@@@@ @$@(@,@0@4@8@<6/<  P 0   0 R  @pTY    C-pD0 CD P 0MQ0a @C1 SS  T1,0 0 .  
0a0.  
!  k  P(  
  1  0S  
  R $ 0P  ? 0  `0  0   `  08 	  $0PP  L0  0  e 0 0   [hY |M     L  L  L  L    Q   /8@- P$ @]0    P8 00  MP  5O-0D%PN DP  TMppg Gq  G ^ @L S `50,( 0> 
h%   P9 
0T%   R  
  0 P, 0  R6  
80  S3  H 400 408O080h0 	 h00  D0 H0' S  D0  
 a A  ,0 40  R   	   0000 0$0(0,00    Q  
  s Q  
  Q00  Q  
00 	 00 0   W  
  #   R      048<@DHP    h </p    Z J  00  40#  S  0 `0 a   S  0 02000  S1  
80  S    4500 408080h0 h0 0   0 070D0H 0 SD0e  
 a A  00 40 R=   0L `0 ` 0 Rf  T  00   P  s Q  
  Q0 0  
0000mPQ  
	       60  00e 0 * 	00 %D0 0   00t0&s 0b D000 0 0  0 ld d  T T  V    @W tK      
         J  tF  hF  PK  F  (K  F  8K  F  `J  8O-0D@PD DP P `\MQ b @N ^ T@ X8X(0 S 
 Z <8 0, 0 1 0 
 00	0 
'  H  P 
 7	  0S  
  /  @,0p  S 8  
80  S    4.00 408080h0   Lh    D  H    RD l 
 aA  ` ,x04  ` Q    
P   00 0$0(0,000400B   Q  
  s Q  
ll  Q80  \Q  
80  08 0     @8 < @ D H L P $  0:/ P   0    Zo  p0" <0%  S  8 `0 a   S 0 0200  Z3  
80  SE   400 408080h0 xh0 0   0 070D0H 0 SD0 
 a A  `00 40 R   t 0  ? 
 P0  0T 	0  0 R  \  80 x0  p 000 0@    s Q  
  Q  
 0 0 0 0 80UpQi  
    0   z@3 Z\  
  Z00w   0 Sm  
 0#  S   n`0 a   S|  0 020(0  S2  
80  S   k 400 408r080h0 h0 0   0 070D0H 0 SD0_  
 a A  `(>0 40 ` R   0
  0  @ D    0 B D 0    B? 0 0 0   00t0 0   00t0x D0 D000 0 0  0    kp p  d d  hP        P D      
     D  xA  =  x=  B  =  pB  =  HB  =  A  =  \A  d:O-0DXPN DP ` pMahH H ^ @u :,0 0  
00P 00Q 
)   0P0J 
 9  0S 
    P,0  S6  
80  S?  i 400 408p080h0  h00  D0 H0' S  D0 
   bB!   p ,<0 40 p R}      0,0004080<0@0D0  0 SL 
  r0 S  
@8@0 S
  480S  
  0, 0004 0  R6  
80  S  	 400 408080h0 n h00  D0 H0' S  D0 
   bB!   p 40 40 p R   i    0H0L0P0T0X0\0`0W   r0 S  
60 S  
 X   6  0  S   000,d P  
0$H0  S      $ 0P ( </  P    
6 P 
0  P 00  S  ?R  
0 0<  0 S2 
00%  S  , k`0 a   S3 0  020(0  S 
80  SL  g 400 408n080h0 h0 0   0 070D0H 0 SD0  
 a A  p(90 40 R      0    	`30   0 0 00 0 R   0 0 40S/   0 0 XH L0N,d P  0 $H0 
     $0  0
0, </ 00  P   0x3 PWd   0Pq  0  L  r0 S
  
30 S0 0  
0,0020S@  
  @  '   ~   8 0 S$ 0
  </ 00( 0dh     0       0</  P*  
(0 13/   0  0I gB  Q F 	KI P  K = SD0 OD0v( 
 0 </(0  13/ c >D0   0,0    B?N $0   0   00 t0.00 0 0  0    tl l  ` `  TG    G  <      
         l9  2  2  7  2   3  7  7  2  2  2  6  6O-0D@PD DP P p\MQ``f Fa@F T T 60, 0@1 0  
0	0o 
<&
  [  Pi 
0$&	   R  

  B0 @, 0  R 8  
80  Sd 
  
 4A00
 408080h0
  
 _h    D  H '  Q D 
 n
 N  p,04  p Q  
 
 c   00 0$0(0,000400    Q^  
  s Q  
  Q80  QC  
80
  0	8 0    V  
  `$\   R       @8<@DHLP    ha 6/  P   0G  `   
 P90  0T 	0  0 R  \  80   @X(  <  s Q  
88  Q  
 0 0 0 0 80Qf  

  z  a0  
 h2 PY  
  P  0`0o  <0"  S 
 8 `0 a   Sh  0 02000  SX  
80  S  
 
 4Y00
 408080h0
 6h0 0   0 070D0H 0 SD0G  
 a
 A  p00 40 R  
 2   0d
  00I 0  0W
 {
 e]
  a P
  c 0
 jD   0=
 W0 0 
  00t0c
 TD000 0 0
  0 |t t  h h  `  ?<    0= <1      
         /  |+  p+  0  +  0  +  <0  +  h/  4O-0D@PD DP P DMQ`	`f Fa@F T < 40, 0@1 0  
0q0  
@$
    P  
0($   R  

  v0 @, 0  R 7  
80  S  
  
 4u00
 408080h0
 R 
 h    D  H '  Q D  
 	n
 N  ,04  Q  
 M
    0 0$0(0,00040800    Qa  
  s Q  
  Q
  Q4  

  A0  $0 V/   |2 x 0  Sd   00s  R @"  $0  13/  P   0#  
 P~0[  p0< 0  0 Re  D 0 00@ 0   TA  4/  P   01 P   ? 0  @VZ  p:  s Q  
44  Q  
 0 0 0  $0Q  

    0  
 f
   0 0
   0h
 
 DBx0x0 0p p0
  0 TL L  \5     6 *      
         $&  &  +  H&  *  X&  *  86O-0D@,PD DP P p\MQ``f Fa@F T Ti 50, 0@1 0 
0	0L 
%
  E  PF 
0%	   R  

  ,0 @, 0  R6  
80  SE 
 
 4,00
 408080h0
 	
 Kh    D  H '  Q D 
 n
 N  p,w04  p Q  
 
 O  00 0$0(0,000400    Q  
  s Q  
    Q
  Q  

 8 80  004 0  R 7  
80  S  
  C
 400
 408J080h0
  
 h    D  H '  Q D  
 n
 N  p404  Q  
 
    080<0@0D0H0L0P00  7  s Q4  
  Q/  
 V   2  0  S  

  p0  @ 80 ,B4/0P  ?
 0S  0T 	0  0 Rv  \ 0 0zQ   0 08 <0  @
  a0    s Q  
dd  Q  
 0 0 0  0S,Q  

    0  
 {
 xw 0
 h0
 Z
  ^ 0u
 eDS
 aD00 0 0
  0' h ` `  'T T  "40    0 $      
              %    $          `$  H$O- D<4PNTM0DP p Pq 000c @C1 SL   3,0 0   
 0	0  
#    P  
0#	   R  
  0 `, 0  R5  
80  S    400 408
080h0 h
 h00  D0 H0' S  D0  
 a A  P,0 40 R|   d
   0000 0$0(0,00q     RJ  
  s  R  
<"<  R00  ," R/  
00 
 0U0 0   P0P4P8P<P@PDPHP`  P h </ 0p/o "0?  0L 	0  0 RI  T   00   `o S  s  R  
!  R0 0  
0000  R  

       A 0 
10 # 5D0bl0l0 0d d0  0 H@ @  )    L* `      
             $  (  4    l4O-0D@`PD DP P DMQ`	`f Fa@F T <  40, 0@1 0  
0q0  
#
    P  
0#   R  

  f0 @, 0  R 7  
80  S  
  
 4e00
 408080h0
 B 
 h    D  H '  Q D  
 	n
 N  ,04  Q  
 =
    0 0$0(0,00040800t    QK  
  s Q  
PP  Q
  DQ2  

  10  $0 V   2  0  S  

  0   @0 TA04/0P  ?
 p0B  p0< 0  0 RL  D 0 0  @l`  pP  s Q  
    Q  
 0 0 0  $0Q  

    0  
 | 0
   0
 
 	D]t0t0 0l l0
  0 PH H  %    %       
         P  D    t         C-D 7PN `DP  PM0 c Bq W @ Pb  7  
 q6 0S  
0  x 0 0C
 S  (  A  Y  i  w               00 0	0N SR 
O S  
    0   0 0 Ro  0 p  .  P 00e S: 	0  0, 0p0L0C S        0L S 
O S  
I S    P 
0S S 
T Sn  
M S    P=  
0O S  
R SU  
I Sd 	   P.  
0E0C S  ~}|{    xz  
0C0C Sr  ponmlkji  g  edc        PZ  Y    P k
Ld    P
DH    P
<, 	   P Q
2  v  P G
(  l  P
   d  P
  \  P -
  R  P#
l  J  P 
H 
 @  P
, 
 8  P
 
 0  P
 
 (  P 
 
   Pc 
 
   Pn
 
   Pf
t 
   P  
P 
   PT
4    PL
 .  0 P    P9
 	   P1
    P 
 d            X  ,      <            H                      T  (  0  L    ,    l  C- PD0 CD ` 0a0lC1 S  t2,0 0 a  
0p0   
42 0SP  
  c @@  Y  N  
 0 `0Q    Q  
  RW   B   Q  
  RI   B   Q  
  RJ   B (  Q  
  RE   B ,  Q  
  R@   B 0  Q  
  R,   B 4  Q  
  R   B  0p p 0@  $0 13/0	 H13/    Y } z w t q n k ,$$$ $0  0            A- @D0 CD P `MQ0`cFa VS  Pp0A  
<!   P<  
 (1  0S!  
   `4  Q   
  0 4 00 X pp  W    X  
  S  
  00P P 0` 4   R   B  040 <0<0 04 40  0 
     	  	  X  
  	  A- @D0 CD P `MQ0`cFa VS  Pp0A  
<! \  P<  
 (1  0S!  
  C `(  Q   
  q0 ( 00 X pp  W    X  
  S  
  00P P 0` Z(   R   B  0(0 <0<0 04 40  0H A@	     4  (    X    A- @D0 CD P `MQ0`cFa VS  Pp0A  
<!   P<  
 (1  0S!  
   `,  Q   
  0 , 00 X pp  W    X  
  S  
  00P P 0` ,   R   B  0,0 %<0<0 04 40  0      |  p       D  O-MD0`CD |$ p 
0 @	`0f 0L4 A 0<Tl88$P0    $0  $0  #0  #0  #0  #0  #0  #0 c `0  {hhp 0P `HH	  ph00   `` 0  pV0   `M 0  pD0	   `<0	   p4|0   `,`0   p$DD"0   `(("0  "0    "0  !0  !0  !0  !0  !0  !0  t10  h  PX(   P   0 0$ R  
 $0 
 0
             H  
  0
  
  lt	  0	  X|    8X  x   \  H  8  (        t|   P  <<      (
  (
  |t  	        @-DB_File::db_version DB_File::db_ver DB_File::db_185_compat  DB_File needs Berkeley DB 2.3.4 or greater, you have %d.%d.%d
  %d.%d   %d.%03d%03d db, code    DB_File %s: %s is not of type %s    DB_File::filter_fetch_value db  db, flags=0 DB_File::sync   DB_File::fd db, ... recursion detected in %s    filter_store_value  DB_File btree_prefix: recursion detected
   DB_File btree_prefix: expected 1 return value from prefix sub, got %d
  DB_File btree_compare: recursion detected
  DB_File btree_compare: expected 1 return value from compare sub, got %d
    DB_File hash callback: recursion detected
  DB_File hash_cb: expected 1 return value from hash sub, got %d
 DB_File::Error  %s: %s  isHASH, dbtype, name=undef, flags=O_CREAT|O_RDWR, mode=0666, type=DB_HASH   type parameter is not a reference   GOT DB_File::HASHINFO   internal error  DB_File can only tie an associative array to a DB_HASH database hash    ffactor nelem   bsize   cachesize   lorder  DB_File::BTREEINFO  DB_File can only tie an associative array to a DB_BTREE database    compare prefix  psize   DB_File::RECNOINFO  DB_File can only tie an array to a DB_RECNO database    bval    reclen  bfname  type is not of type DB_File::HASHINFO, DB_File::BTREEINFO or DB_File::RECNOINFO filter_fetch_value  db, key DB_File::NEXTKEY    filter_fetch_key    DB_File::FIRSTKEY   Modification of non-creatable array value attempted, subscript %ld  db, key, flags=0    DB_File::FETCH  filter_store_key    db, key, value, flags   DB_File::seq    db, key, value, flags=0 DB_File::put    DB_File::get    DB_File::del    DB_File::STORE  DB_File::EXISTS DB_File::DELETE sv  R_DUP   R_LAST  R_NEXT  R_PREV  DB_TXN  R_FIRST DB_LOCK R_NOKEY DB_SHMEM    R_CURSOR    R_IAFTER    HASHMAGIC   RET_ERROR   R_IBEFORE   R_FIXEDLEN  BTREEMAGIC  __R_UNUSED  R_SNAPSHOT  R_RECNOSYN  RET_SPECIA  HASHVERSIO  R_SETCURSO  RET_SUCCES  BTREEVERSION    R_NOOVERWRITE   MAX_REC_NUMBER  MAX_PAGE_NUMBER MAX_PAGE_OFFSET %s is not a valid DB_File macro Your vendor has not defined DB_File macro %s, used  %s: %s is not a reference   DB_File::DESTROY    DB_File::filter_store_value DB_File::filter_fetch_key   DB_File::filter_store_key   v5.20.0 1.831   DB_File::constant   DB_File.c   DB_File::DoTie_ DB_File::UNSHIFT    DB_File::unshift    DB_File::POP    DB_File::pop    DB_File::SHIFT  DB_File::shift  DB_File::PUSH   DB_File::push   DB_File::FETCHSIZE  DB_File::length                                                                                                                                                                                                                                               p                                                   o          h  
   U                           l          P         o
  o   o.
  o                                                                                                                                                                                                                                                A.   aeabi $   6 	
"DB_File.so  - .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       P                (         h  h  p              0             U                 8   o   .
  .
                  E   o   
  
  `                T   	          P                ]   	   B   l  l       
         f                               a                               l                               r                               x      2       `	                                                                                                                                                                                                                                                                     p          /                                3                                  C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          (      4   B   4    (                  7  7           ?  ? ?              ?  ? ?                         $   $         Qtd                          Rtd?  ? ?                      GNU >G)" vi)   ;           1 F;   >   A    4BE|WqXvT<Xy3                           	     ?       z             O                           Q             L           "                                                                                                                                                                    D             X             \                                                                                 8                                                                                ]                          A                                       8                                                                  |                           [                            i                                                                 1             2               o              k                          &                A         @          A          A         @                	   @          2           A       Q  x,  @     __gmon_start__ _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses Perl_newSViv Perl_sv_2mortal Perl_dowantarray Perl_stack_grow Perl_croak_nocontext Perl_croak_xs_usage Perl_sv_2iv_flags Perl_warn_nocontext Perl_sv_2pv_flags __stack_chk_fail __stack_chk_guard Perl_push_scope Perl_gv_stashsv strcmp Perl_hv_name_set Perl_hv_common_key_len Perl_pop_scope Perl_newSVsv Perl_newSV memset Perl_safesyscalloc Perl_save_vptr Perl_save_destructor __memcpy_chk Perl_save_aptr Perl_newSV_type Perl_save_hptr Perl_save_generic_svref Perl_gv_fetchpvn_flags Perl_sv_free Perl_save_hash Perl_gv_add_by_type Perl_hv_clear Perl_call_sv __memset_chk Perl_markstack_grow Perl_warn Perl_sv_setsv_flags Perl_get_op_descs strlen Perl_newSVpvn_flags Perl_get_op_names Perl_sv_setiv Perl_sv_newmortal Perl_mg_set PL_charclass boot_Opcode Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS_flags Perl_my_cxt_init Perl_call_list libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                                                                                                       ii                    ii         ?    ?    @    @   @ 	  @ 
  @   @   @   @ .  @ 6  @   @   @   @   @    @   $@   (@   ,@   0@   4@   8@   <@   @@   D@   H@   L@   P@   T@   X@   \@   `@   d@   h@   l@   p@    t@ !  x@ "  |@ #  @ $  @ %  @ &  @ '  @ (  @ )  @ *  @ +  @ ,  @ -  @ /  @ 0  @ 1  @ 2  @ 3  @ 4  @ 5  @ 7  @ 8  @ 9  @ :  @-  -T3  T L D < 4 , $                     | t l d \ T L D < 4 , $           0 0   R/0    404 0  00` S 00/ 0  S//1 1 0    88   `,0A0/ 0  S//t1 p1 d0    @-H0H 0  0  S400  S  
(0 60 0   1  0    0 0 8 @-    ,0  R0  @ 0  S
3/. /    8@- @D 0BD   P10c#!'   Pc00  
 Co  P  00e S  % ?x  Z  8I @o  0 P   # 
t!  #  @G-8B8`@ ,M  Pp	0)  
10SO  
 5a P 00? i  0 S  1  W0V   0    00   W  0 RO  F  
 0 QA  D10S!  `0 S  $!  W 1  
    W     P0@ 0  
p q0C s 0   0 0  ` 0B  R0
 p q0C s 0  `00X  P 
v   f  8 
  .    t/             D      x  l    H  @- @D 0BD   M1 cB ^;  P`b  u0 P  
 0 001  P  
0  S  
    P  
   P  
  p  0 p(h $0 X  0 0p kh0 S     `       |  @-, 	  r  P  
h h   P`  	  
  Q  
@  S   ,    +  
  8  ,      0p@-0 @Q  ,8 Pa  
  0 p@   P  0   0
2<;0p+ @- @D0p CD  0  1 lBa"  P   4  S  
 %   R      40  S 121% R    p@- @D0` CD  0  1 l"!  H , P 01   00 0p pt) H  p@- @D0` CD  0  1 lB!
  Ps   00 0p R  @- PD0 CD ` 0a0lC1 S#  0,0` 0q@O  p  T0  
 s  S  50  
  B300 0` ` p(   @@!<1O-0Pp , M @ 0` 	4  S5  
00S-  
  0 Z 0   0 @  
 \   p  W0
 i Q  0dC"
 S    0 R  0  0   &    '    |  p@- @D0 CD P 0Q 0bC1 S  `  Q  
 0P Pp   O-Mr"pD L`D   0 P1 c B ^ @  Pb p2,(0  0Ma0 S  D2D"    [%$2x  
Z
 OK    p i 	 wtp  dp0  S     t0  0 M p 0p0  S    0(,(4@ 0  p 4
   ~0 0  S   0<0 0<0hD0H 0 SD0!  
 PbEQ P000  
 S+ *  Q   P0! P 0 R   #(  /D0 $$    x%    l      t  (  @-pM `@ 0 P,0   0    	  p0  s  R  
HH  \	  
  0  030   "  
  l  0@-0D PN`DP P  MQp g B! R @   Pp0^  
0 y   0 0 0P P 0 R
   0    nX!         @"@ O-$MD@NpD@ 0 `1c @LpN W P@u   ^`l@   1 0Sb  
  10S]  
  0+ p  Y M  
d x1,0  0  1@00  R 0,   @0G0@0p0%0g R  Y3   
00f S   0 7    
`@ T0  \00  ` 0 R  $  0 `
  0 0p00            0  L  G- @D0 CD ` PapPgEQ0E S4  0	 %  
 0 U 0  0 0S  
  } p 0   ?   0  0	0 0 00 p         0@-0,@ M  0       P  
  0  s Q  
 Q  
 : Q  
! Q  
l l0  !0 S  
P   j@   e8   a,   ] H  
           \  0  D3D#0O-,M D A  D p ` P$ ]3,0q @@d7 `d   D1  S0}  000 00(   0@    0,-  
x" R   0p  W  5 W  00f S   0Ap 7    `0  SN  
00 10S
  0   @f  
  Q`  QB    X 0 @0@ 0p0%0g R  Y3   
00f S$   0 7    
`@ T0  \00  S0$  ` 0 R'  ,  0f ` "0 x0   P p  W|T      0L `w( s   Vd           l    !1O- D0AD @,M 0 0 j `$bJ@    Z <  41
00
10 0A0  1	0S&      0p 0 ! Sp B   P0 p  0@ T  
p  0Pp 
	  P
p  0   p 0  $ 00 00 0 Q  ,         2O-0D"@N4M D@ @$   ``f pFa    V P,   0  0(2 0, 0qx  
2"0 Sq   00 0 !0  `   Y   0    VC  
 Y 00!@00# 0(0 
A0  P10S&   (  0p 0 ! Sp B(  ` p 0@ y
 T  
p  0`p 	 ^  P
p  0](  p0  ,  0 0 0$0 0 R  4   0>8   g ,N88         
  8
     	    tO-D h5B,M0D pP 0D%0 `0 0 @$PE0e 05 A 0 U $ `P0   `I$   $0 ` =$0  ` 3$0  ` *xx$ 0 ht`  \\$p0 p HH` p8

 0`  	
 0tp    `
 0    `
 0   `#0   ` `p#p   h#0 ` PP#0 `  p44#0  p` #0  ` "0  p` "0  p`   I5B?  R      ?2,(0 0    s5  S ` p$P@   0 0 30
 C 
   0    v%0` p R  @  a  0 A  41  0S.  
   0    0 B , %A  0 "<r    0$  R  
 $0 $  0 0  0 R  ,  0   x      l  p  x  L  l  D  X  4  0     (                    `  \  L  <  ,               @-opcodes in list context not yet implemented on  off panic: opcode "%s" value %d is invalid  set_opset_bits bit %2d (off=%d, bit=%d) %s %s
  set_opset_bits opset %s %s
 panic: invalid bitspec for "%s" (type %u)   Package main    _   undefined   wrong type  wrong size  Invalid opset: %s   Can't add to uninitialised PL_op_mask   Package, mask, codesv   PL_op_mask restored main::  INC Opcode tag "%s" already defined optagsv, mask   opset, desc = 0 opset, fatal = 0    Unknown operator tag "%s"   Can't negate operators here ("%s")  Unknown operator name "%s"  Unknown operator prefix "%s"    panic: opcode %d (%s) out of range  (opset) safe, ...   Not a Safe object   Mask    v5.20.0 1.27    Opcode::_safe_pkg_prep  Opcode.c    $   Opcode::_safe_call_sv   $$$ Opcode::verify_opset    $;$ Opcode::invert_opset    Opcode::opset_to_ops    Opcode::opset   ;@  Opcode::deny    $;@ Opcode::deny_only   Opcode::permit  Opcode::permit_only Opcode::opdesc  Opcode::define_optag    $$  Opcode::empty_opset Opcode::full_opset  Opcode::opmask_add  Opcode::opcodes Opcode::opmask  opset_len %ld
  :none   :all                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0                          2     ?          ?       o          d  
   '            @                     
     X         oh
  o   o	  o                                           ?                                                                                                                                             @ A.   aeabi $   6 	
"Opcode.so   u>- .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       L                (         d  d  P              0             '                 8   o   	  	                  E   o   h
  h
  @                T   	      
  
  X                ]   	   B              
         f                               a             l                l             #                 r         2  2                    x      2   2  2  L                         7  7                             ? ?                             ? ?                             ? ?                             ? ?                            @  @                            @ @                             @ @                         p        @  /                                +A                                  ;A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ELF          (      4   x   4    (                  T
  T
               L  P                                       $   $         Qtd                          Rtd                         GNU 
Ahs11G[;j            01 B          4BE|WqXvT<$Yy                           	                         R           "                                                            u                                                         :             /                                         a               8                 \       g  X         \         \       n  X                 	 z  X          
           @	         \        __gmon_start__ _init _fini _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Jv_RegisterClasses gethostname Perl_newSVpv Perl_sv_2mortal Perl_stack_grow __stack_chk_fail Perl_croak_xs_usage __stack_chk_guard boot_Sys__Hostname Perl_xs_apiversion_bootcheck Perl_xs_version_bootcheck Perl_newXS Perl_call_list libc.so.6 ld-linux-armhf.so.3 _edata __bss_start __bss_start__ __bss_end__ __end__ _end GLIBC_2.4                                                  S         ii           I         ii                 T    <   @   D   H 
  L   P                	    
  $   (   ,   0   4   8   @-)  -	             0 0   R/<	 H   404 0  00` S 00/ 0  S//p	 l	  	 @   88   `,0A0/ 0  S//$	  	  P   @-H0H 0  0  S400  S  
(0 0 0   t <     8 @-    ,0  R0  @ 0  S
3/(  L   C-LMD `LPD` p0 q0  0c#a @D *   `c f R  @ m    q y  
  x0  0D  0 R  L 0 0 0 0H `H M D      C-MD0PCD   p` 0 @	PE0 0el0A  0XX X0  01$  R  
 $(0  00 0   |   h   l|   @-v5.20.0 1.18    Sys::Hostname::ghname   Hostname.c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                t         I     S          
                      o     4     d  
                   `                 \     H         o  o   o  o                                                                                                    T A.   aeabi $   6 	
"Hostname.so  .shstrtab .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .eh_frame .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .gnu_debuglink                                                          $                     o       L                (         d  d                0         4  4                   8   o       :                E   o       @                T   	      \  \  H                ]   	   B       `      
         f                               a                              l             `                 r         
  
                    x      2   
  
  4                          P
  P
                                                                                                                                                        T                          T T                             X X                         p        X  /                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      require '_h2ph_pre.ph';

no warnings qw(redefine misc);

unless(defined(&_SYS_SYSMACROS_H)) {
    eval 'sub _SYS_SYSMACROS_H () {1;}' unless defined(&_SYS_SYSMACROS_H);
    require 'features.ph';
    if(defined(&__USE_EXTERN_INLINES)) {
    }
    eval 'sub major {
        my($dev) = @_;
	    eval q( &gnu_dev_major ($dev));
    }' unless defined(&major);
    eval 'sub minor {
        my($dev) = @_;
	    eval q( &gnu_dev_minor ($dev));
    }' unless defined(&minor);
    eval 'sub makedev {
        my($maj, $min) = @_;
	    eval q( &gnu_dev_makedev ($maj, $min));
    }' unless defined(&makedev);
}
1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   